{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"gps_frames","text":"<p>Reference frame representation, transformations, and operations for GPS.</p> <p> </p> <p>Documentation | GitHub | PyPI</p>"},{"location":"#installation","title":"Installation","text":"<p>This module can be installed using PyPI: <pre><code>pip install gps-frames\n</code></pre></p>"},{"location":"#running-tests","title":"Running Tests","text":"<p>This module includes tests for all of the major functionality. To run the tests, you can use the commands in the makefile <code>make test</code>. Because some of the functions use JIT compilation via Numba, <code>make test-nojit</code> runs all of the tests without JIT compilation to enable better code coverage analysis.</p>"},{"location":"#using-gps_frames","title":"Using gps_frames","text":"<p>The motivating use case of this module is to determine distances between two points in space while accounting for non-inertial reference frames and non-simultaneous position measures. The <code>examples/</code> directory contains scripts demonstrating the library's capabilities:</p> <ul> <li><code>examples/example.py</code>: A basic walkthrough of creating Positions, checking visibility, and calculating ranges/azimuths.</li> <li><code>examples/case_study_satellite_tracking.py</code>: An advanced case study simulating a 3-day satellite pass from a ground station, demonstrating orbit propagation, coordinate frame rotations, and custom basis projections.</li> </ul> <p>To run the examples: <pre><code># Basic example\npython examples/example.py\n\n# Advanced Case Study (requires matplotlib)\npip install .[examples]\npython examples/case_study_satellite_tracking.py\n</code></pre></p> <p>Note: When first run, gps-frames has significant overhead due to JIT compliation. This should only occur on the first run. Additionally, you may see <code>NumbaPerformanceWarning</code> messages related to the <code>@</code> (matrix multiplication) operator. These can be disregarded and should only appear the first time gps-frames is run.</p>"},{"location":"#ai-disclosure","title":"AI Disclosure","text":"<p>Generative AI was used to assist in the development of this module. All logic and techniques were developed without the use of AI. Following AI models were used: Gemini 3 Pro (High), Gemini 3 Flash, Claude Opus 4.5. The first version containing any AI generated information is version 3.0.0. The final version without any AI generated information is version 2.8.2.</p>"},{"location":"#licence","title":"Licence","text":"<p>The <code>gps_frames</code> module is released under the GNU AGPL v3 license.</p> <p>Copyright (c) 2022 The Aerospace Corportation.</p>"},{"location":"#open-source-licenses","title":"Open Source Licenses","text":""},{"location":"#egm96-data-source","title":"EGM96 Data Source","text":"<p>This module makes use of data related to the EGM96 gravity model. This data was generated by the National Geospatial-intelligence Agency (NGA) and the data used is derived from https://github.com/vectorstofinal/geoid_heights, used under the MIT License Copyright (c) 2015 vectorstofinal.</p>"},{"location":"#pdoc3","title":"pdoc3","text":"<p>The documentation templates are based on the default template provided from pdoc3 and used under the AGPL v3 license.</p>"},{"location":"case_study/","title":"Case Study: The Lost Signal","text":""},{"location":"case_study/#problem-statement","title":"Problem Statement","text":"<p>A nominal GPS satellite (Slot A1) has been launched into a Medium Earth Orbit (MEO). Your mission is to plan ground station contacts for The Aerospace Corporation (El Segundo, CA) over the next 72 hours.</p> <p>You need to answer the following questions: 1.  When can we talk to it? Identify all contact windows where the satellite is at least 5 degrees above the horizon. 2.  When is the signal strongest? Find the time and value of the maximum elevation angle. 3.  How far off-axis are we? At the moment of maximum elevation, assuming the satellite is pointing directly at the center of the Earth (Nadir), what is the angle between the satellite's boresight and the ground station?</p>"},{"location":"case_study/#simulation-parameters","title":"Simulation Parameters","text":"<ul> <li>Orbit: GPS Nominal<ul> <li>Semi-Major Axis: 26,559.7 km</li> <li>Inclination: 55.0 deg</li> <li>Eccentricity: 0.0 (Circular)</li> <li>Start Time: GPS Week 2294, 0.0 s</li> </ul> </li> <li>Ground Station:<ul> <li>Latitude: 33.9167\u00b0 N</li> <li>Longitude: 118.4167\u00b0 W</li> </ul> </li> </ul>"},{"location":"case_study/#mathematical-background","title":"Mathematical Background","text":"<p>To solve this, we rely on coordinate frames and transformations provided by <code>gps_frames</code>.</p>"},{"location":"case_study/#1-orbit-propagation-kepler-eci","title":"1. Orbit Propagation (Kepler -&gt; ECI)","text":"<p>We start with Keplerian Orbital Elements (\\(a, e, i, \\Omega, \\omega, M\\)). While the physics of propagation are standard, we wrap the result in a <code>gps_frames.position.Position</code> object. This ties the coordinates to a specific frame (\"ECI\") and time (<code>GPSTime</code>).</p> <pre><code>from gps_frames.position import Position\nfrom gps_frames.rotations import Rotation\n\n# ... calculate r_pqw ...\norbit_rotation = Rotation(dcm=dcm_combined)\nr_eci_coords = orbit_rotation.rotate(r_pqw)\n\n# Wrap in a Position object\nsat_pos_eci = Position(r_eci_coords, current_time, \"ECI\")\n</code></pre>"},{"location":"case_study/#2-time-control-gpstime-arithmetic","title":"2. Time Control (GPSTime Arithmetic)","text":"<p>The <code>gps_time.GPSTime</code> objects support direct addition of seconds (as <code>float</code> or <code>int</code>), making simulation loops extremely clean:</p> <pre><code># Direct arithmetic with seconds\ncurrent_time = base_time + t_sec\n</code></pre>"},{"location":"case_study/#3-automatic-frame-transformations","title":"3. Automatic Frame Transformations","text":"<p>Once the satellite is in a <code>Position</code> object, we can transform it to the Earth-Fixed (ECEF) frame without manually calculating Sidereal Time. The library handles the time-dependent rotation internally through the <code>get_position</code> method.</p> <pre><code># The library handles the ECI -&gt; ECEF rotation for current_time\nsat_pos_ecef = sat_pos_eci.get_position(\"ECEF\")\n</code></pre>"},{"location":"case_study/#4-topocentric-horizon-frame-enu-basis","title":"4. Topocentric Horizon Frame (ENU Basis)","text":"<p>To compute Azimuth and Elevation, we project the satellite position into the station's local East-North-Up (ENU) frame using the <code>gps_frames.basis.Basis</code> object.</p> <pre><code>from gps_frames.basis import Basis, coordinates_in_basis\n\n# Define the local ENU basis at the station\nenu_basis = Basis(station_ecef, u_east, u_north, u_up)\n\n# Project the satellite position into this basis directly!\nrho_enu = coordinates_in_basis(sat_pos_ecef, enu_basis)\n</code></pre> <p>Note: Azimuth is calculated using <code>arctan2(East, North)</code>, resulting in a range of -180\u00b0 to +180\u00b0, which avoids wrapping discontinuities on plots.</p>"},{"location":"case_study/#solution-script","title":"Solution Script","text":"<p>The refactored solution is implemented in <code>examples/case_study_satellite_tracking.py</code>. It demonstrates how to leverage high-level objects to minimize manual coordinate bookkeeping.</p>"},{"location":"case_study/#running-the-code","title":"Running the Code","text":"<p>Ensure you have the optional dependencies installed: <pre><code>pip install .[examples]\npython examples/case_study_satellite_tracking.py\n</code></pre></p>"},{"location":"case_study/#expected-output","title":"Expected Output","text":"<p>The script will output contact times and angles. Example snippet: <pre><code>Pass 1: T+2.35h to T+6.10h (Duration: 225.0 min)\n...\nMaximum Elevation:\n  Value: 82.45 deg\nOff-Boresight Angle at Max Elevation:\n  Angle: 0.9841 deg\n</code></pre></p> <p>visualization plots will also be generated showing the Azimuth and Elevation profiles for all visible passes.</p>"},{"location":"example_walkthrough/","title":"Ranging Example Walkthrough","text":"<p>This page provides a detailed walkthrough of a common astrodynamics scenario: calculating the range, azimuth, and elevation from a ground station to a satellite, as well as checking for visibility (line of sight) between objects.</p> <p>The example code below is fully commented to explain each step of the process using the <code>gps_frames</code> library.</p>"},{"location":"example_walkthrough/#complete-example-code","title":"Complete Example Code","text":"<pre><code># Copyright (c) 2022 The Aerospace Corporation\n\n# Example: Ranging from a ground antenna to spacecraft\n# ====================================================\n# This example demonstrates how to use the 'gps_frames' library to perform\n# common astrodynamics calculations, such as frame conversions, visibility\n# checks, and range/azimuth/elevation computations.\n\n# 1. Imports\n# ----------\n# We start by importing the necessary libraries. 'numpy' is used for array\n# manipulations, which is central to the 'gps_frames' library. 'gps_time' is\n# used for precise time handling, which is crucial for frame transformations\n# (e.g., ECEF to ECI) that depend on the Earth's rotation.\nimport numpy as np\n\nfrom datetime import datetime\nfrom gps_time import GPSTime\n\n# Import Components that will be shown in the example\nfrom gps_frames import (\n    Position,\n    distance,\n    get_range_azimuth_elevation,\n    get_east_north_up_basis,\n    check_earth_obscuration,\n)\n\n# 2. Setup Scenario Time\n# ----------------------\n# Define the specific date and time for the scenario. This time is used for\n# all subsequent calculations to ensure consistency, especially for\n# time-dependent coordinate frame transformations.\n# We create a GPSTime object from a standard Python datetime object.\ntime = GPSTime.from_datetime(datetime(2017, 9, 2, 12, 0, 0))\n\n# 3. Define Ground Station\n# ------------------------\n# Define the location of a ground antenna. We start with Geodetic coordinates\n# (Latitude, Longitude, Altitude/LLA) as these are most intuitive for ground\n# locations.\nground_antenna_latitude_deg = 33\nground_antenna_longitude_deg = -118\nground_antenna_altitude_m = 30\n\n# Create a Position object for the ground antenna.\n# Note:\n#   - Input coordinates must be converted to radians for the Position object.\n#   - We specify 'LLA' as the frame type.\n#   - The 'time' object associates this position with our scenario time.\nground_antenna_position = Position(\n    np.array(\n        [\n            ground_antenna_latitude_deg * np.pi / 180,\n            ground_antenna_longitude_deg * np.pi / 180,\n            ground_antenna_altitude_m,\n        ]\n    ),\n    time,\n    \"LLA\",\n)\n\n# 4. Define Satellites\n# --------------------\n# We define two satellites in this scenario.\n#   - Satellite 1: Low Earth Orbit (LEO). Positioned to be in view of the ground antenna.\n#   - Satellite 2: Geostationary Orbit (GEO). Positioned to be NOT in view of the ground antenna,\n#     but in view of Satellite 1.\n\n# Define Satellite 1 (LEO)\nsatellite1_latitude_deg = 45\nsatellite1_longitude_deg = -110\nsatellite1_altitude_m = 600e3  # 600 km altitude\n\nsatellite1_position = Position(\n    np.array(\n        [\n            satellite1_latitude_deg * np.pi / 180,\n            satellite1_longitude_deg * np.pi / 180,\n            satellite1_altitude_m,\n        ]\n    ),\n    time,\n    \"LLA\",\n)\n\n# Define Satellite 2 (GEO)\nsatellite2_latitude_deg = -10\nsatellite2_longitude_deg = -30\nsatellite2_altitude_m = 30000e3  # 30,000 km altitude (approx GEO/MEO)\n\nsatellite2_position = Position(\n    np.array(\n        [\n            satellite2_latitude_deg * np.pi / 180,\n            satellite2_longitude_deg * np.pi / 180,\n            satellite2_altitude_m,\n        ]\n    ),\n    time,\n    \"LLA\",\n)\n\n# 5. Frame Conversions\n# --------------------\n# The Position object allows for easy conversion between coordinate frames.\n# Here we extract the coordinates of Satellite 1 in both Earth-Centered, Earth-Fixed (ECEF)\n# and Earth-Centered Inertial (ECI) frames. The library handles the necessary rotations\n# based on the time associated with the Position object.\nsatellite1_ecef_coords = satellite1_position.get_position(\"ECEF\").coordinates\nsatellite1_eci_coords = satellite1_position.get_position(\"ECI\").coordinates\n\n# 6. Visibility Checks\n# --------------------\n# We use 'check_earth_obscuration' to determine if there is a direct line of sight\n# between two objects, blocked by the Earth.\n#   - earth_adjustment_m: Optional parameter to adjust the effective Earth radius\n#     (e.g., to account for atmosphere or terrain). Here set to 0.\n\n# Check: Ground Antenna &lt;-&gt; Satellite 1\nga_to_sat1_in_view = check_earth_obscuration(\n    ground_antenna_position, satellite1_position, earth_adjustment_m=0\n)\n\n# Check: Ground Antenna &lt;-&gt; Satellite 2\nga_to_sat2_in_view = check_earth_obscuration(\n    ground_antenna_position, satellite2_position, earth_adjustment_m=0\n)\n\n# Check: Satellite 1 &lt;-&gt; Satellite 2 (Inter-satellite link)\nsat1_to_sat2_in_view = check_earth_obscuration(\n    satellite1_position, satellite2_position, earth_adjustment_m=0\n)\n\n# 7. Distance Calculations\n# ------------------------\n# Compute the straight-line Euclidean distance between the objects.\n# The 'distance' function handles frame harmonization automatically (converting\n# both to ECEF before calculation).\nga_to_sat1_distance = distance(ground_antenna_position, satellite1_position)\nga_to_sat2_distance = distance(ground_antenna_position, satellite2_position)\nsat1_to_sat2_distance = distance(satellite1_position, satellite2_position)\n\n# 8. Azimuth and Elevation\n# ------------------------\n# Calculate the look angles (Azimuth and Elevation) from an observer to a target.\n# This requires defining a local reference frame (East-North-Up or ENU) at the\n# observer's location.\n\n# From Ground Antenna to Satellite 1\n# First, get the basis vectors for the local ENU frame centered at the ground antenna.\n# Then compute range, azimuth, and elevation.\n_, ga_to_sat1_azimuth, ga_to_sat1_elevation = get_range_azimuth_elevation(\n    get_east_north_up_basis(ground_antenna_position), satellite1_position\n)\n\n# From Ground Antenna to Satellite 2\n_, ga_to_sat2_azimuth, ga_to_sat2_elevation = get_range_azimuth_elevation(\n    get_east_north_up_basis(ground_antenna_position), satellite2_position\n)\n\n# From Satellite 1 to Satellite 2\n# Note: Defining an ENU frame on a satellite is mathematically valid (based on its\n# sub-satellite point) and allows us to compute relative look angles.\n_, sat1_to_sat2_azimuth, sat1_to_sat2_elevation = get_range_azimuth_elevation(\n    get_east_north_up_basis(satellite1_position), satellite2_position\n)\n\n\n# 9. Report Results\n# -----------------\nprint(\"\\n**** Ground Antenna Information *************************\")\nprint(\n    \"Latitude (deg):  {:.2f}\".format(\n        ground_antenna_position.coordinates[0] * 180.0 / np.pi\n    )\n)\nprint(\n    \"Longitude (deg): {:.2f}\".format(\n        ground_antenna_position.coordinates[1] * 180.0 / np.pi\n    )\n)\nprint(\"Altitude (km):  {:.2f}\".format(ground_antenna_position.coordinates[2] / 1000.0))\n\nprint(\"\\n**** Satellite 1 Information (w/ other frames) **********\")\nprint(\n    \"Latitude (deg):  {:.2f}\".format(satellite1_position.coordinates[0] * 180.0 / np.pi)\n)\nprint(\n    \"Longitude (deg): {:.2f}\".format(satellite1_position.coordinates[1] * 180.0 / np.pi)\n)\nprint(\"Altitude (km):   {:.2f}\".format(satellite1_position.coordinates[2] / 1000.0))\nprint(\"-&gt; ECEF X (km):  {:.2f}\".format(satellite1_ecef_coords[0] / 1000.0))\nprint(\"-&gt; ECEF Y (km):  {:.2f}\".format(satellite1_ecef_coords[1] / 1000.0))\nprint(\"-&gt; ECEF Z (km):  {:.2f}\".format(satellite1_ecef_coords[2] / 1000.0))\nprint(\"-&gt; ECI X (km):   {:.2f}\".format(satellite1_eci_coords[0] / 1000.0))\nprint(\"-&gt; ECI Y (km):   {:.2f}\".format(satellite1_eci_coords[1] / 1000.0))\nprint(\"-&gt; ECI Z (km):   {:.2f}\".format(satellite1_eci_coords[2] / 1000.0))\n\nprint(\"\\n**** Satellite 2 Information ****************************\")\nprint(\n    \"Latitude (deg):  {:.2f}\".format(satellite2_position.coordinates[0] * 180.0 / np.pi)\n)\nprint(\n    \"Longitude (deg): {:.2f}\".format(satellite2_position.coordinates[1] * 180.0 / np.pi)\n)\nprint(\"Altitude (km):   {:.2f}\".format(satellite2_position.coordinates[2] / 1000.0))\n\n\nprint(\"\\n**** Line of Sight **************************************\")\nprint(f\"Ground Antenna to Satellite 1: {ga_to_sat1_in_view}\")\nprint(f\"Ground Antenna to Satellite 2: {ga_to_sat2_in_view}\")\nprint(f\"Satellite 1 to Satellite 2:    {sat1_to_sat2_in_view}\")\n\n\nprint(\"\\n**** Distances ******************************************\")\nprint(\"Ground Antenna to Satellite 1 (km): {:.2f}\".format(ga_to_sat1_distance / 1000.0))\nprint(\"Ground Antenna to Satellite 2 (km): {:.2f}\".format(ga_to_sat2_distance / 1000.0))\nprint(\n    \"Satellite 1 to Satellite 2 (km):    {:.2f}\".format(sat1_to_sat2_distance / 1000.0)\n)\n\nprint(\"\\n**** Azimuth/Elevation **********************************\")\nprint(\n    \"Ground Antenna to Satellite 1 (deg): {:.2f}, {:.2f}\".format(\n        ga_to_sat1_azimuth * 180.0 / np.pi, ga_to_sat1_elevation * 180.0 / np.pi\n    )\n)\nprint(\n    \"Ground Antenna to Satellite 2 (deg): {:.2f}, {:.2f}\".format(\n        ga_to_sat2_azimuth * 180.0 / np.pi, ga_to_sat2_elevation * 180.0 / np.pi\n    )\n)\nprint(\n    \"Satellite 1 to Satellite 2 (deg):    {:.2f}, {:.2f}\".format(\n        sat1_to_sat2_azimuth * 180.0 / np.pi, sat1_to_sat2_elevation * 180.0 / np.pi\n    )\n)\n\nprint(\"\")\n</code></pre>"},{"location":"reference/gps_frames/api/","title":"API Overview","text":""},{"location":"reference/gps_frames/api/#gps_frames","title":"<code>gps_frames</code>","text":"gps_frames <p>Define the reference frames for use throughout the model.</p> <p>The purpose of this module is to provide tools for translating between the different reference frames used for GPS. At first, only the WGS84 (LLA) frame, the ECEF frame, and the GPS ECI frame (relative to start of week) will be included.</p> Notes <p>Like all internal modules, distances are stored here as meters and angles are stored as radians.</p>"},{"location":"reference/gps_frames/api/#gps_frames.check_earth_obscuration","title":"<code>check_earth_obscuration(position1, position2, convert_hae_altitude=False, earth_adjustment_m=30000.0, transition_altitude_m=-np.inf, elevation_mask_angle_rad=-0.1)</code>","text":"<p>Determine if position2 is visiable from position1.</p> <p>.. note:: Assumptions     This function is meant to be a quick check of Earth obscuration. As     such, it does not account for things like time delays, signal     refraction, or a non-spherical Earth. All calculations are done under     the assumptions of simultanity, geometric line-of-sight, and a     spherical Earth. In fact, this includes the option to naively use the     height above ellipsoid as the height above the spherical Earth.</p> <p>This function is meant to determine if an object at position 2 has a direct line of sight to the object at position 1. There are two ways that this function checks to see if an object is visible.</p> <p>First, it checks to see if the object at position 2 is above the limb of the Earth. This means that the horizon object at position 2 is above the horizon viewed from position 1. Let the position 1 be a distance \\(r\\) from the center of the Earth. For the purposes of determining the angle to the horizon, let the adjusted radius of the Earth be $$     R_{\\oplus}' = R_{\\oplus} - \\delta R $$ where \\(R_{\\oplus}\\) is the actual radius of the Earth and \\(\\delta R\\) is a correction factor for the radius. Thus the angle between the nadir vector from position 1 to the limb is $$     \\lambda = \\sin^{-1} \\left(\\frac{R_{\\oplus}'}{r}\\right) $$ Let the angle from the anti-nadir vector of position 1 to position 2 be \\(\\psi\\). Position 2 will be above the horizon if $$     \\pi - \\lambda \\geq \\psi $$</p> <p>The first method works well for determining if a satellite in view from a terrestrial object, but is not useful for determining if a terrestrial object is in view of a satellite. This is because if a terrestrial object is between a satellite and the Earth, it will be definitionally below the horizon, but obviously in view of the satellite. For this reason a second test is implemented. An object at position 1 is defined to be in view of an object at position 1 if the distance from position 1 to 2 is less than the distance from position 1 to the horizon. This technically allows for a significant amount of the interior of the Earth to be considered in view, but would in practice only return objects in view because subterranian objects are not feasible. Let \\(d\\) be the distance from position 1 to position 2. This second condition is $$     d &lt; r \\cos\\lambda $$</p> <p>This function also includes a sort of safety factor; it allows for the radius of the Earth used for determining the horizon to be reduced. This factor can be used to account for the non-sphereical Earth and timing issues.</p> <p>Parameters:</p> Name Type Description Default <code>position1</code> <code>Position</code> <p>The position of object 1</p> required <code>position2</code> <code>Position</code> <p>The position of object 2</p> required <code>convert_hae_altitude</code> <code>bool</code> <p>If the position is in the LLA frame, then its altitude is in height above ellispoid (HAE). If this is true, actual spherical altitude will be calculated. However, it it is False, the HAE altitude will naively be used as a spherical altitude, which is less accurate but will provide a faster estimate and can be accounted for using the earth_adjustment_m parameter, by default False</p> <code>False</code> <code>earth_adjustment_m</code> <code>float</code> <p>Effectively reduces the radius of the Earth for the purposes of the computing the obscuration. This distance (in meters) is subtracted from the radius of the Earth when calculating idealized mask angles, by default 100e3</p> <code>30000.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the position2 is visible from position1</p> Source code in <code>gps_frames/__init__.py</code> <pre><code>def check_earth_obscuration(\n    position1: Position,\n    position2: Position,\n    convert_hae_altitude: bool = False,\n    earth_adjustment_m: float = 30e3,\n    transition_altitude_m: float = -np.inf,\n    elevation_mask_angle_rad: float = -0.1,\n) -&gt; bool:\n    r\"\"\"Determine if position2 is visiable from position1.\n\n    .. note:: Assumptions\n        This function is meant to be a quick check of Earth obscuration. As\n        such, it does not account for things like time delays, signal\n        refraction, or a non-spherical Earth. All calculations are done under\n        the assumptions of simultanity, geometric line-of-sight, and a\n        spherical Earth. In fact, this includes the option to naively use the\n        height above ellipsoid as the height above the spherical Earth.\n\n    This function is meant to determine if an object at position 2 has a\n    direct line of sight to the object at position 1. There are two ways that\n    this function checks to see if an object is visible.\n\n    First, it checks to see if the object at position 2 is above the limb of\n    the Earth. This means that the horizon object at position 2 is above the\n    horizon viewed from position 1. Let the position 1 be a distance \\(r\\) from\n    the center of the Earth. For the purposes of determining the angle to the\n    horizon, let the adjusted radius of the Earth be\n    $$\n        R_{\\oplus}' = R_{\\oplus} - \\delta R\n    $$\n    where \\(R_{\\oplus}\\) is the actual radius of the Earth and \\(\\delta R\\)\n    is a correction factor for the radius. Thus the angle between the nadir\n    vector from position 1 to the limb is\n    $$\n        \\lambda = \\sin^{-1} \\left(\\frac{R_{\\oplus}'}{r}\\right)\n    $$\n    Let the angle from the anti-nadir vector of position 1 to position 2 be\n    \\(\\psi\\). Position 2 will be above the horizon if\n    $$\n        \\pi - \\lambda \\geq \\psi\n    $$\n\n    The first method works well for determining if a satellite in view from a\n    terrestrial object, but is not useful for determining if a terrestrial\n    object is in view of a satellite. This is because if a terrestrial object\n    is between a satellite and the Earth, it will be definitionally below the\n    horizon, but obviously in view of the satellite. For this reason a second\n    test is implemented. An object at position 1 is defined to be in view of\n    an object at position 1 if the distance from position 1 to 2 is less than\n    the distance from position 1 to the horizon. This technically allows for a\n    significant amount of the interior of the Earth to be considered in view,\n    but would in practice only return objects in view because subterranian\n    objects are not feasible. Let \\(d\\) be the distance from position 1 to\n    position 2. This second condition is\n    $$\n        d &lt; r \\cos\\lambda\n    $$\n\n    This function also includes a sort of safety factor; it allows for the\n    radius of the Earth used for determining the horizon to be reduced. This\n    factor can be used to account for the non-sphereical Earth and timing\n    issues.\n\n    Parameters\n    ----------\n    position1 : Position\n        The position of object 1\n    position2 : Position\n        The position of object 2\n    convert_hae_altitude : bool, optional\n        If the position is in the LLA frame, then its altitude is in height\n        above ellispoid (HAE). If this is true, actual spherical altitude will\n        be calculated. However, it it is False, the HAE altitude will naively\n        be used as a spherical altitude, which is less accurate but will\n        provide a faster estimate and can be accounted for using the\n        earth_adjustment_m parameter, by default False\n    earth_adjustment_m : float, optional\n        Effectively reduces the radius of the Earth for the purposes of the\n        computing the obscuration. This distance (in meters) is subtracted\n        from the radius of the Earth when calculating idealized mask angles,\n        by default 100e3\n\n    Returns\n    -------\n    bool\n        True if the position2 is visible from position1\n\n    \"\"\"\n    if earth_adjustment_m &lt; 0:\n        logger.debug(\n            \"Earth Obscuration: Earth Radius Adjustment is negative, which \"\n            \"makes Earth larger.\"\n        )\n\n    elevation_mask_angle_rad = 5 * np.pi / 180\n\n    position1_radius = position1.get_radius()\n    position2_radius = position2.get_radius()\n\n    if position1_radius &lt; position2_radius:\n        lower_position = position1\n        lower_radius = position1_radius\n        lower_altitude = position1.get_altitude_hae()\n\n        upper_position = position2\n        # upper_radius = position2_radius\n    else:\n        upper_position = position1\n        # upper_radius = position1_radius\n\n        lower_position = position2\n        lower_radius = position2_radius\n        lower_altitude = position2.get_altitude_hae()\n\n    lower_enu_basis = get_east_north_up_basis(lower_position)\n    _distance, _azimuth, _elevation = get_range_azimuth_elevation(\n        lower_enu_basis, upper_position\n    )\n\n    if transition_altitude_m &gt; lower_altitude:\n        min_elevation = elevation_mask_angle_rad\n    else:\n        adjusted_earth_radius = EarthParam.r_e - earth_adjustment_m\n        sin_limb_angle = adjusted_earth_radius / lower_radius\n        limb_angle = np.arcsin(np.min([1.0, sin_limb_angle]))\n        min_elevation = limb_angle - (np.pi / 2) + elevation_mask_angle_rad\n\n    in_view = _elevation &gt;= min_elevation\n\n    return in_view\n</code></pre>"},{"location":"reference/gps_frames/api/#gps_frames.get_azimuth_elevation","title":"<code>get_azimuth_elevation(enu_basis, target_position)</code>","text":"<p>Get the azimuth and elevation of a target relative to a basis.</p> <p>Parameters:</p> Name Type Description Default <code>enu_basis</code> <code>Basis</code> <p>The East-North-Up basis</p> required <code>target_position</code> <code>Position</code> <p>The position of the target</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>The (1) azimuth and (2) elevation of the target relative to ENU basis provided.</p> Source code in <code>gps_frames/__init__.py</code> <pre><code>def get_azimuth_elevation(\n    enu_basis: Basis, target_position: Position\n) -&gt; Tuple[float, float]:\n    \"\"\"Get the azimuth and elevation of a target relative to a basis.\n\n    Parameters\n    ----------\n    enu_basis : Basis\n        The East-North-Up basis\n    target_position : Position\n        The position of the target\n\n    Returns\n    -------\n    Tuple[float, float]\n        The (1) azimuth and (2) elevation of the target relative to ENU\n        basis provided.\n\n    \"\"\"\n    _, azimuth, elevation = get_range_azimuth_elevation(enu_basis, target_position)\n\n    return azimuth, elevation\n</code></pre>"},{"location":"reference/gps_frames/api/#gps_frames.get_east_north_up_basis","title":"<code>get_east_north_up_basis(position)</code>","text":"<p>Get the East-North-Up Basis for the input position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Position</code> <p>The position of interest</p> required <p>Returns:</p> Type Description <code>Basis</code> <p>The basis representing the East-North-Up frame</p> Source code in <code>gps_frames/__init__.py</code> <pre><code>def get_east_north_up_basis(position: Position) -&gt; Basis:\n    \"\"\"Get the East-North-Up Basis for the input position.\n\n    Parameters\n    ----------\n    position : Position\n        The position of interest\n\n    Returns\n    -------\n    Basis\n        The basis representing the East-North-Up frame\n\n    \"\"\"\n    lla_pos = position.get_position(\"LLA\")\n    lla = lla_pos.coordinates\n    upx = np.cos(lla[0]) * np.cos(lla[1])\n    upy = np.cos(lla[0]) * np.sin(lla[1])\n    upz = np.sin(lla[0])\n\n    updirection = UnitVector(\n        np.array([upx, upy, upz], dtype=float), position.frame_time, \"ECEF\"\n    )\n\n    localeast_coords = np.array(\n        [-updirection.coordinates[1], updirection.coordinates[0], 0], dtype=float\n    )\n    localeast = UnitVector(localeast_coords, lla_pos.frame_time, \"ECEF\")\n\n    # Local North is the cross between the up and east directions, i.e.\n    # north = up cross east\n    localnorth = UnitVector.from_vector(updirection.cross_product(localeast))\n\n    return Basis(position.get_position(\"ECEF\"), localeast, localnorth, updirection)\n</code></pre>"},{"location":"reference/gps_frames/api/#gps_frames.get_range_azimuth_elevation","title":"<code>get_range_azimuth_elevation(enu_basis, target_position)</code>","text":"<p>Get the azimuth and elevation of a target relative to a basis.</p> <p>Parameters:</p> Name Type Description Default <code>enu_basis</code> <code>Basis</code> <p>The East-North-Up basis</p> required <code>target_position</code> <code>Position</code> <p>The position of the target</p> required <p>Returns:</p> Type Description <code>Tuple[float, float, float]</code> <p>The (1) range, (2) azimuth, and (3) elevation of the target relative to ENU basis provided.</p> Source code in <code>gps_frames/__init__.py</code> <pre><code>def get_range_azimuth_elevation(\n    enu_basis: Basis, target_position: Position\n) -&gt; Tuple[float, float, float]:\n    \"\"\"Get the azimuth and elevation of a target relative to a basis.\n\n    Parameters\n    ----------\n    enu_basis : Basis\n        The East-North-Up basis\n    target_position : Position\n        The position of the target\n\n    Returns\n    -------\n    Tuple[float, float, float]\n        The (1) range, (2) azimuth, and (3) elevation of the target relative\n        to ENU basis provided.\n\n    \"\"\"\n    rp = coordinates_in_basis(target_position, enu_basis)\n    range_ = np.linalg.norm(rp)\n\n    elevation = (np.pi / 2.0) - np.arccos(rp[2] / range_)\n    azimuth = np.arctan2(rp[0], rp[1])\n\n    return range_, azimuth, elevation\n</code></pre>"},{"location":"reference/gps_frames/api/#gps_frames.get_relative_angles","title":"<code>get_relative_angles(basis, target_position, look_axis, reference_axis)</code>","text":"<p>Get the angles from a basis to an object.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>Basis</code> <p>The basis to measure angles relative to</p> required <code>target_position</code> <code>Position</code> <p>The position of the target</p> required <code>look_axis</code> <code>int</code> <p>The axis that represents the look direction of the basis (i.e. the boresight)</p> required <code>reference_axis</code> <code>int</code> <p>The axis to measure the angle around the bore relative to (right-hand positive about the look_axis)</p> required <p>Returns:</p> Type Description <code>Tuple[float]</code> <p>The angle off of the look_axis and the angle about the look_axis, rad</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the look_axis and reference_axis have the same value or if they are not 1, 2, or 3</p> Source code in <code>gps_frames/__init__.py</code> <pre><code>def get_relative_angles(\n    basis: Basis, target_position: Position, look_axis: int, reference_axis: int\n) -&gt; Tuple[float, float]:\n    \"\"\"Get the angles from a basis to an object.\n\n    Parameters\n    ----------\n    basis : Basis\n        The basis to measure angles relative to\n    target_position : Position\n        The position of the target\n    look_axis : int\n        The axis that represents the look direction of the basis (i.e. the\n        boresight)\n    reference_axis : int\n        The axis to measure the angle around the bore relative to (right-hand\n        positive about the look_axis)\n\n    Returns\n    -------\n    Tuple[float]\n        The angle off of the look_axis and the angle about the look_axis, rad\n\n    Raises\n    ------\n    ValueError\n        If the look_axis and reference_axis have the same value or if they are\n        not 1, 2, or 3\n\n    \"\"\"\n    if look_axis == reference_axis:\n        raise ValueError(\"look_axis and reference_axis must be different\")\n\n    if look_axis not in [1, 2, 3]:\n        raise ValueError(\"look_axis must be 1, 2, or 3\")\n\n    if reference_axis not in [1, 2, 3]:\n        raise ValueError(\"reference_axis must be 1, 2, or 3\")\n\n    # Get the position relative to the basis\n    rp = coordinates_in_basis(target_position, basis)\n\n    # Assign the components along the basis to the internal variables\n    for axis in [1, 2, 3]:\n        if axis == look_axis:\n            look_component = rp[axis - 1]\n        elif axis == reference_axis:\n            reference_component = rp[axis - 1]\n        else:\n            other_componet = rp[axis - 1]\n\n    # Compute the angle off of the boresight (look_axis)\n    off_bore_component = np.sqrt(reference_component ** 2 + other_componet ** 2)\n    angle_off_bore = np.arctan2(off_bore_component, look_component)\n\n    # Determine if the reference_axis is next in the cyclic order after the\n    # look_axis\n    _cyclic_order = reference_axis == (look_axis % 3) + 1\n\n    # If the order is cyclic, simply compute the angle directly, If not, flip\n    # the value of the other axis and compute the angle about the boresight\n    # relative to the reference axis\n    if _cyclic_order:\n        angle_from_ref = np.arctan2(other_componet, reference_component)\n    else:\n        angle_from_ref = np.arctan2(-other_componet, reference_component)\n\n    return angle_off_bore, angle_from_ref\n</code></pre>"},{"location":"reference/gps_frames/basis/","title":"Basis","text":""},{"location":"reference/gps_frames/basis/#gps_frames.basis","title":"<code>gps_frames.basis</code>","text":"<p>Reference Frame Basis.</p> <p>This submodule is used to define the basis for reference frames.</p>"},{"location":"reference/gps_frames/basis/#gps_frames.basis.Basis","title":"<code>Basis</code>","text":"<p>Basis of a reference frame.</p> <p>Attributes:</p> Name Type Description <code>origin</code> <code>Position</code> <p>The origin of the basis</p> <code>axes</code> <code>list</code> <p>This is a three element array whose elements are of the <code>UnitVector</code> type. This represent the axes that make up the basis.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the following:</p> <ul> <li>The origin is in the LLA frame</li> <li>The axes and origin are defined in different frames</li> <li>The axes are not orthogonal</li> <li>The basis is not right-handed</li> </ul> Source code in <code>gps_frames/basis.py</code> <pre><code>class Basis:\n    \"\"\"Basis of a reference frame.\n\n    Attributes\n    ----------\n    origin : Position\n        The origin of the basis\n    axes : list\n        This is a three element array whose elements are of the `UnitVector`\n        type. This represent the axes that make up the basis.\n\n    Raises\n    ------\n    ValueError\n        If any of the following:\n\n        - The origin is in the LLA frame\n        - The axes and origin are defined in different frames\n        - The axes are not orthogonal\n        - The basis is not right-handed\n\n    \"\"\"\n\n    UNSAFE = False\n    yaml_tag = \"!Basis\"\n\n    def __init__(\n        self, origin: Position, axis1: UnitVector, axis2: UnitVector, axis3: UnitVector\n    ) -&gt; None:\n        \"\"\"Object constructor.\n\n        Parameters\n        ----------\n        origin : Position\n            The position of the origin\n        axis1 : UnitVector\n            The 1-axis (e.g. X)\n        axis2 : UnitVector\n            The 2-axis (e.g. Y)\n        axis3 : UnitVector\n            The 3-axis (e.g. Z)\n\n        \"\"\"\n        self.origin: Position = origin\n        self.axes: List[UnitVector] = [axis1, axis2, axis3]\n\n        if not Basis.UNSAFE:\n            self.check_frames()\n            self.check_orthogonality()\n            self.check_right_handedness()\n\n    @classmethod\n    def to_yaml(\n        cls, representer: ruamel.yaml.Representer, node: SerializeableVector\n    ) -&gt; ruamel.yaml.MappingNode:\n        \"\"\"Convert the class into a mapping node for serialzation.\n\n        Takes the attributes of the class and converts them to ScalarNode\n        used in a ruamel.yaml MappingNode to dump the object in a specific\n        format. This method is called by the ruamel.yaml.YAML object\n        when passed to register_class\n\n        Parameters\n        ----------\n        representer : ruamel.yaml.Representer\n            Yaml representer\n        node : SerializeableVector\n            The instance of the class to serialize\n\n        Returns\n        -------\n        ruamel.yaml.MappingNode\n            A mapping node which describes to the yaml dumper how to serialize\n            the object\n\n        \"\"\"\n        return representer.represent_mapping(\n            cls.yaml_tag,\n            {\n                \"origin\": node.origin,\n                \"axis1\": node.axes[0],\n                \"axis2\": node.axes[1],\n                \"axis3\": node.axes[2],\n            },\n        )\n\n    @classmethod\n    def from_yaml(\n        cls: type, constructor: ruamel.yaml.Constructor, node: ruamel.yaml.MappingNode\n    ) -&gt; SerializeableVector:\n        \"\"\"Construct a class from a MappingNode.\n\n        This method is called when using yaml.load if the\n        SerializeableVector class has been registered to the\n        ruamel.yaml.YAML object\n\n        Parameters\n        ----------\n        cls : type\n            The type of the class to deserialize\n        constructor : ruamel.yaml.Constructor\n            The constructor object\n        node : ruamel.yaml.MappingNode\n            Node created from the yaml parser\n\n        Returns\n        -------\n        SerializeableVector\n            Instance of serialized class\n\n        \"\"\"\n        nodes = node.value\n        origin = None\n        axes = [None, None, None]\n        for i in range(len(nodes)):\n            node_name = nodes[i][0].value\n            if node_name == \"axis1\":\n                axes[0] = constructor.construct_object(nodes[i][1])\n            elif node_name == \"axis2\":\n                axes[1] = constructor.construct_object(nodes[i][1])\n            elif node_name == \"axis3\":\n                axes[2] = constructor.construct_object(nodes[i][1])\n            elif node_name == \"origin\":\n                origin = constructor.construct_object(nodes[i][1])\n        return cls(origin, *axes)\n\n    def check_frames(self) -&gt; None:\n        \"\"\"Ensure that the frames are consistent.\n\n        !!! note \"LLA Frame\"\n            If the LLA frame is provided for the origin, will attempt to\n            convert to the ECEF frame. Will log an error\n\n        Raises\n        ------\n        ValueError\n            If the axes are not all in the same frame as the origin\n\n        \"\"\"\n        if self.origin.frame == \"LLA\":\n            logger.warning(\"LLA frame used for basis of origin, ECEF will be used\")\n            self.origin.switch_frame(to_frame=\"ECEF\")\n\n        origin_frame = self.origin.frame\n        origin_frame_time = self.origin.frame_time\n\n        if any([axis.frame != origin_frame for axis in self.axes]):\n            raise ValueError(\"Not all axes and origin in the same frame\")\n\n        if any([axis.frame_time != origin_frame_time for axis in self.axes]):\n            raise ValueError(\"Not all axes and origin have same frame time\")\n\n    def check_orthogonality(self, eps: float = 1e-12) -&gt; None:\n        \"\"\"Check that the axes are orthogonal.\n\n        Parameters\n        ----------\n        eps : float, optional\n            The amount of allowable numerical error, by default 1e-12\n\n        Raises\n        ------\n        ValueError\n            If the axes are not mutually orthogonal\n\n        \"\"\"\n        v1 = self.axes[0].coordinates\n        v2 = self.axes[1].coordinates\n        v3 = self.axes[2].coordinates\n\n        checks = np.array(\n            [np.abs(np.dot(v1, v2)), np.abs(np.dot(v2, v3)), np.abs(np.dot(v3, v1))]\n        )\n        if any(checks &gt; eps):\n            raise ValueError(\"Axes are not orthogonal\")\n\n    def check_right_handedness(self, eps: float = 1e-12) -&gt; None:\n        \"\"\"Check that the axes are right-handed.\n\n        Parameters\n        ----------\n        eps : float, optional\n            The amount of allowable numerical error, by default 1e-12\n\n        Raises\n        ------\n        ValueError\n            If the basis is not right-handed\n\n        \"\"\"\n        Basis.right_hand_numba(\n            np.array(\n                [\n                    self.axes[0].coordinates,\n                    self.axes[1].coordinates,\n                    self.axes[2].coordinates,\n                ]\n            )\n        )\n\n    @staticmethod\n    @jit(nopython=True)\n    def right_hand_numba(axes: np.array, eps: float = 1e-12) -&gt; None:\n\n        v1 = axes[0]\n        v2 = axes[1]\n        v3 = axes[2]\n\n        check1 = np.linalg.norm(np.cross(v1, v2) - v3) &gt; eps\n        check2 = np.linalg.norm(np.cross(v2, v3) - v1) &gt; eps\n        check3 = np.linalg.norm(np.cross(v3, v1) - v2) &gt; eps\n\n        if np.any(np.array([check1, check2, check3])):\n            raise ValueError(\"Basis is not right-handed\")\n\n    def __hash__(self):\n        \"\"\"Make basis hashable.\"\"\"\n        return hash(\n            str(hash(self.origin))\n            + str(hash(self.axes[0]))\n            + str(hash(self.axes[1]))\n            + str(hash(self.axes[2]))\n        )\n</code></pre>"},{"location":"reference/gps_frames/basis/#gps_frames.basis.Basis.__hash__","title":"<code>__hash__()</code>","text":"<p>Make basis hashable.</p> Source code in <code>gps_frames/basis.py</code> <pre><code>def __hash__(self):\n    \"\"\"Make basis hashable.\"\"\"\n    return hash(\n        str(hash(self.origin))\n        + str(hash(self.axes[0]))\n        + str(hash(self.axes[1]))\n        + str(hash(self.axes[2]))\n    )\n</code></pre>"},{"location":"reference/gps_frames/basis/#gps_frames.basis.Basis.__init__","title":"<code>__init__(origin, axis1, axis2, axis3)</code>","text":"<p>Object constructor.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>Position</code> <p>The position of the origin</p> required <code>axis1</code> <code>UnitVector</code> <p>The 1-axis (e.g. X)</p> required <code>axis2</code> <code>UnitVector</code> <p>The 2-axis (e.g. Y)</p> required <code>axis3</code> <code>UnitVector</code> <p>The 3-axis (e.g. Z)</p> required Source code in <code>gps_frames/basis.py</code> <pre><code>def __init__(\n    self, origin: Position, axis1: UnitVector, axis2: UnitVector, axis3: UnitVector\n) -&gt; None:\n    \"\"\"Object constructor.\n\n    Parameters\n    ----------\n    origin : Position\n        The position of the origin\n    axis1 : UnitVector\n        The 1-axis (e.g. X)\n    axis2 : UnitVector\n        The 2-axis (e.g. Y)\n    axis3 : UnitVector\n        The 3-axis (e.g. Z)\n\n    \"\"\"\n    self.origin: Position = origin\n    self.axes: List[UnitVector] = [axis1, axis2, axis3]\n\n    if not Basis.UNSAFE:\n        self.check_frames()\n        self.check_orthogonality()\n        self.check_right_handedness()\n</code></pre>"},{"location":"reference/gps_frames/basis/#gps_frames.basis.Basis.check_frames","title":"<code>check_frames()</code>","text":"<p>Ensure that the frames are consistent.</p> <p>LLA Frame</p> <p>If the LLA frame is provided for the origin, will attempt to convert to the ECEF frame. Will log an error</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the axes are not all in the same frame as the origin</p> Source code in <code>gps_frames/basis.py</code> <pre><code>def check_frames(self) -&gt; None:\n    \"\"\"Ensure that the frames are consistent.\n\n    !!! note \"LLA Frame\"\n        If the LLA frame is provided for the origin, will attempt to\n        convert to the ECEF frame. Will log an error\n\n    Raises\n    ------\n    ValueError\n        If the axes are not all in the same frame as the origin\n\n    \"\"\"\n    if self.origin.frame == \"LLA\":\n        logger.warning(\"LLA frame used for basis of origin, ECEF will be used\")\n        self.origin.switch_frame(to_frame=\"ECEF\")\n\n    origin_frame = self.origin.frame\n    origin_frame_time = self.origin.frame_time\n\n    if any([axis.frame != origin_frame for axis in self.axes]):\n        raise ValueError(\"Not all axes and origin in the same frame\")\n\n    if any([axis.frame_time != origin_frame_time for axis in self.axes]):\n        raise ValueError(\"Not all axes and origin have same frame time\")\n</code></pre>"},{"location":"reference/gps_frames/basis/#gps_frames.basis.Basis.check_orthogonality","title":"<code>check_orthogonality(eps=1e-12)</code>","text":"<p>Check that the axes are orthogonal.</p> <p>Parameters:</p> Name Type Description Default <code>eps</code> <code>float</code> <p>The amount of allowable numerical error, by default 1e-12</p> <code>1e-12</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the axes are not mutually orthogonal</p> Source code in <code>gps_frames/basis.py</code> <pre><code>def check_orthogonality(self, eps: float = 1e-12) -&gt; None:\n    \"\"\"Check that the axes are orthogonal.\n\n    Parameters\n    ----------\n    eps : float, optional\n        The amount of allowable numerical error, by default 1e-12\n\n    Raises\n    ------\n    ValueError\n        If the axes are not mutually orthogonal\n\n    \"\"\"\n    v1 = self.axes[0].coordinates\n    v2 = self.axes[1].coordinates\n    v3 = self.axes[2].coordinates\n\n    checks = np.array(\n        [np.abs(np.dot(v1, v2)), np.abs(np.dot(v2, v3)), np.abs(np.dot(v3, v1))]\n    )\n    if any(checks &gt; eps):\n        raise ValueError(\"Axes are not orthogonal\")\n</code></pre>"},{"location":"reference/gps_frames/basis/#gps_frames.basis.Basis.check_right_handedness","title":"<code>check_right_handedness(eps=1e-12)</code>","text":"<p>Check that the axes are right-handed.</p> <p>Parameters:</p> Name Type Description Default <code>eps</code> <code>float</code> <p>The amount of allowable numerical error, by default 1e-12</p> <code>1e-12</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the basis is not right-handed</p> Source code in <code>gps_frames/basis.py</code> <pre><code>def check_right_handedness(self, eps: float = 1e-12) -&gt; None:\n    \"\"\"Check that the axes are right-handed.\n\n    Parameters\n    ----------\n    eps : float, optional\n        The amount of allowable numerical error, by default 1e-12\n\n    Raises\n    ------\n    ValueError\n        If the basis is not right-handed\n\n    \"\"\"\n    Basis.right_hand_numba(\n        np.array(\n            [\n                self.axes[0].coordinates,\n                self.axes[1].coordinates,\n                self.axes[2].coordinates,\n            ]\n        )\n    )\n</code></pre>"},{"location":"reference/gps_frames/basis/#gps_frames.basis.Basis.from_yaml","title":"<code>from_yaml(constructor, node)</code>  <code>classmethod</code>","text":"<p>Construct a class from a MappingNode.</p> <p>This method is called when using yaml.load if the SerializeableVector class has been registered to the ruamel.yaml.YAML object</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The type of the class to deserialize</p> required <code>constructor</code> <code>Constructor</code> <p>The constructor object</p> required <code>node</code> <code>MappingNode</code> <p>Node created from the yaml parser</p> required <p>Returns:</p> Type Description <code>SerializeableVector</code> <p>Instance of serialized class</p> Source code in <code>gps_frames/basis.py</code> <pre><code>@classmethod\ndef from_yaml(\n    cls: type, constructor: ruamel.yaml.Constructor, node: ruamel.yaml.MappingNode\n) -&gt; SerializeableVector:\n    \"\"\"Construct a class from a MappingNode.\n\n    This method is called when using yaml.load if the\n    SerializeableVector class has been registered to the\n    ruamel.yaml.YAML object\n\n    Parameters\n    ----------\n    cls : type\n        The type of the class to deserialize\n    constructor : ruamel.yaml.Constructor\n        The constructor object\n    node : ruamel.yaml.MappingNode\n        Node created from the yaml parser\n\n    Returns\n    -------\n    SerializeableVector\n        Instance of serialized class\n\n    \"\"\"\n    nodes = node.value\n    origin = None\n    axes = [None, None, None]\n    for i in range(len(nodes)):\n        node_name = nodes[i][0].value\n        if node_name == \"axis1\":\n            axes[0] = constructor.construct_object(nodes[i][1])\n        elif node_name == \"axis2\":\n            axes[1] = constructor.construct_object(nodes[i][1])\n        elif node_name == \"axis3\":\n            axes[2] = constructor.construct_object(nodes[i][1])\n        elif node_name == \"origin\":\n            origin = constructor.construct_object(nodes[i][1])\n    return cls(origin, *axes)\n</code></pre>"},{"location":"reference/gps_frames/basis/#gps_frames.basis.Basis.to_yaml","title":"<code>to_yaml(representer, node)</code>  <code>classmethod</code>","text":"<p>Convert the class into a mapping node for serialzation.</p> <p>Takes the attributes of the class and converts them to ScalarNode used in a ruamel.yaml MappingNode to dump the object in a specific format. This method is called by the ruamel.yaml.YAML object when passed to register_class</p> <p>Parameters:</p> Name Type Description Default <code>representer</code> <code>Representer</code> <p>Yaml representer</p> required <code>node</code> <code>SerializeableVector</code> <p>The instance of the class to serialize</p> required <p>Returns:</p> Type Description <code>MappingNode</code> <p>A mapping node which describes to the yaml dumper how to serialize the object</p> Source code in <code>gps_frames/basis.py</code> <pre><code>@classmethod\ndef to_yaml(\n    cls, representer: ruamel.yaml.Representer, node: SerializeableVector\n) -&gt; ruamel.yaml.MappingNode:\n    \"\"\"Convert the class into a mapping node for serialzation.\n\n    Takes the attributes of the class and converts them to ScalarNode\n    used in a ruamel.yaml MappingNode to dump the object in a specific\n    format. This method is called by the ruamel.yaml.YAML object\n    when passed to register_class\n\n    Parameters\n    ----------\n    representer : ruamel.yaml.Representer\n        Yaml representer\n    node : SerializeableVector\n        The instance of the class to serialize\n\n    Returns\n    -------\n    ruamel.yaml.MappingNode\n        A mapping node which describes to the yaml dumper how to serialize\n        the object\n\n    \"\"\"\n    return representer.represent_mapping(\n        cls.yaml_tag,\n        {\n            \"origin\": node.origin,\n            \"axis1\": node.axes[0],\n            \"axis2\": node.axes[1],\n            \"axis3\": node.axes[2],\n        },\n    )\n</code></pre>"},{"location":"reference/gps_frames/basis/#gps_frames.basis.coordinates_in_basis","title":"<code>coordinates_in_basis(position, basis)</code>","text":"<p>Get the coordinates of a position in a basis.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Position</code> <p>The position</p> required <code>basis</code> <code>Basis</code> <p>The basis to express the position in</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A three element array reprenting the coordinates of the position in the basis.</p> Source code in <code>gps_frames/basis.py</code> <pre><code>def coordinates_in_basis(position: Position, basis: Basis) -&gt; np.ndarray:\n    \"\"\"Get the coordinates of a position in a basis.\n\n    Parameters\n    ----------\n    position : Position\n        The position\n    basis : Basis\n        The basis to express the position in\n\n    Returns\n    -------\n    np.ndarray\n        A three element array reprenting the coordinates of the position in\n        the basis.\n\n    \"\"\"\n    origin_frame = basis.origin.frame\n    origin_frame_time = basis.origin.frame_time\n\n    # Move the position ot the same frame as the basis\n    _position = position.get_position(origin_frame)\n    _position.update_frame_time(origin_frame_time)\n\n    # Find the relative position\n    rp = _position.coordinates - basis.origin.coordinates\n\n    # Project the relative position onto the basis' axes\n    v1 = basis.axes[0].dot_product(rp)\n    v2 = basis.axes[1].dot_product(rp)\n    v3 = basis.axes[2].dot_product(rp)\n\n    return [v1, v2, v3]\n</code></pre>"},{"location":"reference/gps_frames/basis/#gps_frames.basis.get_ecef_basis","title":"<code>get_ecef_basis(time)</code>","text":"<p>Get the ECE basis.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>GPSTime</code> <p>The time to define the ECEF basis</p> required <p>Returns:</p> Type Description <code>Basis</code> <p>The ECEF basis</p> Source code in <code>gps_frames/basis.py</code> <pre><code>def get_ecef_basis(time: GPSTime) -&gt; Basis:\n    \"\"\"Get the ECE basis.\n\n    Parameters\n    ----------\n    time : GPSTime\n        The time to define the ECEF basis\n\n    Returns\n    -------\n    Basis\n        The ECEF basis\n\n    \"\"\"\n    origin = Position(\n        coordinates=np.array([0.0, 0.0, 0.0]), frame_time=time, frame=\"ECEF\"\n    )\n    x_axis = UnitVector(\n        coordinates=np.array([1.0, 0.0, 0.0]), frame_time=time, frame=\"ECEF\"\n    )\n    y_axis = UnitVector(\n        coordinates=np.array([0.0, 1.0, 0.0]), frame_time=time, frame=\"ECEF\"\n    )\n    z_axis = UnitVector(\n        coordinates=np.array([0.0, 0.0, 1.0]), frame_time=time, frame=\"ECEF\"\n    )\n\n    return Basis(origin=origin, axis1=x_axis, axis2=y_axis, axis3=z_axis)\n</code></pre>"},{"location":"reference/gps_frames/basis/#gps_frames.basis.get_eci_basis","title":"<code>get_eci_basis(time)</code>","text":"<p>Get the ECI basis.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>GPSTime</code> <p>The time to define the ECI basis</p> required <p>Returns:</p> Type Description <code>Basis</code> <p>The ECI basis</p> Source code in <code>gps_frames/basis.py</code> <pre><code>def get_eci_basis(time: GPSTime) -&gt; Basis:\n    \"\"\"Get the ECI basis.\n\n    Parameters\n    ----------\n    time : GPSTime\n        The time to define the ECI basis\n\n    Returns\n    -------\n    Basis\n        The ECI basis\n\n    \"\"\"\n    origin = Position(\n        coordinates=np.array([0.0, 0.0, 0.0]), frame_time=time, frame=\"ECI\"\n    )\n    x_axis = UnitVector(\n        coordinates=np.array([1.0, 0.0, 0.0]), frame_time=time, frame=\"ECI\"\n    )\n    y_axis = UnitVector(\n        coordinates=np.array([0.0, 1.0, 0.0]), frame_time=time, frame=\"ECI\"\n    )\n    z_axis = UnitVector(\n        coordinates=np.array([0.0, 0.0, 1.0]), frame_time=time, frame=\"ECI\"\n    )\n\n    return Basis(origin=origin, axis1=x_axis, axis2=y_axis, axis3=z_axis)\n</code></pre>"},{"location":"reference/gps_frames/basis/#gps_frames.basis.rotate_basis","title":"<code>rotate_basis(rotation, basis)</code>","text":"<p>Rotate a basis about its origin.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>Rotation</code> <p>A rotation object</p> required <code>basis</code> <code>Basis</code> <p>A basis</p> required <p>Returns:</p> Type Description <code>Basis</code> <p>A basis with the same origin as the input basis, but whose axes are rotated according to the given rotation.</p> Source code in <code>gps_frames/basis.py</code> <pre><code>def rotate_basis(rotation: Rotation, basis: Basis) -&gt; Basis:\n    \"\"\"Rotate a basis about its origin.\n\n    Parameters\n    ----------\n    rotation : Rotation\n        A rotation object\n    basis : Basis\n        A basis\n\n    Returns\n    -------\n    Basis\n        A basis with the same origin as the input basis, but whose axes are\n        rotated according to the given rotation.\n\n    \"\"\"\n    v1 = UnitVector(\n        rotation.rotate(basis.axes[0].coordinates),\n        basis.origin.frame_time,\n        basis.origin.frame,\n    )\n    v2 = UnitVector(\n        rotation.rotate(basis.axes[1].coordinates),\n        basis.origin.frame_time,\n        basis.origin.frame,\n    )\n    v3 = UnitVector(\n        rotation.rotate(basis.axes[2].coordinates),\n        basis.origin.frame_time,\n        basis.origin.frame,\n    )\n\n    return Basis(origin=basis.origin, axis1=v1, axis2=v2, axis3=v3)\n</code></pre>"},{"location":"reference/gps_frames/parameters/","title":"Parameters","text":""},{"location":"reference/gps_frames/parameters/#gps_frames.parameters","title":"<code>gps_frames.parameters</code>","text":"<p>Standard parameters used throughout the simulator.</p> <p>This package contains physical parameters that are divided into several classes. PhysicsParam contains standard physical parameters. EarthParam contains parameters specific to the Earth. GPSparam includes parameters specific to the GPS system.</p> References <p>.. [1] IS-GPS-200 https://www.gps.gov/technical/icwg/</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.EarthParam","title":"<code>EarthParam</code>  <code>dataclass</code>","text":"<p>Earth Parameters.</p> <p>This class contains parameters specific to the Earth. The values are specified by IS-GPS-200H or WGS-84</p> Source code in <code>gps_frames/parameters.py</code> <pre><code>@dataclass(init=False, repr=True, frozen=True)\nclass EarthParam:\n    \"\"\"Earth Parameters.\n\n    This class contains parameters specific to the Earth. The values are\n    specified by IS-GPS-200H or WGS-84\n\n    \"\"\"\n\n    mu: float = 3.986005e14  # m^3/s^2, gravitational parameter\n    r\"\"\"Standard Gravitational Parameter for the Earth. Units are\n    \\(\\text{m}^{3}/\\text{s}^{2}\\). This value is specified by\n    IS-GPS-200H.\n    \"\"\"\n\n    w_e: float = 7.2921151467e-5  # rad/s, angular velocity of Earth\n    r\"\"\"Angular velocity of the Earth. Units are \\(\\text{rad}/\\text{s}\\). This\n    value is specified by IS-GPS-200H.\n    \"\"\"\n\n    r_e: float = 6378137.0  # m, radius of Earth\n    r\"\"\"Mean radius of the Earth. Units are \\(\\text{m}\\). This value is\n    specified by IS-GPS-200H.\n    \"\"\"\n\n    wgs84a: float = 6378137.0  # m, semimajor axis of Earth from WGS 84\n    r\"\"\"The semimajor axis of the ellipsoidal Earth. Units are \\(\\text{m}\\).\n    This value is specified by WGS-84.\n    \"\"\"\n\n    wgs84f: float = 1 / 298.257223563\n    \"\"\"The WGS84 ellipsoid flattening value, specified by WGS-84\n    \"\"\"\n\n    # m, semiminor axis of Earth from WGS 84\n    wgs84b: float = wgs84a * (1 - wgs84f)\n    r\"\"\"The semiminor axis of the ellipsoidal Earth. Units are \\(\\text{m}\\).\n    This value is derived from values specified by WGS-84.\n    \"\"\"\n\n    wgs84ecc_squared: float = 1 - (1 - wgs84f) ** 2\n    \"\"\"The square of the eccentricity of the WGS-84 ellipsoid.\n    This valuse is derived from values specified by WGS-84\n    \"\"\"\n\n    wgs84ecc: float = np.sqrt(wgs84ecc_squared)\n    \"\"\"The eccentricity of the ellipsoidal Earth. Dimensionless.\n    This value is derived from values specified by WGS-84.\n    \"\"\"\n\n    F: float = -4.442807633e-10  # -2sqrt(mu)/c^2, relativity parameter\n    r\"\"\"Parameter used to determine the relativistic clock bias of each\n    satellite. This values is specified by IS-GPS-200.\n\n    Equal to \\(\\frac{-2\\sqrt{\\mu}}{c^{2}}\\), but the value here is the one\n    specified by IS-GPS-200, not calculated from standard values.\n    \"\"\"\n</code></pre>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.EarthParam.F","title":"<code>F = -4.442807633e-10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Parameter used to determine the relativistic clock bias of each satellite. This values is specified by IS-GPS-200.</p> <p>Equal to \\(\\frac{-2\\sqrt{\\mu}}{c^{2}}\\), but the value here is the one specified by IS-GPS-200, not calculated from standard values.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.EarthParam.mu","title":"<code>mu = 398600500000000.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Standard Gravitational Parameter for the Earth. Units are \\(\\text{m}^{3}/\\text{s}^{2}\\). This value is specified by IS-GPS-200H.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.EarthParam.r_e","title":"<code>r_e = 6378137.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mean radius of the Earth. Units are \\(\\text{m}\\). This value is specified by IS-GPS-200H.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.EarthParam.w_e","title":"<code>w_e = 7.2921151467e-05</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Angular velocity of the Earth. Units are \\(\\text{rad}/\\text{s}\\). This value is specified by IS-GPS-200H.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.EarthParam.wgs84a","title":"<code>wgs84a = 6378137.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The semimajor axis of the ellipsoidal Earth. Units are \\(\\text{m}\\). This value is specified by WGS-84.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.EarthParam.wgs84b","title":"<code>wgs84b = wgs84a * (1 - wgs84f)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The semiminor axis of the ellipsoidal Earth. Units are \\(\\text{m}\\). This value is derived from values specified by WGS-84.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.EarthParam.wgs84ecc","title":"<code>wgs84ecc = np.sqrt(wgs84ecc_squared)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The eccentricity of the ellipsoidal Earth. Dimensionless. This value is derived from values specified by WGS-84.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.EarthParam.wgs84ecc_squared","title":"<code>wgs84ecc_squared = 1 - (1 - wgs84f) ** 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The square of the eccentricity of the WGS-84 ellipsoid. This valuse is derived from values specified by WGS-84</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.EarthParam.wgs84f","title":"<code>wgs84f = 1 / 298.257223563</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The WGS84 ellipsoid flattening value, specified by WGS-84</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GPSparam","title":"<code>GPSparam</code>  <code>dataclass</code>","text":"<p>GPS Parameters.</p> <p>This class contains parameters specific to the GPS system. These parameters are specified by IS-GPS-200H.</p> Source code in <code>gps_frames/parameters.py</code> <pre><code>@dataclass(init=False, repr=True, frozen=True)\nclass GPSparam:\n    \"\"\"GPS Parameters.\n\n    This class contains parameters specific to the GPS system. These\n    parameters are specified by IS-GPS-200H.\n\n    \"\"\"\n\n    epoch_datetime: datetime = datetime(1980, 1, 6)\n    \"\"\"The start time of the GPS Epoch, which is defined to be 00:00:00\n    on 6 January 1980.\n    \"\"\"\n\n    pi: float = 3.1415926535898  # Mathematical constant pi (IS-GPS-200H)\n    r\"\"\"The mathematical constant \\(\\pi\\). As many of the parameters in the\n    broadcast ephemeris are transmitted in units of semicircles, it is\n    important that the value of \\(\\pi\\) used by the simulator is exactly\n    the value used by receivers and the GPS constellation. As such this\n    value is specified in IS-GPS-200H.\n    \"\"\"\n\n    gamma: float = (1575.42 / 1227.6) ** 2\n    r\"\"\"Square of L1-L2 center frequency ratio \\(\\gamma\\)\n\n    This parameter is used in determining the difference in the pseudorange\n    between L1 and L2. Specifically,\n    $$\n        \\gamma\n            = \\left(\\frac{f_{\\mathrm{L1}}}{f_{\\mathrm{L2}}}\\right)^{2}\n            = \\left(\\frac{1575.42}{1227.6}\\right)^{2}\n    $$\n    where \\(f_{\\mathrm{L1}} = 1575.42 \\text{MHz}\\) is the L1 center\n    frequency and \\(f_{\\mathrm{L2}} = 1227.6 \\text{MHz}\\) is the L2\n    center frequency.\n    \"\"\"\n\n    lnav_t_oc_epoch: int = 2 ** 4\n    r\"\"\"The LNAV Time of Clock Epoch\n\n    This is the resolution of the time of clock,\n    \\(t_{\\mathrm{OC}}\\), as reported in the ephemeris of the LNAV\n    messages.\n    \"\"\"\n\n    lnav_t_oe_epoch: int = 2 ** 4\n    r\"\"\"The LNAV Time of Ephemeris Epoch\n\n    This is the resolution of the time of ephemeris,\n    \\(t_{\\mathrm{OE}}\\), as reported in the ephemeris of the LNAV\n    messages.\n    \"\"\"\n\n    lnav_t_oa_epoch: int = 2 ** 12\n    r\"\"\"The LNAV Time of Applicability Epoch\n\n    This is the resolution of the time of applicability,\n    \\(t_{\\mathrm{OA}}\\), as reported in the almanac of the LNAV\n    messages.\n    \"\"\"\n\n    L1_CENTER_FREQ_Hz: float = 1575.42e6\n    \"\"\"The center frequency of the GPS L1 signal in Hz\n    \"\"\"\n\n    L2_CENTER_FREQ_Hz: float = 1227.6e6\n    \"\"\"The center frequency of the GPS L2 signal in Hz\n    \"\"\"\n\n    L5_CENTER_FREQ_Hz: float = 1176.45e6\n    \"\"\"The center frequency of the GPS L5 signal in Hz\n    \"\"\"\n</code></pre>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GPSparam.L1_CENTER_FREQ_Hz","title":"<code>L1_CENTER_FREQ_Hz = 1575420000.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The center frequency of the GPS L1 signal in Hz</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GPSparam.L2_CENTER_FREQ_Hz","title":"<code>L2_CENTER_FREQ_Hz = 1227600000.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The center frequency of the GPS L2 signal in Hz</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GPSparam.L5_CENTER_FREQ_Hz","title":"<code>L5_CENTER_FREQ_Hz = 1176450000.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The center frequency of the GPS L5 signal in Hz</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GPSparam.epoch_datetime","title":"<code>epoch_datetime = datetime(1980, 1, 6)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The start time of the GPS Epoch, which is defined to be 00:00:00 on 6 January 1980.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GPSparam.gamma","title":"<code>gamma = (1575.42 / 1227.6) ** 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square of L1-L2 center frequency ratio \\(\\gamma\\)</p> <p>This parameter is used in determining the difference in the pseudorange between L1 and L2. Specifically, $$     \\gamma         = \\left(\\frac{f_{\\mathrm{L1}}}{f_{\\mathrm{L2}}}\\right)^{2}         = \\left(\\frac{1575.42}{1227.6}\\right)^{2} $$ where \\(f_{\\mathrm{L1}} = 1575.42 \\text{MHz}\\) is the L1 center frequency and \\(f_{\\mathrm{L2}} = 1227.6 \\text{MHz}\\) is the L2 center frequency.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GPSparam.lnav_t_oa_epoch","title":"<code>lnav_t_oa_epoch = 2 ** 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The LNAV Time of Applicability Epoch</p> <p>This is the resolution of the time of applicability, \\(t_{\\mathrm{OA}}\\), as reported in the almanac of the LNAV messages.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GPSparam.lnav_t_oc_epoch","title":"<code>lnav_t_oc_epoch = 2 ** 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The LNAV Time of Clock Epoch</p> <p>This is the resolution of the time of clock, \\(t_{\\mathrm{OC}}\\), as reported in the ephemeris of the LNAV messages.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GPSparam.lnav_t_oe_epoch","title":"<code>lnav_t_oe_epoch = 2 ** 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The LNAV Time of Ephemeris Epoch</p> <p>This is the resolution of the time of ephemeris, \\(t_{\\mathrm{OE}}\\), as reported in the ephemeris of the LNAV messages.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GPSparam.pi","title":"<code>pi = 3.1415926535898</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The mathematical constant \\(\\pi\\). As many of the parameters in the broadcast ephemeris are transmitted in units of semicircles, it is important that the value of \\(\\pi\\) used by the simulator is exactly the value used by receivers and the GPS constellation. As such this value is specified in IS-GPS-200H.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GeoidData","title":"<code>GeoidData</code>","text":"<p>EGM-96 Geoid Model.</p> <p>This class is used to store the information related to the shape of the Earth, relative to the WGS-84 ellipsoid.</p> <p>This class is based on the data from [1]_ under the MIT License</p> References <p>.. [1] https://github.com/vectorstofinal/geoid_heights</p> License <p>The MIT License (MIT)</p> <p>Copyright (c) 2015 vectorstofinal</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> Source code in <code>gps_frames/parameters.py</code> <pre><code>class GeoidData:\n    \"\"\"EGM-96 Geoid Model.\n\n    This class is used to store the information related to the shape of the\n    Earth, relative to the WGS-84 ellipsoid.\n\n    This class is based on the data from [1]_ under the MIT License\n\n    References\n    ----------\n    .. [1] https://github.com/vectorstofinal/geoid_heights\n\n    License\n    -------\n    The MIT License (MIT)\n\n    Copyright (c) 2015 vectorstofinal\n\n    Permission is hereby granted, free of charge, to any person obtaining a\n    copy of this software and associated documentation files (the \"Software\"),\n    to deal in the Software without restriction, including without limitation\n    the rights to use, copy, modify, merge, publish, distribute, sublicense,\n    and/or sell copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n    DEALINGS IN THE SOFTWARE.\n\n    \"\"\"\n\n    with importlib.resources.path(\"gps_frames.data\", \"geoid_data_1deg.npz\") as _data_path:\n        _geoid_data_npz = np.load(_data_path)\n\n    latitudes = _geoid_data_npz[\"latitudes\"]\n    \"\"\"Geoid Grid latitudes (deg)\"\"\"\n\n    longitudes = _geoid_data_npz[\"longitudes\"]\n    \"\"\"Geoid Grid longitudes (deg)\"\"\"\n\n    geoid_heights = _geoid_data_npz[\"geoid_heights\"]\n    \"\"\"Geoid Heights in a grid (m)\"\"\"\n\n    _geoid_height_interpolator = interpolate.RectBivariateSpline(\n        latitudes, longitudes, geoid_heights\n    )\n    \"\"\"Interpolant for geoid height, arguments are (Lat,Long) in degrees\"\"\"\n\n    @staticmethod\n    def get_geoid_height(\n        latitude: float, longitude: float, units: str = \"rad\"\n    ) -&gt; float:\n        \"\"\"Get the geoid height.\n\n        This function is used to return the geoid height at the provided\n        location. This is done using the data stored in the geoiddata folder.\n\n        Parameters\n        ----------\n        latitude : float\n            The latitude of interest\n        longitude : float\n            The longitude of interest\n        units : str, optional\n            The units for latitude and longitude. Choices are either\n            'rad' or 'deg' for radians or degrees, by default 'rad'\n\n        Returns\n        -------\n        float\n            The geoid height in meters for the given latitude and longitude\n\n        Raises\n        ------\n        NotImplementedError\n            If units other than 'rad' or 'deg' is requested\n\n        \"\"\"\n        if units.lower() == \"rad\":\n            latitude = latitude * 180.0 / np.pi\n            longitude = longitude * 180.0 / np.pi\n        elif units.lower() == \"deg\":\n            pass\n        else:\n            raise NotImplementedError(\"Only rad and deg are available units\")\n\n        geoid_height = GeoidData._geoid_height_interpolator(latitude, longitude)\n\n        return geoid_height[0, 0]\n</code></pre>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GeoidData.geoid_heights","title":"<code>geoid_heights = _geoid_data_npz['geoid_heights']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Geoid Heights in a grid (m)</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GeoidData.latitudes","title":"<code>latitudes = _geoid_data_npz['latitudes']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Geoid Grid latitudes (deg)</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GeoidData.longitudes","title":"<code>longitudes = _geoid_data_npz['longitudes']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Geoid Grid longitudes (deg)</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.GeoidData.get_geoid_height","title":"<code>get_geoid_height(latitude, longitude, units='rad')</code>  <code>staticmethod</code>","text":"<p>Get the geoid height.</p> <p>This function is used to return the geoid height at the provided location. This is done using the data stored in the geoiddata folder.</p> <p>Parameters:</p> Name Type Description Default <code>latitude</code> <code>float</code> <p>The latitude of interest</p> required <code>longitude</code> <code>float</code> <p>The longitude of interest</p> required <code>units</code> <code>str</code> <p>The units for latitude and longitude. Choices are either 'rad' or 'deg' for radians or degrees, by default 'rad'</p> <code>'rad'</code> <p>Returns:</p> Type Description <code>float</code> <p>The geoid height in meters for the given latitude and longitude</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If units other than 'rad' or 'deg' is requested</p> Source code in <code>gps_frames/parameters.py</code> <pre><code>@staticmethod\ndef get_geoid_height(\n    latitude: float, longitude: float, units: str = \"rad\"\n) -&gt; float:\n    \"\"\"Get the geoid height.\n\n    This function is used to return the geoid height at the provided\n    location. This is done using the data stored in the geoiddata folder.\n\n    Parameters\n    ----------\n    latitude : float\n        The latitude of interest\n    longitude : float\n        The longitude of interest\n    units : str, optional\n        The units for latitude and longitude. Choices are either\n        'rad' or 'deg' for radians or degrees, by default 'rad'\n\n    Returns\n    -------\n    float\n        The geoid height in meters for the given latitude and longitude\n\n    Raises\n    ------\n    NotImplementedError\n        If units other than 'rad' or 'deg' is requested\n\n    \"\"\"\n    if units.lower() == \"rad\":\n        latitude = latitude * 180.0 / np.pi\n        longitude = longitude * 180.0 / np.pi\n    elif units.lower() == \"deg\":\n        pass\n    else:\n        raise NotImplementedError(\"Only rad and deg are available units\")\n\n    geoid_height = GeoidData._geoid_height_interpolator(latitude, longitude)\n\n    return geoid_height[0, 0]\n</code></pre>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.PhysicsParam","title":"<code>PhysicsParam</code>  <code>dataclass</code>","text":"<p>Physical Constants.</p> <p>This class contains standard physical constants</p> Source code in <code>gps_frames/parameters.py</code> <pre><code>@dataclass(init=False, repr=True, frozen=True)\nclass PhysicsParam:\n    \"\"\"Physical Constants.\n\n    This class contains standard physical constants\n\n    \"\"\"\n\n    c: float = 2.99792458e8  # m/s, speed of light (IS-GPS-200H)\n    \"\"\"The speed of light in meters per second\n\n    The speed of light in meters per second as specified by IS-GPS-200H.\n    \"\"\"\n\n    k_b: float = 1.38064852e-23  # m^2 kg / s^2 K\n    r\"\"\"Boltzmann Constant in m^2 kg / s^2 K\n\n    The Boltzmann constant, \\(k_{B}\\) or \\(k\\), is a physical\n    constant relating the average kinetic energy of particles in a gas with\n    the temperature of the gas and occurs in Planck's law of black-body\n    radiation and in Boltzmann's entropy formula.\n    \"\"\"\n</code></pre>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.PhysicsParam.c","title":"<code>c = 299792458.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The speed of light in meters per second</p> <p>The speed of light in meters per second as specified by IS-GPS-200H.</p>"},{"location":"reference/gps_frames/parameters/#gps_frames.parameters.PhysicsParam.k_b","title":"<code>k_b = 1.38064852e-23</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Boltzmann Constant in m^2 kg / s^2 K</p> <p>The Boltzmann constant, \\(k_{B}\\) or \\(k\\), is a physical constant relating the average kinetic energy of particles in a gas with the temperature of the gas and occurs in Planck's law of black-body radiation and in Boltzmann's entropy formula.</p>"},{"location":"reference/gps_frames/paths/","title":"Paths","text":""},{"location":"reference/gps_frames/paths/#gps_frames.paths","title":"<code>gps_frames.paths</code>","text":"<p>Compute information about signal paths.</p> <p>This submodule contains tools that can be used to determine information about a signal path.</p>"},{"location":"reference/gps_frames/paths/#gps_frames.paths.get_altitude_intersection_point","title":"<code>get_altitude_intersection_point(altitude, origin_position, target_position)</code>","text":"<p>Get the point where a unit vector crosses an altitude</p> <p>The purpose of this function is to calculate the point at which a vector, starting at the origin, will cross a specific altitude.</p> <p>Spherical Earth</p> <p>The function assumes a spherical Earth, not WGS84 ellipsoid</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>float</code> <p>The altitude in meters</p> required <code>origin_position</code> <code>Position</code> <p>The position of the origin</p> required <code>target_position</code> <code>Position</code> <p>The position of the target</p> required <p>Returns:</p> Type Description <code>Position</code> <p>The position where the path from the origin to the target passes through the specified altitude.</p> Source code in <code>gps_frames/paths.py</code> <pre><code>def get_altitude_intersection_point(\n    altitude: float, origin_position: Position, target_position: Position\n) -&gt; Position:\n    \"\"\"Get the point where a unit vector crosses an altitude\n\n    The purpose of this function is to calculate the point at which a vector,\n    starting at the origin, will cross a specific altitude.\n\n    !!! note \"Spherical Earth\"\n        The function assumes a spherical Earth, not WGS84 ellipsoid\n\n    Parameters\n    ----------\n    altitude : float\n        The altitude in meters\n    origin_position : Position\n        The position of the origin\n    target_position : Position\n        The position of the target\n\n    Returns\n    -------\n    Position\n        The position where the path from the origin to the target passes\n        through the specified altitude.\n\n    \"\"\"\n\n    path_vector = target_position.to_vector() - origin_position.to_vector()\n    path_length = path_vector.magnitude\n\n    origin_radius = origin_position.get_radius()\n    target_radius = target_position.get_radius()\n\n    cos_e_p2 = (origin_radius ** 2 + path_length ** 2 - target_radius ** 2) / (\n        2 * origin_radius * path_length\n    )\n\n    k = origin_radius * cos_e_p2 + np.sqrt(\n        (EarthParam.r_e + altitude) ** 2 - origin_radius ** 2 * (1 - cos_e_p2 ** 2)\n    )\n\n    intersection_point = origin_position + (path_vector * (k / path_length))\n\n    return intersection_point\n</code></pre>"},{"location":"reference/gps_frames/paths/#gps_frames.paths.get_distance_between_points","title":"<code>get_distance_between_points(positions)</code>","text":"<p>Compute the distance between Positions in a list.</p> <p>Length of Return Object</p> <p>Because it requires two points to compute a distance, the length of the returned list is one element shorter than the input list.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>List[Position]</code> <p>A list of positions</p> required <p>Returns:</p> Type Description <code>List[float]</code> <p>A list of distances between the positions. The first returned element is the distance between first and second positions, the second returned element is the distance between the second and third, and so on.</p> Source code in <code>gps_frames/paths.py</code> <pre><code>def get_distance_between_points(positions: List[Position]) -&gt; List[float]:\n    \"\"\"Compute the distance between Positions in a list.\n\n    !!! note \"Length of Return Object\"\n        Because it requires two points to compute a distance, the length of\n        the returned list is one element shorter than the input list.\n\n    Parameters\n    ----------\n    positions : List[Position]\n        A list of positions\n\n    Returns\n    -------\n    List[float]\n        A list of distances between the positions. The first returned element\n        is the distance between first and second positions, the second\n        returned element is the distance between the second and third, and\n        so on.\n\n    \"\"\"\n    logger.debug(f\"Calculating Distance between {len(positions)} points\")\n    return [\n        distance(_pos1, _pos2) for _pos1, _pos2 in zip(positions[:-1], positions[1:])\n    ]\n</code></pre>"},{"location":"reference/gps_frames/paths/#gps_frames.paths.get_point_closest_approach","title":"<code>get_point_closest_approach(start_point, path_vector, elevation, max_length=np.inf)</code>","text":"<p>Get the point along the path that is is closest to Earth.</p> <p>Compute the point along the path that it is closest to the spherical Earth</p> <p>Parameters:</p> Name Type Description Default <code>start_point</code> <code>Position</code> <p>The start position of the path</p> required <code>path_vector</code> <code>Vector</code> <p>The vector (not unit vector) describing the path from the start point to the end point, i.e. <code>end_point = start_point + path_vector</code> or <code>path_vector = end_point - start_point</code>.</p> required <code>elevation</code> <code>float</code> <p>The elevation of the end point of the path relative to the start point</p> required <code>max_length</code> <code>float</code> <p>The maximum distance from the start point to the point of closest approach, by default infinity (np.inf). It is generally useful to specify that the length of the path is the maximum distance, otherwise this algorithm will find a point of closest approach beyond the end point.</p> <code>inf</code> <p>Returns:</p> Type Description <code>Position</code> <p>The point of closest approach along the path.</p> Source code in <code>gps_frames/paths.py</code> <pre><code>def get_point_closest_approach(\n    start_point: Position,\n    path_vector: Vector,\n    elevation: float,\n    max_length: float = np.inf,\n) -&gt; Position:\n    \"\"\"Get the point along the path that is is closest to Earth.\n\n    Compute the point along the path that it is closest to the spherical Earth\n\n    Parameters\n    ----------\n    start_point : Position\n        The start position of the path\n    path_vector : Vector\n        The vector (not unit vector) describing the path from the start point\n        to the end point, i.e. `end_point = start_point + path_vector` or\n        `path_vector = end_point - start_point`.\n    elevation : float\n        The elevation of the end point of the path relative to the start point\n    max_length : float, optional\n        The maximum distance from the start point to the point of closest\n        approach, by default infinity (np.inf). It is generally useful to\n        specify that the length of the path is the maximum distance, otherwise\n        this algorithm will find a point of closest approach beyond the end point.\n\n    Returns\n    -------\n    Position\n        The point of closest approach along the path.\n\n    \"\"\"\n    if elevation &gt;= 0:\n        logger.warning(\n            \"Attempted to find closest approach when the end point was above \"\n            \"the start point's horizon. Because the path starts at the start \"\n            \"point and the path moves away from the Earth, the start point \"\n            \"is by definition the point of closest approach.\"\n        )\n        return start_point\n    else:\n        dc = start_point.get_radius() * np.sin(-elevation)\n\n        if dc &gt; max_length:\n            dc = max_length\n\n        return start_point + (path_vector * (dc / path_vector.magnitude))\n</code></pre>"},{"location":"reference/gps_frames/paths/#gps_frames.paths.get_points_along_path","title":"<code>get_points_along_path(start_point, end_point, num_points)</code>","text":"<p>Get evenly space points along the path.</p> <p>Get a list of evenly spaced points along a path. This list includes the start and end points, so the number of points along the path must be at least 2 (the start and end points).</p> <p>Parameters:</p> Name Type Description Default <code>start_point</code> <code>Position</code> <p>The starting position of the path</p> required <code>end_point</code> <code>Position</code> <p>The ending position of the path</p> required <code>num_points</code> <code>int</code> <p>The number of points to return along the path.</p> required <p>Returns:</p> Type Description <code>List[Position]</code> <p>A list of points along the path, including the start and end points. The length of the returned list is num_points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If num_points &lt; 2</p> Source code in <code>gps_frames/paths.py</code> <pre><code>def get_points_along_path(\n    start_point: Position, end_point: Position, num_points: int\n) -&gt; List[Position]:\n    \"\"\"Get evenly space points along the path.\n\n    Get a list of evenly spaced points along a path. This list includes the\n    start and end points, so the number of points along the path must be at\n    least 2 (the start and end points).\n\n    Parameters\n    ----------\n    start_point : Position\n        The starting position of the path\n    end_point : Position\n        The ending position of the path\n    num_points : int\n        The number of points to return along the path.\n\n    Returns\n    -------\n    List[Position]\n        A list of points along the path, including the start and end points.\n        The length of the returned list is num_points.\n\n    Raises\n    ------\n    ValueError\n        If num_points &lt; 2\n    \"\"\"\n    if num_points &lt; 2:\n        raise ValueError(\"num_points must be &gt;= 2\")\n\n    start_vector = start_point.to_vector()\n    end_vector = end_point.to_vector()\n\n    path_vector = end_vector - start_vector\n    path_length = path_vector.magnitude\n\n    return [\n        start_point + (path_vector * (_d / path_length))\n        for _d in np.linspace(0, path_length, num_points)\n    ]\n</code></pre>"},{"location":"reference/gps_frames/position/","title":"Position","text":""},{"location":"reference/gps_frames/position/#gps_frames.position","title":"<code>gps_frames.position</code>","text":"<p>Positions in reference frames.</p> <p>The purpose of this submodule is to provide a representation for the position of objects and tools to manipulate the positions.</p>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position","title":"<code>Position</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SerializeableVector</code></p> <p>Represent a position in multiple frames.</p> Source code in <code>gps_frames/position.py</code> <pre><code>@dataclass(eq=False)\nclass Position(SerializeableVector):\n    \"\"\"Represent a position in multiple frames.\"\"\"\n\n    yaml_tag = \"!SerializeableVector.Position\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Check for proper coordinate shape.\"\"\"\n        if len(np.shape(self.coordinates)) == 2:\n            self.coordinates = np.reshape(self.coordinates, 3)\n        elif len(np.shape(self.coordinates)) &gt; 2:\n            raise ValueError(\"Too many dimensions for position\")\n\n    def get_position(self, out_frame: str) -&gt; Position:\n        \"\"\"Get a position object in new frame.\n\n        !!! note \"New Object Created on Output\"\n            This function returns a new position object. It does not change\n            the reference frame used in this object. Use `switch_frame()` to\n            change the frame of the object.\n\n        Parameters\n        ----------\n        out_frame : str\n            The frame to output the position in\n\n        Returns\n        -------\n        Position\n            The position expressed in a new frame\n\n        See Also\n        --------\n        switch_frame: Change the frame that the position is interally\n            expressed in\n\n        \"\"\"\n        new_coordinates = trans.position_transform(\n            self.frame, out_frame, self.coordinates, self.frame_time\n        )\n\n        return self.__class__(new_coordinates, self.frame_time, out_frame)\n\n    def switch_frame(self, to_frame: str) -&gt; None:\n        \"\"\"Change the frame used to store this position internally.\n\n        Parameters\n        ----------\n        to_frame : str\n            The desired new frame\n\n        \"\"\"\n        new_coordinates = trans.position_transform(\n            self.frame, to_frame, self.coordinates, self.frame_time\n        )\n\n        self.coordinates = new_coordinates\n        self.frame = to_frame\n\n    def update_frame_time(self, new_frame_time: GPSTime) -&gt; None:\n        \"\"\"Change the reference time for the frame.\n\n        Reference frames can be time dependant. This method is used to change\n        the time reference for a reference frame.\n\n        This method updates the internal representation of the position to the\n        frame at the new reference time.\n\n        Parameters\n        ----------\n        new_frame_time : GPSTime\n            The new frame reference time\n\n        \"\"\"\n        coordinates = self.coordinates\n        if self.frame == \"ECI\":\n            delta_weeks = new_frame_time.week_number - self.frame_time.week_number\n\n            self.coordinates = trans.add_weeks_eci(delta_weeks, coordinates)\n            self.frame_time = new_frame_time\n\n        elif self.frame == \"ECEF\":\n            self.coordinates = trans.rotate_ecef(\n                self.frame_time, new_frame_time, coordinates\n            )\n            self.frame_time = new_frame_time\n\n        elif self.frame == \"LLA\":\n            self.switch_frame(\"ECEF\")\n            coordinates = self.coordinates\n            self.coordinates = trans.rotate_ecef(\n                self.frame_time, new_frame_time, coordinates\n            )\n            self.frame_time = new_frame_time\n\n            self.switch_frame(\"LLA\")\n\n    def get_altitude_msl(self) -&gt; float:\n        \"\"\"Get the Altitude above Mean Sea Level.\n\n        Returns\n        -------\n        float\n            The altitude above mean sea level\n\n        \"\"\"\n        lla = trans.position_transform(\n            self.frame, \"LLA\", self.coordinates, self.frame_time\n        )\n\n        geoid_height = GeoidData.get_geoid_height(lla[0], lla[1])\n\n        return lla[2] - geoid_height\n\n    def get_altitude_hae(self) -&gt; float:\n        \"\"\"Get the altitude, height above ellipsoid.\n\n        Returns\n        -------\n        float\n            The height above ellipsoid\n\n        \"\"\"\n        lla = trans.position_transform(\n            self.frame, \"LLA\", self.coordinates, self.frame_time\n        )\n\n        return lla[2]\n\n    def get_radius(self) -&gt; float:\n        \"\"\"Get the radius of the position.\n\n        Get the radius of the position, i.e. the distance from the position to\n        the center of the Earth\n\n        Returns\n        -------\n        float\n            The distance to the center of the Earth\n\n        \"\"\"\n        ecef = trans.position_transform(\n            self.frame, \"ECEF\", self.coordinates, self.frame_time\n        )\n\n        return np.linalg.norm(ecef)\n\n    def get_altitude_spherical(self) -&gt; float:\n        \"\"\"Get the altitude above the spherical Earth.\n\n        Get the altitude for the position if the Earth was a perfect sphere.\n        This is done by subtracting the radius of the Earth from the value\n        returned by get_radius() method.\n\n        Returns\n        -------\n        float\n            The altitude above the spherical Earth\n\n        \"\"\"\n        return self.get_radius() - EarthParam.r_e\n\n    def __hash__(self):\n        \"\"\"Make position hashable.\"\"\"\n        return super().__hash__()\n\n    @classmethod\n    def from_vector(cls, vector: Vector) -&gt; Position:\n        \"\"\"Create a position from a vector.\n\n        Parameters\n        ----------\n        vector : Vector\n            The vector\n\n        Returns\n        -------\n        Position\n            The vector represented as a position\n\n        \"\"\"\n        return cls(\n            coordinates=vector.coordinates,\n            frame_time=vector.frame_time,\n            frame=vector.frame,\n        )\n\n    def to_vector(self) -&gt; Vector:\n        \"\"\"Recast Position as a Vector.\n\n        Returns\n        -------\n        Vector\n            New vector\n\n        \"\"\"\n        return Vector(\n            coordinates=self.coordinates, frame_time=self.frame_time, frame=self.frame\n        )\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Equality Comparision.\n\n        Parameters\n        ----------\n        other : Position\n            Another position\n\n        Returns\n        -------\n        bool\n            If the distance between the positions is less than 1e-6\n\n        Raises\n        ------\n        TypeError\n            If the other value is not a Position\n\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise TypeError(\"Equality only defined between two Positions\")\n\n        eps = 1e-6\n\n        return distance(self, other) &lt; eps\n\n    def __add__(self, other: Vector) -&gt; Position:\n        \"\"\"Add a vector to a position.\n\n        Parameters\n        ----------\n        other : Vector\n            Vector to add\n\n        Returns\n        -------\n        Position\n            New position\n\n        Raises\n        ------\n        TypeError\n            Other is not a vector\n\n        \"\"\"\n        if not isinstance(other, Vector):\n            raise TypeError(\"other must be a vector\")\n\n        vec1 = self.to_vector()\n\n        new_vec = vec1 + other\n\n        return self.from_vector(new_vec)\n\n    def __sub__(self, other: Vector) -&gt; Position:\n        \"\"\"Subtract a vector from a position.\n\n        Parameters\n        ----------\n        other : Vector\n            Vector to subtract\n\n        Returns\n        -------\n        Position\n            New position\n\n        Raises\n        ------\n        TypeError\n            If other is not a vector\n        \"\"\"\n        if not isinstance(other, Vector):\n            raise TypeError(\"other must be a vector\")\n\n        vec1 = self.to_vector()\n\n        new_vec = vec1 - other\n\n        return self.from_vector(new_vec)\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.__add__","title":"<code>__add__(other)</code>","text":"<p>Add a vector to a position.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Vector</code> <p>Vector to add</p> required <p>Returns:</p> Type Description <code>Position</code> <p>New position</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Other is not a vector</p> Source code in <code>gps_frames/position.py</code> <pre><code>def __add__(self, other: Vector) -&gt; Position:\n    \"\"\"Add a vector to a position.\n\n    Parameters\n    ----------\n    other : Vector\n        Vector to add\n\n    Returns\n    -------\n    Position\n        New position\n\n    Raises\n    ------\n    TypeError\n        Other is not a vector\n\n    \"\"\"\n    if not isinstance(other, Vector):\n        raise TypeError(\"other must be a vector\")\n\n    vec1 = self.to_vector()\n\n    new_vec = vec1 + other\n\n    return self.from_vector(new_vec)\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality Comparision.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Position</code> <p>Another position</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If the distance between the positions is less than 1e-6</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the other value is not a Position</p> Source code in <code>gps_frames/position.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Equality Comparision.\n\n    Parameters\n    ----------\n    other : Position\n        Another position\n\n    Returns\n    -------\n    bool\n        If the distance between the positions is less than 1e-6\n\n    Raises\n    ------\n    TypeError\n        If the other value is not a Position\n\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        raise TypeError(\"Equality only defined between two Positions\")\n\n    eps = 1e-6\n\n    return distance(self, other) &lt; eps\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.__hash__","title":"<code>__hash__()</code>","text":"<p>Make position hashable.</p> Source code in <code>gps_frames/position.py</code> <pre><code>def __hash__(self):\n    \"\"\"Make position hashable.\"\"\"\n    return super().__hash__()\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check for proper coordinate shape.</p> Source code in <code>gps_frames/position.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Check for proper coordinate shape.\"\"\"\n    if len(np.shape(self.coordinates)) == 2:\n        self.coordinates = np.reshape(self.coordinates, 3)\n    elif len(np.shape(self.coordinates)) &gt; 2:\n        raise ValueError(\"Too many dimensions for position\")\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtract a vector from a position.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Vector</code> <p>Vector to subtract</p> required <p>Returns:</p> Type Description <code>Position</code> <p>New position</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If other is not a vector</p> Source code in <code>gps_frames/position.py</code> <pre><code>def __sub__(self, other: Vector) -&gt; Position:\n    \"\"\"Subtract a vector from a position.\n\n    Parameters\n    ----------\n    other : Vector\n        Vector to subtract\n\n    Returns\n    -------\n    Position\n        New position\n\n    Raises\n    ------\n    TypeError\n        If other is not a vector\n    \"\"\"\n    if not isinstance(other, Vector):\n        raise TypeError(\"other must be a vector\")\n\n    vec1 = self.to_vector()\n\n    new_vec = vec1 - other\n\n    return self.from_vector(new_vec)\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.from_vector","title":"<code>from_vector(vector)</code>  <code>classmethod</code>","text":"<p>Create a position from a vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>Vector</code> <p>The vector</p> required <p>Returns:</p> Type Description <code>Position</code> <p>The vector represented as a position</p> Source code in <code>gps_frames/position.py</code> <pre><code>@classmethod\ndef from_vector(cls, vector: Vector) -&gt; Position:\n    \"\"\"Create a position from a vector.\n\n    Parameters\n    ----------\n    vector : Vector\n        The vector\n\n    Returns\n    -------\n    Position\n        The vector represented as a position\n\n    \"\"\"\n    return cls(\n        coordinates=vector.coordinates,\n        frame_time=vector.frame_time,\n        frame=vector.frame,\n    )\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.get_altitude_hae","title":"<code>get_altitude_hae()</code>","text":"<p>Get the altitude, height above ellipsoid.</p> <p>Returns:</p> Type Description <code>float</code> <p>The height above ellipsoid</p> Source code in <code>gps_frames/position.py</code> <pre><code>def get_altitude_hae(self) -&gt; float:\n    \"\"\"Get the altitude, height above ellipsoid.\n\n    Returns\n    -------\n    float\n        The height above ellipsoid\n\n    \"\"\"\n    lla = trans.position_transform(\n        self.frame, \"LLA\", self.coordinates, self.frame_time\n    )\n\n    return lla[2]\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.get_altitude_msl","title":"<code>get_altitude_msl()</code>","text":"<p>Get the Altitude above Mean Sea Level.</p> <p>Returns:</p> Type Description <code>float</code> <p>The altitude above mean sea level</p> Source code in <code>gps_frames/position.py</code> <pre><code>def get_altitude_msl(self) -&gt; float:\n    \"\"\"Get the Altitude above Mean Sea Level.\n\n    Returns\n    -------\n    float\n        The altitude above mean sea level\n\n    \"\"\"\n    lla = trans.position_transform(\n        self.frame, \"LLA\", self.coordinates, self.frame_time\n    )\n\n    geoid_height = GeoidData.get_geoid_height(lla[0], lla[1])\n\n    return lla[2] - geoid_height\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.get_altitude_spherical","title":"<code>get_altitude_spherical()</code>","text":"<p>Get the altitude above the spherical Earth.</p> <p>Get the altitude for the position if the Earth was a perfect sphere. This is done by subtracting the radius of the Earth from the value returned by get_radius() method.</p> <p>Returns:</p> Type Description <code>float</code> <p>The altitude above the spherical Earth</p> Source code in <code>gps_frames/position.py</code> <pre><code>def get_altitude_spherical(self) -&gt; float:\n    \"\"\"Get the altitude above the spherical Earth.\n\n    Get the altitude for the position if the Earth was a perfect sphere.\n    This is done by subtracting the radius of the Earth from the value\n    returned by get_radius() method.\n\n    Returns\n    -------\n    float\n        The altitude above the spherical Earth\n\n    \"\"\"\n    return self.get_radius() - EarthParam.r_e\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.get_position","title":"<code>get_position(out_frame)</code>","text":"<p>Get a position object in new frame.</p> <p>New Object Created on Output</p> <p>This function returns a new position object. It does not change the reference frame used in this object. Use <code>switch_frame()</code> to change the frame of the object.</p> <p>Parameters:</p> Name Type Description Default <code>out_frame</code> <code>str</code> <p>The frame to output the position in</p> required <p>Returns:</p> Type Description <code>Position</code> <p>The position expressed in a new frame</p> See Also <p>switch_frame: Change the frame that the position is interally     expressed in</p> Source code in <code>gps_frames/position.py</code> <pre><code>def get_position(self, out_frame: str) -&gt; Position:\n    \"\"\"Get a position object in new frame.\n\n    !!! note \"New Object Created on Output\"\n        This function returns a new position object. It does not change\n        the reference frame used in this object. Use `switch_frame()` to\n        change the frame of the object.\n\n    Parameters\n    ----------\n    out_frame : str\n        The frame to output the position in\n\n    Returns\n    -------\n    Position\n        The position expressed in a new frame\n\n    See Also\n    --------\n    switch_frame: Change the frame that the position is interally\n        expressed in\n\n    \"\"\"\n    new_coordinates = trans.position_transform(\n        self.frame, out_frame, self.coordinates, self.frame_time\n    )\n\n    return self.__class__(new_coordinates, self.frame_time, out_frame)\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.get_radius","title":"<code>get_radius()</code>","text":"<p>Get the radius of the position.</p> <p>Get the radius of the position, i.e. the distance from the position to the center of the Earth</p> <p>Returns:</p> Type Description <code>float</code> <p>The distance to the center of the Earth</p> Source code in <code>gps_frames/position.py</code> <pre><code>def get_radius(self) -&gt; float:\n    \"\"\"Get the radius of the position.\n\n    Get the radius of the position, i.e. the distance from the position to\n    the center of the Earth\n\n    Returns\n    -------\n    float\n        The distance to the center of the Earth\n\n    \"\"\"\n    ecef = trans.position_transform(\n        self.frame, \"ECEF\", self.coordinates, self.frame_time\n    )\n\n    return np.linalg.norm(ecef)\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.switch_frame","title":"<code>switch_frame(to_frame)</code>","text":"<p>Change the frame used to store this position internally.</p> <p>Parameters:</p> Name Type Description Default <code>to_frame</code> <code>str</code> <p>The desired new frame</p> required Source code in <code>gps_frames/position.py</code> <pre><code>def switch_frame(self, to_frame: str) -&gt; None:\n    \"\"\"Change the frame used to store this position internally.\n\n    Parameters\n    ----------\n    to_frame : str\n        The desired new frame\n\n    \"\"\"\n    new_coordinates = trans.position_transform(\n        self.frame, to_frame, self.coordinates, self.frame_time\n    )\n\n    self.coordinates = new_coordinates\n    self.frame = to_frame\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.to_vector","title":"<code>to_vector()</code>","text":"<p>Recast Position as a Vector.</p> <p>Returns:</p> Type Description <code>Vector</code> <p>New vector</p> Source code in <code>gps_frames/position.py</code> <pre><code>def to_vector(self) -&gt; Vector:\n    \"\"\"Recast Position as a Vector.\n\n    Returns\n    -------\n    Vector\n        New vector\n\n    \"\"\"\n    return Vector(\n        coordinates=self.coordinates, frame_time=self.frame_time, frame=self.frame\n    )\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.Position.update_frame_time","title":"<code>update_frame_time(new_frame_time)</code>","text":"<p>Change the reference time for the frame.</p> <p>Reference frames can be time dependant. This method is used to change the time reference for a reference frame.</p> <p>This method updates the internal representation of the position to the frame at the new reference time.</p> <p>Parameters:</p> Name Type Description Default <code>new_frame_time</code> <code>GPSTime</code> <p>The new frame reference time</p> required Source code in <code>gps_frames/position.py</code> <pre><code>def update_frame_time(self, new_frame_time: GPSTime) -&gt; None:\n    \"\"\"Change the reference time for the frame.\n\n    Reference frames can be time dependant. This method is used to change\n    the time reference for a reference frame.\n\n    This method updates the internal representation of the position to the\n    frame at the new reference time.\n\n    Parameters\n    ----------\n    new_frame_time : GPSTime\n        The new frame reference time\n\n    \"\"\"\n    coordinates = self.coordinates\n    if self.frame == \"ECI\":\n        delta_weeks = new_frame_time.week_number - self.frame_time.week_number\n\n        self.coordinates = trans.add_weeks_eci(delta_weeks, coordinates)\n        self.frame_time = new_frame_time\n\n    elif self.frame == \"ECEF\":\n        self.coordinates = trans.rotate_ecef(\n            self.frame_time, new_frame_time, coordinates\n        )\n        self.frame_time = new_frame_time\n\n    elif self.frame == \"LLA\":\n        self.switch_frame(\"ECEF\")\n        coordinates = self.coordinates\n        self.coordinates = trans.rotate_ecef(\n            self.frame_time, new_frame_time, coordinates\n        )\n        self.frame_time = new_frame_time\n\n        self.switch_frame(\"LLA\")\n</code></pre>"},{"location":"reference/gps_frames/position/#gps_frames.position.distance","title":"<code>distance(position1, position2)</code>","text":"<p>Compute the distance between two positions.</p> <p>This function is used to calculate the distance between two positions. To do this, it first computes the positions in their ECEF reference frames (for their frame refer times). It then rotates the ECEF frame of <code>position2</code> into the ECEF frame of <code>position1</code>. From there, it simply takes the 2-norm of the difference of the position coordinates.</p> <p>Although the calculation of distance is done in the ECEF frame, the distance between two points is the same regardless of which frames are used.</p> <p>Parameters:</p> Name Type Description Default <code>position1</code> <code>Position</code> <p>A Position</p> required <code>position2</code> <code>Position</code> <p>Another Position</p> required <p>Returns:</p> Type Description <code>float</code> <p>The distance between <code>position1</code> and <code>position2</code></p> Source code in <code>gps_frames/position.py</code> <pre><code>def distance(position1: Position, position2: Position) -&gt; float:\n    \"\"\"Compute the distance between two positions.\n\n    This function is used to calculate the distance between two positions. To\n    do this, it first computes the positions in their ECEF reference frames\n    (for their frame refer times). It then rotates the ECEF frame of\n    `position2` into the ECEF frame of `position1`. From there, it simply\n    takes the 2-norm of the difference of the position coordinates.\n\n    Although the calculation of distance is done in the ECEF frame, the\n    distance between two points is the same regardless of which frames are\n    used.\n\n    Parameters\n    ----------\n    position1 : Position\n        A Position\n    position2 : Position\n        Another Position\n\n    Returns\n    -------\n    float\n        The distance between `position1` and `position2`\n\n    \"\"\"\n    # Get both positions in the ECEF frame\n    eci_position1 = position1.get_position(\"ECI\")\n    eci_position2 = position2.get_position(\"ECI\")\n\n    # Rotate the second into the frame of the first\n    eci_position2.update_frame_time(eci_position1.frame_time)\n\n    distance_vector = eci_position1.coordinates - eci_position2.coordinates\n\n    return np.linalg.norm(distance_vector)\n</code></pre>"},{"location":"reference/gps_frames/rotations/","title":"Rotations","text":""},{"location":"reference/gps_frames/rotations/#gps_frames.rotations","title":"<code>gps_frames.rotations</code>","text":"<p>Representation for Rotations.</p> <p>The purpose of this submodule is to provide representations for rotations. This is meant to be a low-level library that uses Numba compilation to speed up execution. As such, much of the code in this submodule should be considered strictly-typed.</p> <p>The main externally used componentes are the Rotation class, which is a non-Numba class that serves as a wrapper to Numba JIT compiled functions, and the standard_rotation() function, which is a Numba JIT compiled function that provides a means for rotating a vector around a principal axis.</p>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.Rotation","title":"<code>Rotation</code>","text":"<p>Represention of rotations.</p> <p>This class is used to represent a rotation. The rotation is internally represented by a _Rotator object, which is a Numba optimized class that is used to handle the actual rotations.</p> <p>Attributes:</p> Name Type Description <code>_rotator</code> <code>_Rotator</code> <p>A numba optimized class used to describe rotations.</p> Todo <p>Consider adding to_yaml() and from_yaml() methods to enable storing as a YAML object.</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>class Rotation:\n    r\"\"\"Represention of rotations.\n\n    This class is used to represent a rotation. The rotation is internally\n    represented by a _Rotator object, which is a Numba optimized class that is\n    used to handle the actual rotations.\n\n    Attributes\n    ----------\n    _rotator : _Rotator\n        A numba optimized class used to describe rotations.\n\n    Todo\n    ----\n    Consider adding to_yaml() and from_yaml() methods to enable storing as a\n    YAML object.\n\n    \"\"\"\n\n    _rotator: _Rotator\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        r\"\"\"Construct a Rotation Object\n\n        !!! note \"Types\"\n            Because this acts as an interface to a numba object (which is\n            strictly typed), it is recommended that all inputs contain only\n            floats. This should be corrected automatically, but success cannot\n            be guarenteed.\n\n        This constructor is able to take a various numbers of input arguments\n        to create a _Rotator object. These can either be positional or keyword\n        arguments. It is recommended to use the keyword arguments to avoid\n        ambiguity.\n\n        !!! warning \"Duplicate Definitions\"\n            There can only be one definition of the rotation. If multiple\n            definitions are given, it will raise an error. This includes\n            having both positional and keyword arguments.\n\n        This constructor functions by taking the input arguments and\n        converting the rotation representation to a direction cosine matrix,\n        which is then used to instantiate a _Rotator object.\n\n        !!! tip \"Quaternion Ordering\"\n            The order of the unit quaternion inputs are (\\(q_{w}\\), \\(q_{i}\\),\n            \\(q_{j}\\), \\(q_{k}\\)) where\n\n            \\(\\mathbf{q} = q_{w} + q_{i}i + q_{j}j + q_{k}k\\).\n\n        Parameters\n        ----------\n        *args\n            If one positional argument is provided, it is assumed to be either\n            a unit quaternion (if its length is 4) or a direction cosine\n            matrix (otherwise). If two positional arguments are provided, then\n            the first positional argument is assumed to be the axis of\n            rotation and the second argument is assumed to be the angle of\n            rotation. If four positional arguments are given, the values are\n            assumed to be the components of the unit quaternion.\n        **kwargs\n            The rotation can be defined using keyword arguments. The valid\n            keyword arguments are:\n\n            - 'dcm': A direction cosine matrix (3x3 array)\n            - 'axis', 'angle': The euler axis (3 element vector) and angle of\n              rotation (float)\n            - 'standard_axis', 'angle': The principal axis of rotation\n              (int, 1,2,3) and angle of rotation (float)\n            - 'quaternion': A unit quaternion (4 element vector)\n\n        \"\"\"\n\n        if len(args) != 0:\n            assert (\n                len(kwargs) == 0\n            ), \"Only positional or keyword arguments accepted, not both\"\n\n            if len(args) == 1:\n                _input = np.array(args[0])\n                if len(_input) == 4:  # Infer Quaternion\n                    _dcm = quaternion2direction_cosine_matrix(_input)\n                else:  # Infer DCM\n                    _dcm = _input\n            elif len(args) == 2:  # Euler Axis Angle\n                _dcm = euler_axis_angle2direction_cosine_matrix(args[0], args[1])\n            elif len(args) == 4:  # Quaternions\n                _dcm = quaternion2direction_cosine_matrix(np.array(args))\n            else:\n                raise ValueError(f\"Cannot handle {len(args)} positional arguments\")\n        else:\n            if \"dcm\" in kwargs:\n                assert \"axis\" not in kwargs, \"Duplicate rotation definitions\"\n                assert \"angle\" not in kwargs, \"Duplicate rotation definitions\"\n                assert \"quaternion\" not in kwargs, \"Duplicate rotation definitions\"\n\n                _dcm = kwargs[\"dcm\"]\n\n            elif \"axis\" in kwargs:\n                assert \"angle\" in kwargs, \"No angle provided\"\n                assert \"dcm\" not in kwargs, \"Duplicate rotation definitions\"\n                assert \"quaternion\" not in kwargs, \"Duplicate rotation definitions\"\n                assert \"standard_axis\" not in kwargs, \"Duplicate rotation definitions\"\n\n                _dcm = euler_axis_angle2direction_cosine_matrix(\n                    kwargs[\"axis\"], kwargs[\"angle\"]\n                )\n\n            elif \"standard_axis\" in kwargs:\n                assert \"angle\" in kwargs, \"No angle provided\"\n                assert \"dcm\" not in kwargs, \"Duplicate rotation definitions\"\n                assert \"quaternion\" not in kwargs, \"Duplicate rotation definitions\"\n                assert \"axis\" not in kwargs, \"Duplicate rotation definitions\"\n\n                _standard_axis = {\n                    1: np.array((1.0, 0.0, 0.0), dtype=float),\n                    2: np.array((0.0, 1.0, 0.0), dtype=float),\n                    3: np.array((0.0, 0.0, 1.0), dtype=float),\n                }\n\n                assert (\n                    kwargs[\"standard_axis\"] in _standard_axis\n                ), f'Invalid standard axis {kwargs[\"standard_axis\"]}'\n\n                _dcm = euler_axis_angle2direction_cosine_matrix(\n                    _standard_axis[kwargs[\"standard_axis\"]], kwargs[\"angle\"]\n                )\n\n            elif \"quaternion\" in kwargs:\n                assert \"dcm\" not in kwargs, \"Duplicate rotation definitions\"\n                assert \"axis\" not in kwargs, \"Duplicate rotation definitions\"\n                assert \"angle\" not in kwargs, \"Duplicate rotation definitions\"\n\n                _quaternion = np.array(kwargs[\"quaternion\"])\n                _dcm = quaternion2direction_cosine_matrix(_quaternion)\n\n        self._check_dcm(_dcm)\n        self._rotator = _Rotator(np.array(_dcm, dtype=float))\n\n    @staticmethod\n    def _check_dcm(dcm: np.ndarray) -&gt; None:\n        \"\"\"Check to see if a Direction Cosine Matrix is valid.\n\n        Specifically, this static method checks to ensure that the input\n        direction cosine matrix is a 3x3 matrix that is both right-handed and\n        orthonormal.\n\n        Parameters\n        ----------\n        dcm : np.ndarray\n            The Direction Cosine Matrix of interest.\n\n        \"\"\"\n        assert np.shape(dcm) == (3, 3), \"Direction Cosine Matrix must be 3x3\"\n        assert np.isclose(\n            abs(np.linalg.det(dcm) - 1), 0\n        ), \"Direction Cosine Matrix must be right-handed and orthonormal\"\n\n    def rotate(self, vector: np.array) -&gt; np.array:\n        \"\"\"Rotate a vector by this rotaion.\n\n        !!! note \"Vector Objects\"\n            gps_frames.vectors includes an object called Vector. This method\n            takes a numpy array that represents a vector. This is deliberate\n            because rotations are dependant on a frame and the Vector object\n            requires a frame\n\n        Parameters\n        ----------\n        vector : np.array\n            The 3-element 1D numpy array representing a vector\n\n        Returns\n        -------\n        np.array\n            The vector rotated into the new frame\n\n        \"\"\"\n        return self._rotator.rotate(np.array(vector, dtype=float))\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.Rotation.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Construct a Rotation Object</p> <p>Types</p> <p>Because this acts as an interface to a numba object (which is strictly typed), it is recommended that all inputs contain only floats. This should be corrected automatically, but success cannot be guarenteed.</p> <p>This constructor is able to take a various numbers of input arguments to create a _Rotator object. These can either be positional or keyword arguments. It is recommended to use the keyword arguments to avoid ambiguity.</p> <p>Duplicate Definitions</p> <p>There can only be one definition of the rotation. If multiple definitions are given, it will raise an error. This includes having both positional and keyword arguments.</p> <p>This constructor functions by taking the input arguments and converting the rotation representation to a direction cosine matrix, which is then used to instantiate a _Rotator object.</p> <p>Quaternion Ordering</p> <p>The order of the unit quaternion inputs are (\\(q_{w}\\), \\(q_{i}\\), \\(q_{j}\\), \\(q_{k}\\)) where</p> <p>\\(\\mathbf{q} = q_{w} + q_{i}i + q_{j}j + q_{k}k\\).</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>If one positional argument is provided, it is assumed to be either a unit quaternion (if its length is 4) or a direction cosine matrix (otherwise). If two positional arguments are provided, then the first positional argument is assumed to be the axis of rotation and the second argument is assumed to be the angle of rotation. If four positional arguments are given, the values are assumed to be the components of the unit quaternion.</p> <code>()</code> <code>**kwargs</code> <p>The rotation can be defined using keyword arguments. The valid keyword arguments are:</p> <ul> <li>'dcm': A direction cosine matrix (3x3 array)</li> <li>'axis', 'angle': The euler axis (3 element vector) and angle of   rotation (float)</li> <li>'standard_axis', 'angle': The principal axis of rotation   (int, 1,2,3) and angle of rotation (float)</li> <li>'quaternion': A unit quaternion (4 element vector)</li> </ul> <code>{}</code> Source code in <code>gps_frames/rotations.py</code> <pre><code>def __init__(self, *args, **kwargs) -&gt; None:\n    r\"\"\"Construct a Rotation Object\n\n    !!! note \"Types\"\n        Because this acts as an interface to a numba object (which is\n        strictly typed), it is recommended that all inputs contain only\n        floats. This should be corrected automatically, but success cannot\n        be guarenteed.\n\n    This constructor is able to take a various numbers of input arguments\n    to create a _Rotator object. These can either be positional or keyword\n    arguments. It is recommended to use the keyword arguments to avoid\n    ambiguity.\n\n    !!! warning \"Duplicate Definitions\"\n        There can only be one definition of the rotation. If multiple\n        definitions are given, it will raise an error. This includes\n        having both positional and keyword arguments.\n\n    This constructor functions by taking the input arguments and\n    converting the rotation representation to a direction cosine matrix,\n    which is then used to instantiate a _Rotator object.\n\n    !!! tip \"Quaternion Ordering\"\n        The order of the unit quaternion inputs are (\\(q_{w}\\), \\(q_{i}\\),\n        \\(q_{j}\\), \\(q_{k}\\)) where\n\n        \\(\\mathbf{q} = q_{w} + q_{i}i + q_{j}j + q_{k}k\\).\n\n    Parameters\n    ----------\n    *args\n        If one positional argument is provided, it is assumed to be either\n        a unit quaternion (if its length is 4) or a direction cosine\n        matrix (otherwise). If two positional arguments are provided, then\n        the first positional argument is assumed to be the axis of\n        rotation and the second argument is assumed to be the angle of\n        rotation. If four positional arguments are given, the values are\n        assumed to be the components of the unit quaternion.\n    **kwargs\n        The rotation can be defined using keyword arguments. The valid\n        keyword arguments are:\n\n        - 'dcm': A direction cosine matrix (3x3 array)\n        - 'axis', 'angle': The euler axis (3 element vector) and angle of\n          rotation (float)\n        - 'standard_axis', 'angle': The principal axis of rotation\n          (int, 1,2,3) and angle of rotation (float)\n        - 'quaternion': A unit quaternion (4 element vector)\n\n    \"\"\"\n\n    if len(args) != 0:\n        assert (\n            len(kwargs) == 0\n        ), \"Only positional or keyword arguments accepted, not both\"\n\n        if len(args) == 1:\n            _input = np.array(args[0])\n            if len(_input) == 4:  # Infer Quaternion\n                _dcm = quaternion2direction_cosine_matrix(_input)\n            else:  # Infer DCM\n                _dcm = _input\n        elif len(args) == 2:  # Euler Axis Angle\n            _dcm = euler_axis_angle2direction_cosine_matrix(args[0], args[1])\n        elif len(args) == 4:  # Quaternions\n            _dcm = quaternion2direction_cosine_matrix(np.array(args))\n        else:\n            raise ValueError(f\"Cannot handle {len(args)} positional arguments\")\n    else:\n        if \"dcm\" in kwargs:\n            assert \"axis\" not in kwargs, \"Duplicate rotation definitions\"\n            assert \"angle\" not in kwargs, \"Duplicate rotation definitions\"\n            assert \"quaternion\" not in kwargs, \"Duplicate rotation definitions\"\n\n            _dcm = kwargs[\"dcm\"]\n\n        elif \"axis\" in kwargs:\n            assert \"angle\" in kwargs, \"No angle provided\"\n            assert \"dcm\" not in kwargs, \"Duplicate rotation definitions\"\n            assert \"quaternion\" not in kwargs, \"Duplicate rotation definitions\"\n            assert \"standard_axis\" not in kwargs, \"Duplicate rotation definitions\"\n\n            _dcm = euler_axis_angle2direction_cosine_matrix(\n                kwargs[\"axis\"], kwargs[\"angle\"]\n            )\n\n        elif \"standard_axis\" in kwargs:\n            assert \"angle\" in kwargs, \"No angle provided\"\n            assert \"dcm\" not in kwargs, \"Duplicate rotation definitions\"\n            assert \"quaternion\" not in kwargs, \"Duplicate rotation definitions\"\n            assert \"axis\" not in kwargs, \"Duplicate rotation definitions\"\n\n            _standard_axis = {\n                1: np.array((1.0, 0.0, 0.0), dtype=float),\n                2: np.array((0.0, 1.0, 0.0), dtype=float),\n                3: np.array((0.0, 0.0, 1.0), dtype=float),\n            }\n\n            assert (\n                kwargs[\"standard_axis\"] in _standard_axis\n            ), f'Invalid standard axis {kwargs[\"standard_axis\"]}'\n\n            _dcm = euler_axis_angle2direction_cosine_matrix(\n                _standard_axis[kwargs[\"standard_axis\"]], kwargs[\"angle\"]\n            )\n\n        elif \"quaternion\" in kwargs:\n            assert \"dcm\" not in kwargs, \"Duplicate rotation definitions\"\n            assert \"axis\" not in kwargs, \"Duplicate rotation definitions\"\n            assert \"angle\" not in kwargs, \"Duplicate rotation definitions\"\n\n            _quaternion = np.array(kwargs[\"quaternion\"])\n            _dcm = quaternion2direction_cosine_matrix(_quaternion)\n\n    self._check_dcm(_dcm)\n    self._rotator = _Rotator(np.array(_dcm, dtype=float))\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.Rotation.rotate","title":"<code>rotate(vector)</code>","text":"<p>Rotate a vector by this rotaion.</p> <p>Vector Objects</p> <p>gps_frames.vectors includes an object called Vector. This method takes a numpy array that represents a vector. This is deliberate because rotations are dependant on a frame and the Vector object requires a frame</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>array</code> <p>The 3-element 1D numpy array representing a vector</p> required <p>Returns:</p> Type Description <code>array</code> <p>The vector rotated into the new frame</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>def rotate(self, vector: np.array) -&gt; np.array:\n    \"\"\"Rotate a vector by this rotaion.\n\n    !!! note \"Vector Objects\"\n        gps_frames.vectors includes an object called Vector. This method\n        takes a numpy array that represents a vector. This is deliberate\n        because rotations are dependant on a frame and the Vector object\n        requires a frame\n\n    Parameters\n    ----------\n    vector : np.array\n        The 3-element 1D numpy array representing a vector\n\n    Returns\n    -------\n    np.array\n        The vector rotated into the new frame\n\n    \"\"\"\n    return self._rotator.rotate(np.array(vector, dtype=float))\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.direction_cosine_matrix2euler_axis_angle","title":"<code>direction_cosine_matrix2euler_axis_angle(dcm)</code>","text":"<p>Convert a Direction Cosine Matrix to an Euler axis and angle.</p> <p>This function simply calls direction_cosine_matrix2quaternion() to convert the input DCM to the corresponding unit quaternion. From there, the quaternion is converted to the corresponding Euler axis and angle using quaternion2euler_axis_angle().</p> <p>Numba JIT Compiled</p> <p>This function is compiled using Numba. Use care when providing inputs as Numba is strictly typed. Unless otherwise stated, all inputs should be float arrays.</p> <p>Parameters:</p> Name Type Description Default <code>dcm</code> <code>ndarray</code> <p>The direction cosine matrix</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, float]</code> <p>A tuple where the first element is a 3-element 1D numpy array representing the rotation axis and the second element is the angle of rotation, in radians.</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>@jit(\"Tuple((float64[:], float64))(float64[:,:])\", nopython=True, cache=True)\ndef direction_cosine_matrix2euler_axis_angle(\n    dcm: np.ndarray,\n) -&gt; Tuple[np.ndarray, float]:\n    \"\"\"Convert a Direction Cosine Matrix to an Euler axis and angle.\n\n    This function simply calls direction_cosine_matrix2quaternion() to convert\n    the input DCM to the corresponding unit quaternion. From there, the\n    quaternion is converted to the corresponding Euler axis and angle using\n    quaternion2euler_axis_angle().\n\n    !!! note \"Numba JIT Compiled\"\n        This function is compiled using Numba. Use care when providing inputs\n        as Numba is strictly typed. Unless otherwise stated, all inputs should\n        be float arrays.\n\n    Parameters\n    ----------\n    dcm : np.ndarray\n        The direction cosine matrix\n\n    Returns\n    -------\n    Tuple[np.ndarray, float]\n        A tuple where the first element is a 3-element 1D numpy array\n        representing the rotation axis and the second element is the angle\n        of rotation, in radians.\n\n    \"\"\"\n    quaternion = direction_cosine_matrix2quaternion(dcm)\n    return quaternion2euler_axis_angle(quaternion)\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.direction_cosine_matrix2quaternion","title":"<code>direction_cosine_matrix2quaternion(dcm)</code>","text":"<p>Create a rotation object from a Direction Cosine Matrix.</p> <p>Let the direction cosine matrix be \\(\\mathbf{R}\\). The \\(q_{w}\\) element of the quaternion can be computed as</p> \\[ q_{w} = \\frac{         \\sqrt{1 + \\text{trace}\\mathbf{R}}     }{         2     } \\] <p>The remaining elements of the quaternion are then computed as</p> \\[ \\begin{split}     q_{i} = &amp; \\frac{         \\mathbf{R}_{23} - \\mathbf{R}_{32}}{4q_{w}} \\\\     q_{j} = &amp; \\frac{         \\mathbf{R}_{31} - \\mathbf{R}_{13}}{4q_{w}} \\\\     q_{k} = &amp; \\frac{         \\mathbf{R}_{12} - \\mathbf{R}_{21}}{4q_{w}} \\\\ \\end{split} \\] <p>The quaternion is represented as</p> \\[ \\bar{\\mathbf{q}} = \\left[     q_{w} \\quad q_{i} \\quad q_{j} \\quad q_{k} \\right] \\] <p>There a singulariy when the rotation is by an angle of \\(\\pi\\). This occurs because \\(q_{w} = \\cos\\left(\\theta / 2\\right)\\), so \\(q_{w}=0\\) when \\(\\theta=\\pi\\). In the previous expression, the other quaternion elements were found by dividing the difference of various DCM elements by \\(4q_{w}\\), which cannot be done of \\(q_{w}=0\\). Thus, for these cases, an alternate approach is used. The angle of rotation is known (because \\(\\cos(\\pi/2) = \\cos(-\\pi/2) = 0\\) to be \\(\\pi\\). The axis of rotation is found by find the eigenvector to the DCM corresponding the eigenvalue with a value of 1. This is done by calling euler_axis_angle2quaternion().</p> <p>Numba JIT Compiled</p> <p>This function is compiled using Numba. Use care when providing inputs as Numba is strictly typed. Unless otherwise stated, all inputs should be float arrays.</p> <p>Parameters:</p> Name Type Description Default <code>dcm</code> <code>ndarray</code> <p>The direction cosine matrix (a 3x3 matrix)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The corresponding unit quaternion</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>@jit(\"float64[:](float64[:,:])\", nopython=True, cache=True)\ndef direction_cosine_matrix2quaternion(dcm: np.ndarray) -&gt; np.array:\n    r\"\"\"Create a rotation object from a Direction Cosine Matrix.\n\n    Let the direction cosine matrix be \\(\\mathbf{R}\\). The \\(q_{w}\\)\n    element of the quaternion can be computed as\n\n    $$\n    q_{w} = \\frac{\n            \\sqrt{1 + \\text{trace}\\mathbf{R}}\n        }{\n            2\n        }\n    $$\n\n    The remaining elements of the quaternion are then computed as\n\n    $$\n    \\begin{split}\n        q_{i} = &amp; \\frac{\n            \\mathbf{R}_{23} - \\mathbf{R}_{32}}{4q_{w}} \\\\\n        q_{j} = &amp; \\frac{\n            \\mathbf{R}_{31} - \\mathbf{R}_{13}}{4q_{w}} \\\\\n        q_{k} = &amp; \\frac{\n            \\mathbf{R}_{12} - \\mathbf{R}_{21}}{4q_{w}} \\\\\n    \\end{split}\n    $$\n\n    The quaternion is represented as\n\n    $$\n    \\bar{\\mathbf{q}} = \\left[\n        q_{w} \\quad q_{i} \\quad q_{j} \\quad q_{k}\n    \\right]\n    $$\n\n    There a singulariy when the rotation is by an angle of \\(\\pi\\).\n    This occurs because \\(q_{w} = \\cos\\left(\\theta / 2\\right)\\), so\n    \\(q_{w}=0\\) when \\(\\theta=\\pi\\). In the previous expression, the other\n    quaternion elements were found by dividing the difference of various DCM\n    elements by \\(4q_{w}\\), which cannot be done of \\(q_{w}=0\\). Thus, for\n    these cases, an alternate approach is used. The angle of rotation is known\n    (because \\(\\cos(\\pi/2) = \\cos(-\\pi/2) = 0\\) to be \\(\\pi\\). The axis of\n    rotation is found by find the eigenvector to the DCM corresponding the\n    eigenvalue with a value of 1. This is done by calling\n    euler_axis_angle2quaternion().\n\n    !!! note \"Numba JIT Compiled\"\n        This function is compiled using Numba. Use care when providing inputs\n        as Numba is strictly typed. Unless otherwise stated, all inputs should\n        be float arrays.\n\n    Parameters\n    ----------\n    dcm : np.ndarray\n        The direction cosine matrix (a 3x3 matrix)\n\n    Returns\n    -------\n    np.ndarray\n        The corresponding unit quaternion\n\n    \"\"\"\n\n    qw = np.sqrt(1 + np.trace(dcm)) / 2\n    if qw == 0.0:\n        euler_angle = np.pi\n\n        eig_val, eig_axis = np.linalg.eigh(dcm)\n\n        for _i in range(3):\n            if eig_val[_i] == 1:\n                euler_axis = eig_axis[:, _i]\n                break\n        else:\n            raise ValueError(\"Encountered singular DCM\")\n\n        return euler_axis_angle2quaternion(euler_axis, euler_angle)\n\n    else:\n        qi = (dcm[1, 2] - dcm[2, 1]) / (4 * qw)\n        qj = (dcm[2, 0] - dcm[0, 2]) / (4 * qw)\n        qk = (dcm[0, 1] - dcm[1, 0]) / (4 * qw)\n\n        return np.array([qw, qi, qj, qk])\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.euler_axis_angle2direction_cosine_matrix","title":"<code>euler_axis_angle2direction_cosine_matrix(euler_axis, euler_angle)</code>","text":"<p>Convert an Euler axis and angle to a Direction Cosine Matrix.</p> <p>This function simply calls euler_axis_angle2quaternion() to convert the input Euler axis and angle to the corresponding unit quaternion. From there, the quaternion is converted to the corresponding DCM using quaternion2direction_cosine_matrix().</p> <p>Numba JIT Compiled</p> <p>This function is compiled using Numba. Use care when providing inputs as Numba is strictly typed. Unless otherwise stated, all inputs should be float arrays.</p> <p>Parameters:</p> Name Type Description Default <code>euler_axis</code> <code>ndarray</code> <p>The axis of rotation. Will be normalized to a magnitude of 1</p> required <code>euler_angle</code> <code>float</code> <p>The angle of rotation in radians</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The direction cosine matrix (a 3x3 matrix)</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>@jit(\"float64[:,:](float64[:], float64)\", nopython=True, cache=True)\ndef euler_axis_angle2direction_cosine_matrix(\n    euler_axis: np.ndarray, euler_angle: float\n) -&gt; np.ndarray:\n    \"\"\"Convert an Euler axis and angle to a Direction Cosine Matrix.\n\n    This function simply calls euler_axis_angle2quaternion() to convert\n    the input Euler axis and angle to the corresponding unit quaternion. From\n    there, the quaternion is converted to the corresponding DCM using\n    quaternion2direction_cosine_matrix().\n\n\n    !!! note \"Numba JIT Compiled\"\n        This function is compiled using Numba. Use care when providing inputs\n        as Numba is strictly typed. Unless otherwise stated, all inputs should\n        be float arrays.\n\n    Parameters\n    ----------\n    euler_axis : np.ndarray\n        The axis of rotation. Will be normalized to a magnitude of 1\n    euler_angle : float\n        The angle of rotation in radians\n    Returns\n    -------\n    np.ndarray\n        The direction cosine matrix (a 3x3 matrix)\n\n    \"\"\"\n    return quaternion2direction_cosine_matrix(\n        euler_axis_angle2quaternion(euler_axis, euler_angle)\n    )\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.euler_axis_angle2quaternion","title":"<code>euler_axis_angle2quaternion(euler_axis, euler_angle)</code>","text":"<p>Convert an Euler axis and angle to a quaternion.</p> <p>Let the Euler axis and angle be \\(\\hat{\\mathbf{e}}\\) and \\(\\Phi\\), respectively. The equivalent quaternion is</p> \\[ \\bar{\\mathbf{q}} =     \\left[\\begin{array}{c}         q_{w} \\\\         q_{i} \\\\         q_{j} \\\\         q_{k}     \\end{array}\\right]     =     \\left[\\begin{array}{c}         \\cos\\frac{\\Phi}{2} \\\\         \\hat{\\mathbf{e}}\\sin\\frac{\\Phi}{2}     \\end{array}\\right] \\] <p>Numba JIT Compiled</p> <p>This function is compiled using Numba. Use care when providing inputs as Numba is strictly typed. Unless otherwise stated, all inputs should be float arrays.</p> <p>Parameters:</p> Name Type Description Default <code>euler_axis</code> <code>ndarray</code> <p>The axis of rotation. Will be normalized to a magnitude of 1</p> required <code>euler_angle</code> <code>float</code> <p>The angle of rotation in radians</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The quaternion equivalent to the the euler axis and angle</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>@jit(\"float64[:](float64[:], float64)\", nopython=True, cache=True)\ndef euler_axis_angle2quaternion(\n    euler_axis: np.ndarray, euler_angle: float\n) -&gt; np.ndarray:\n    r\"\"\"Convert an Euler axis and angle to a quaternion.\n\n    Let the Euler axis and angle be \\(\\hat{\\mathbf{e}}\\) and\n    \\(\\Phi\\), respectively. The equivalent quaternion is\n\n    $$\n    \\bar{\\mathbf{q}} =\n        \\left[\\begin{array}{c}\n            q_{w} \\\\\n            q_{i} \\\\\n            q_{j} \\\\\n            q_{k}\n        \\end{array}\\right]\n        =\n        \\left[\\begin{array}{c}\n            \\cos\\frac{\\Phi}{2} \\\\\n            \\hat{\\mathbf{e}}\\sin\\frac{\\Phi}{2}\n        \\end{array}\\right]\n    $$\n\n    !!! note \"Numba JIT Compiled\"\n        This function is compiled using Numba. Use care when providing inputs\n        as Numba is strictly typed. Unless otherwise stated, all inputs should\n        be float arrays.\n\n    Parameters\n    ----------\n    euler_axis : np.ndarray\n        The axis of rotation. Will be normalized to a magnitude of 1\n    euler_angle : float\n        The angle of rotation in radians\n\n    Returns\n    -------\n    np.ndarray\n        The quaternion equivalent to the the euler axis and angle\n\n    \"\"\"\n    euler_axis = euler_axis / np.linalg.norm(euler_axis)  # Normialize length\n    qijk = euler_axis * np.sin(euler_angle / 2) / np.linalg.norm(euler_axis)\n    quaternion = np.append(np.cos(euler_angle / 2), qijk)\n\n    return quaternion / np.linalg.norm(quaternion)\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.quaternion2direction_cosine_matrix","title":"<code>quaternion2direction_cosine_matrix(quaternion)</code>","text":"<p>Convert quaternions to a direction cosine matrix.</p> <p>A quaternions can be represented as</p> \\[ \\bar{\\mathbf{q}} = \\left[     q_{w} \\quad q_{i} \\quad q_{j} \\quad q_{k} \\right] \\] <p>The equivalent direction cosine matrix can then be computed as</p> \\[ \\mathbf{R} =     \\left[\\begin{array}{ccc}         q_{w}^{2} + q_{i}^{2} - q_{j}^{2} - q_{k}^{2} &amp;         2 \\left( q_{i}q_{j} - q_{k}q_{w} \\right) &amp;         2 \\left( q_{i}q_{k} + q_{j}q_{w} \\right) \\\\         2 \\left( q_{i}q_{j} + q_{k}q_{w} \\right) &amp;         q_{w}^{2} - q_{i}^{2} + q_{j}^{2} - q_{k}^{2} &amp;         2 \\left( q_{j}q_{k} - q_{i}q_{w} \\right) \\\\         2 \\left( q_{i}q_{k} - q_{j}q_{w} \\right) &amp;         2 \\left( q_{j}q_{k} + q_{i}q_{w} \\right) &amp;         q_{w}^{2} - q_{i}^{2} - q_{j}^{2} + q_{k}^{2}     \\end{array}\\right] \\] <p>Numba JIT Compiled</p> <p>This function is compiled using Numba. Use care when providing inputs as Numba is strictly typed. Unless otherwise stated, all inputs should be float arrays.</p> <p>Parameters:</p> Name Type Description Default <code>quaternion</code> <code>ndarray</code> <p>The unit quaternion to convert</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The 3x3 Direction Cosine Matrix that represents the rotation</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>@jit(\"float64[:,:](float64[:])\", nopython=True, cache=True)\ndef quaternion2direction_cosine_matrix(quaternion: np.ndarray) -&gt; np.ndarray:\n    r\"\"\"Convert quaternions to a direction cosine matrix.\n\n    A quaternions can be represented as\n\n    $$\n    \\bar{\\mathbf{q}} = \\left[\n        q_{w} \\quad q_{i} \\quad q_{j} \\quad q_{k}\n    \\right]\n    $$\n\n    The equivalent direction cosine matrix can then be computed as\n\n    $$\n    \\mathbf{R} =\n        \\left[\\begin{array}{ccc}\n            q_{w}^{2} + q_{i}^{2} - q_{j}^{2} - q_{k}^{2} &amp;\n            2 \\left( q_{i}q_{j} - q_{k}q_{w} \\right) &amp;\n            2 \\left( q_{i}q_{k} + q_{j}q_{w} \\right) \\\\\n            2 \\left( q_{i}q_{j} + q_{k}q_{w} \\right) &amp;\n            q_{w}^{2} - q_{i}^{2} + q_{j}^{2} - q_{k}^{2} &amp;\n            2 \\left( q_{j}q_{k} - q_{i}q_{w} \\right) \\\\\n            2 \\left( q_{i}q_{k} - q_{j}q_{w} \\right) &amp;\n            2 \\left( q_{j}q_{k} + q_{i}q_{w} \\right) &amp;\n            q_{w}^{2} - q_{i}^{2} - q_{j}^{2} + q_{k}^{2}\n        \\end{array}\\right]\n    $$\n\n\n    !!! note \"Numba JIT Compiled\"\n        This function is compiled using Numba. Use care when providing inputs\n        as Numba is strictly typed. Unless otherwise stated, all inputs should\n        be float arrays.\n\n    Parameters\n    ----------\n    quaternion : np.ndarray\n        The unit quaternion to convert\n\n    Returns\n    -------\n    np.ndarray\n        The 3x3 Direction Cosine Matrix that represents the rotation\n\n    \"\"\"\n    assert len(quaternion) == 4, \"Quaternions must have 4 elements\"\n\n    # Normalize\n    quaternion = quaternion / np.linalg.norm(quaternion)\n\n    qw = quaternion[0]\n    qi = quaternion[1]\n    qj = quaternion[2]\n    qk = quaternion[3]\n\n    dcm = np.array(\n        [\n            [\n                qw ** 2 + qi ** 2 - qj ** 2 - qk ** 2,\n                2 * (qi * qj - qk * qw),\n                2 * (qi * qk + qj * qw),\n            ],\n            [\n                2 * (qi * qj + qk * qw),\n                qw ** 2 - qi ** 2 + qj ** 2 - qk ** 2,\n                2 * (qj * qk - qi * qw),\n            ],\n            [\n                2 * (qi * qk - qj * qw),\n                2 * (qj * qk + qi * qw),\n                qw ** 2 - qi ** 2 - qj ** 2 + qk ** 2,\n            ],\n        ]\n    )\n    return np.transpose(dcm)\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.quaternion2euler_axis_angle","title":"<code>quaternion2euler_axis_angle(quaternion)</code>","text":"<p>Convert a quaternion to an euler axis and angle.</p> <p>Directional Ambiguity</p> <p>There is directional ambitguity when using this function. This occurs because rotating by an angle about a given axis is equivalent to rotating by the same angle in the opposite direction about the opposite axis. There is no way to resolve this ambitguity, but it should not effect anything in the simulation.</p> <p>A quaternions can be represented as</p> \\[ \\bar{\\mathbf{q}} = \\left[     q_{w} \\quad q_{i} \\quad q_{j} \\quad q_{k} \\right] \\] <p>with \\(\\mathbf{q}=[q_{i}, q_{j}, q_{k}]^{T}\\). The angle of rotation that this represents can be computed (using a 4-quadrant arctangent function) as</p> \\[ \\Phi = 2 \\tan^{-1}\\frac{     ||\\mathbf{q}|| }{     q_{w} } \\] <p>The axis of the rotation is then computed as</p> \\[ \\hat{\\mathbf{e}} = \\frac{         \\mathbf{q}     }{         ||\\mathbf{q}||     } \\] <p>Numba JIT Compiled</p> <p>This function is compiled using Numba. Use care when providing inputs as Numba is strictly typed. Unless otherwise stated, all inputs should be float arrays.</p> <p>Parameters:</p> Name Type Description Default <code>quaternion</code> <code>ndarray</code> <p>The unit quaternion to convert</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, float]</code> <p>A tuple where the first element is a 3-element 1D numpy array representing the rotation axis and the second element is the angle of rotation, in radians.</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>@jit(\"Tuple((float64[:], float64))(float64[:])\", nopython=True, cache=True)\ndef quaternion2euler_axis_angle(quaternion: np.ndarray) -&gt; Tuple[np.ndarray, float]:\n    r\"\"\"Convert a quaternion to an euler axis and angle.\n\n    !!! warning \"Directional Ambiguity\"\n        There is directional ambitguity when using this function. This occurs\n        because rotating by an angle about a given axis is equivalent to\n        rotating by the same angle in the opposite direction about the\n        opposite axis. There is no way to resolve this ambitguity, but it\n        should not effect anything in the simulation.\n\n    A quaternions can be represented as\n\n    $$\n    \\bar{\\mathbf{q}} = \\left[\n        q_{w} \\quad q_{i} \\quad q_{j} \\quad q_{k}\n    \\right]\n    $$\n\n    with \\(\\mathbf{q}=[q_{i}, q_{j}, q_{k}]^{T}\\). The angle of\n    rotation that this represents can be computed (using a 4-quadrant\n    arctangent function) as\n\n    $$\n    \\Phi = 2 \\tan^{-1}\\frac{\n        ||\\mathbf{q}||\n    }{\n        q_{w}\n    }\n    $$\n\n    The axis of the rotation is then computed as\n\n    $$\n    \\hat{\\mathbf{e}} = \\frac{\n            \\mathbf{q}\n        }{\n            ||\\mathbf{q}||\n        }\n    $$\n\n    !!! note \"Numba JIT Compiled\"\n        This function is compiled using Numba. Use care when providing inputs\n        as Numba is strictly typed. Unless otherwise stated, all inputs should\n        be float arrays.\n\n    Parameters\n    ----------\n    quaternion : np.ndarray\n        The unit quaternion to convert\n\n    Returns\n    -------\n    Tuple[np.ndarray, float]\n        A tuple where the first element is a 3-element 1D numpy array\n        representing the rotation axis and the second element is the angle\n        of rotation, in radians.\n\n    \"\"\"\n    qw = quaternion[0]\n    qijk = quaternion[1:]\n\n    euler_angle = 2 * np.arctan2(np.linalg.norm(qijk), qw)\n    euler_axis = qijk / np.linalg.norm(qijk)\n\n    return euler_axis, euler_angle\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.roll_pitch_yaw","title":"<code>roll_pitch_yaw(roll_angle, pitch_angle, yaw_angle, vector)</code>","text":"<p>Rotate a vector through a roll-pitch-yaw sequence.</p> <p>This function is an optimized way to rotate a vector through a roll-ptich-yaw sequence. This sequence is a rotation about the 1, 2, and 3 axes in that order, that is first it it rolled, then pitched, then yawed.</p> <p>For a single rotation, this class is faster to use than the Rotation class as it is signficantly simpler to instantiate. However, if a rotation needs to be performed repeatedly, the Rotation class may be faster.</p> <p>.. note:: Numba JIT Compiled     This function is compiled using Numba. Use care when providing inputs     as Numba is strictly typed. The inputs to this function are three     floats and a float array.</p> <p>Parameters:</p> Name Type Description Default <code>roll_angle</code> <code>float</code> <p>Angle of rotation about the roll axis in radians</p> required <code>pitch_angle</code> <code>float</code> <p>Angle of rotation about the pitch axis in radians</p> required <code>yaw_angle</code> <code>float</code> <p>Angle of rotation about the yaw axis in radians</p> required <code>vector</code> <code>ndarray</code> <p>The vector to rotate</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The vector rotated to the new frame</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>@jit(\"float64[:](float64, float64, float64, float64[:])\", nopython=True, cache=True)\ndef roll_pitch_yaw(\n    roll_angle: float, pitch_angle: float, yaw_angle: float, vector: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"Rotate a vector through a roll-pitch-yaw sequence.\n\n    This function is an optimized way to rotate a vector through a\n    roll-ptich-yaw sequence. This sequence is a rotation about the 1, 2, and 3\n    axes in that order, that is first it it rolled, then pitched, then yawed.\n\n    For a single rotation, this class is faster to use than the Rotation class\n    as it is signficantly simpler to instantiate. However, if a rotation needs\n    to be performed repeatedly, the Rotation class may be faster.\n\n    .. note:: Numba JIT Compiled\n        This function is compiled using Numba. Use care when providing inputs\n        as Numba is strictly typed. The inputs to this function are three\n        floats and a float array.\n\n    Parameters\n    ----------\n    roll_angle : float\n        Angle of rotation about the roll axis in radians\n    pitch_angle : float\n        Angle of rotation about the pitch axis in radians\n    yaw_angle : float\n        Angle of rotation about the yaw axis in radians\n    vector : np.ndarray\n        The vector to rotate\n\n    Returns\n    -------\n    np.ndarray\n        The vector rotated to the new frame\n\n    \"\"\"\n\n    return roll_pitch_yaw_matrix(roll_angle, pitch_angle, yaw_angle) @ vector\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.roll_pitch_yaw_matrix","title":"<code>roll_pitch_yaw_matrix(roll_angle, pitch_angle, yaw_angle)</code>","text":"<p>Create the Direction Cosine Matrix fo a roll-pitch-yaw sequence.</p> <p>This function is a way to generate the direction cosine matrix representing a roll-pitch-yaw sequence. This sequence is a rotation about the 1, 2, and 3 axes in that order, that is first it it rolled, then pitched, then yawed.</p> <p>Let \\(\\theta,\\phi,\\psi\\) be the roll, pitch, and yaw angles, respectively. The corresponding direction cosine matrix is</p> \\[     \\mathbf{R}(\\theta,\\phi,\\psi) =         \\left[\\begin{array}{ccc}             \\cos\\psi \\cos\\phi &amp;             \\cos\\psi \\sin\\phi \\sin\\theta - \\sin\\psi \\cos\\theta &amp;             \\cos\\psi \\sin\\phi \\cos\\theta + \\sin\\psi \\sin\\theta \\\\             \\sin\\psi \\cos\\phi &amp;             \\sin\\psi \\sin\\phi \\sin\\theta + \\cos\\psi \\cos\\theta &amp;             \\sin\\psi \\sin\\phi \\cos\\theta - \\cos\\psi \\sin\\theta \\\\             -\\sin\\phi &amp;             \\cos\\phi \\sin\\theta &amp;             \\cos\\phi \\cos\\theta         \\end{array}\\right] \\] <p>.. note:: Numba JIT Compiled     This function is compiled using Numba. Use care when providing inputs     as Numba is strictly typed. The inputs to this function are three     floats and a float array.</p> <p>Parameters:</p> Name Type Description Default <code>roll_angle</code> <code>float</code> <p>Angle of rotation about the roll axis in radians</p> required <code>pitch_angle</code> <code>float</code> <p>Angle of rotation about the pitch axis in radians</p> required <code>yaw_angle</code> <code>float</code> <p>Angle of rotation about the yaw axis in radians</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The direction cosine matrix representing the rotation.</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>@jit(\"float64[:, :](float64, float64, float64)\", nopython=True, cache=True)\ndef roll_pitch_yaw_matrix(\n    roll_angle: float, pitch_angle: float, yaw_angle: float\n) -&gt; np.ndarray:\n    r\"\"\"Create the Direction Cosine Matrix fo a roll-pitch-yaw sequence.\n\n    This function is a way to generate the direction cosine matrix\n    representing a roll-pitch-yaw sequence. This sequence is a rotation about\n    the 1, 2, and 3 axes in that order, that is first it it rolled, then\n    pitched, then yawed.\n\n    Let \\(\\theta,\\phi,\\psi\\) be the roll, pitch, and yaw angles, respectively.\n    The corresponding direction cosine matrix is\n\n    $$\n        \\mathbf{R}(\\theta,\\phi,\\psi) =\n            \\left[\\begin{array}{ccc}\n                \\cos\\psi \\cos\\phi &amp;\n                \\cos\\psi \\sin\\phi \\sin\\theta - \\sin\\psi \\cos\\theta &amp;\n                \\cos\\psi \\sin\\phi \\cos\\theta + \\sin\\psi \\sin\\theta \\\\\n                \\sin\\psi \\cos\\phi &amp;\n                \\sin\\psi \\sin\\phi \\sin\\theta + \\cos\\psi \\cos\\theta &amp;\n                \\sin\\psi \\sin\\phi \\cos\\theta - \\cos\\psi \\sin\\theta \\\\\n                -\\sin\\phi &amp;\n                \\cos\\phi \\sin\\theta &amp;\n                \\cos\\phi \\cos\\theta\n            \\end{array}\\right]\n    $$\n\n    .. note:: Numba JIT Compiled\n        This function is compiled using Numba. Use care when providing inputs\n        as Numba is strictly typed. The inputs to this function are three\n        floats and a float array.\n\n    Parameters\n    ----------\n    roll_angle : float\n        Angle of rotation about the roll axis in radians\n    pitch_angle : float\n        Angle of rotation about the pitch axis in radians\n    yaw_angle : float\n        Angle of rotation about the yaw axis in radians\n\n    Returns\n    -------\n    np.ndarray\n        The direction cosine matrix representing the rotation.\n\n    \"\"\"\n    if np.abs(pitch_angle - np.pi / 2) &lt; 1.0e-8 or np.abs(pitch_angle + np.pi / 2) &lt; 1.0e-8:\n        with objmode:\n            logger.warning(\"Singular rotation (gimbal lock) detected in roll_pitch_yaw_matrix\")\n\n    _c_roll = np.cos(roll_angle)\n    _s_roll = np.sin(roll_angle)\n\n    _c_pitch = np.cos(pitch_angle)\n    _s_pitch = np.sin(pitch_angle)\n\n    _c_yaw = np.cos(yaw_angle)\n    _s_yaw = np.sin(yaw_angle)\n\n    dcm = np.array(\n        [\n            [\n                _c_yaw * _c_pitch,\n                _c_yaw * _s_pitch * _s_roll - _s_yaw * _c_roll,\n                _c_yaw * _s_pitch * _c_roll + _s_yaw * _s_roll,\n            ],\n            [\n                _s_yaw * _c_pitch,\n                _s_yaw * _s_pitch * _s_roll + _c_yaw * _c_roll,\n                _s_yaw * _s_pitch * _c_roll - _c_yaw * _s_roll,\n            ],\n            [-_s_pitch, _c_pitch * _s_roll, _c_pitch * _c_roll],\n        ]\n    )\n\n    return dcm\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.standard_rotation","title":"<code>standard_rotation(rotation_axis, angle, vector)</code>","text":"<p>Rotate a vector about a principal axis.</p> <p>This function is an optimized way to rotate about one of the principal axes. The inputs are the axis to rotate around and the angle of rotation, along with the vector be rotated.</p> <p>For a single rotation, this class is faster to use than the Rotation class as it is signficantly simpler to instantiate. However, if a rotation needs to be performed repeatedly, the Rotation class may be faster.</p> <p>Numba JIT Compiled</p> <p>This function is compiled using Numba. Use care when providing inputs as Numba is strictly typed. The inputs to this function are an int, a float, and a float array.</p> <p>Parameters:</p> Name Type Description Default <code>rotation_axis</code> <code>int</code> <p>The axis of rotation. Must be 1, 2, or 3 (corresponding to x,y, and x)</p> required <code>angle</code> <code>float</code> <p>The angle of rotation in radians</p> required <code>vector</code> <code>ndarray</code> <p>The vector to rotate</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The vector rotated to the new frame</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>@jit(\"float64[:](int8, float64, float64[:])\", nopython=True, cache=True)\ndef standard_rotation(\n    rotation_axis: int, angle: float, vector: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"Rotate a vector about a principal axis.\n\n    This function is an optimized way to rotate about one of the principal\n    axes. The inputs are the axis to rotate around and the angle of rotation,\n    along with the vector be rotated.\n\n    For a single rotation, this class is faster to use than the Rotation class\n    as it is signficantly simpler to instantiate. However, if a rotation needs\n    to be performed repeatedly, the Rotation class may be faster.\n\n    !!! note \"Numba JIT Compiled\"\n        This function is compiled using Numba. Use care when providing inputs\n        as Numba is strictly typed. The inputs to this function are an int, a\n        float, and a float array.\n\n    Parameters\n    ----------\n    rotation_axis : int\n        The axis of rotation. Must be 1, 2, or 3 (corresponding to x,y, and x)\n    angle : float\n        The angle of rotation in radians\n    vector : np.ndarray\n        The vector to rotate\n\n    Returns\n    -------\n    np.ndarray\n        The vector rotated to the new frame\n\n    \"\"\"\n    _c = np.cos(angle)\n    _s = np.sin(angle)\n\n    assert rotation_axis in [1, 2, 3], \"rotation_axis must be 1, 2, or 3\"\n    if rotation_axis == 1:\n        dcm = np.array([[1.0, 0.0, 0.0], [0.0, _c, _s], [0.0, -_s, _c]])\n    elif rotation_axis == 2:\n        dcm = np.array([[_c, 0.0, -_s], [0.0, 1.0, 0.0], [_s, 0.0, _c]])\n    elif rotation_axis == 3:\n        dcm = np.array([[_c, _s, 0.0], [-_s, _c, 0.0], [0.0, 0.0, 1.0]])\n\n    return dcm @ vector\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.standard_rotation_matrix","title":"<code>standard_rotation_matrix(rotation_axis, angle)</code>","text":"<p>Get a standard rotation matrix.</p> <p>This function is used to compute the rotation matrix (direction cosine matrix) for a rotation about one of the principle axes.</p> <p>That is, if the angle of rotation is \\(\\theta\\), the returned rotation matrix is</p> \\[ \\begin{split}     R_{1}(\\theta) = &amp;         \\left[\\begin{array}{ccc}             1 &amp; 0 &amp; 0 \\\\             0 &amp; \\cos\\theta &amp; \\sin\\theta \\\\             0 &amp; -\\sin\\theta &amp; \\cos\\theta         \\end{array}\\right] \\\\     R_{2}(\\theta) = &amp;         \\left[\\begin{array}{ccc}             \\cos\\theta &amp; 0 &amp; -\\sin\\theta \\\\             0 &amp; 1 &amp; 0 \\\\             \\sin\\theta &amp; 0 &amp; \\cos\\theta         \\end{array}\\right] \\\\     R_{3}(\\theta) = &amp;         \\left[\\begin{array}{ccc}             \\cos\\theta &amp; \\sin\\theta &amp; 0 \\\\             -\\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\             0 &amp; 0 &amp; 1         \\end{array}\\right] \\end{split} \\] <p>respectively for rotations about the 1, 2, or 3 axis.</p> <p>To simply the actual code, this is actually accomplished by expressing the rotation as a rotation about an Euler axis and simply converting to a direction cosine matrix using euler_axis_angle2direction_cosion_matrix().</p> <p>Numba JIT Compiled</p> <p>This function is compiled using Numba. Use care when providing inputs as Numba is strictly typed. The inputs to this function are an int and a float.</p> <p>Parameters:</p> Name Type Description Default <code>rotation_axis</code> <code>int</code> <p>The axis of rotation</p> required <code>angle</code> <code>float</code> <p>The angle of rotation in radians</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The rotation matrix (DCM) for the axis and angle of rotation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the rotation axis is not 1, 2, or 3</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>@jit(\"float64[:,:](int8, float64)\", nopython=True, cache=True)\ndef standard_rotation_matrix(rotation_axis: int, angle: float) -&gt; np.ndarray:\n    r\"\"\"Get a standard rotation matrix.\n\n    This function is used to compute the rotation matrix (direction cosine\n    matrix) for a rotation about one of the principle axes.\n\n    That is, if the angle of rotation is \\(\\theta\\), the returned rotation\n    matrix is\n\n    $$\n    \\begin{split}\n        R_{1}(\\theta) = &amp;\n            \\left[\\begin{array}{ccc}\n                1 &amp; 0 &amp; 0 \\\\\n                0 &amp; \\cos\\theta &amp; \\sin\\theta \\\\\n                0 &amp; -\\sin\\theta &amp; \\cos\\theta\n            \\end{array}\\right] \\\\\n        R_{2}(\\theta) = &amp;\n            \\left[\\begin{array}{ccc}\n                \\cos\\theta &amp; 0 &amp; -\\sin\\theta \\\\\n                0 &amp; 1 &amp; 0 \\\\\n                \\sin\\theta &amp; 0 &amp; \\cos\\theta\n            \\end{array}\\right] \\\\\n        R_{3}(\\theta) = &amp;\n            \\left[\\begin{array}{ccc}\n                \\cos\\theta &amp; \\sin\\theta &amp; 0 \\\\\n                -\\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\\n                0 &amp; 0 &amp; 1\n            \\end{array}\\right]\n    \\end{split}\n    $$\n\n    respectively for rotations about the 1, 2, or 3 axis.\n\n    To simply the actual code, this is actually accomplished by expressing the\n    rotation as a rotation about an Euler axis and simply converting to a\n    direction cosine matrix using euler_axis_angle2direction_cosion_matrix().\n\n    !!! note \"Numba JIT Compiled\"\n        This function is compiled using Numba. Use care when providing inputs\n        as Numba is strictly typed. The inputs to this function are an int and\n        a float.\n\n    Parameters\n    ----------\n    rotation_axis : int\n        The axis of rotation\n    angle : float\n        The angle of rotation in radians\n\n    Returns\n    -------\n    np.ndarray\n        The rotation matrix (DCM) for the axis and angle of rotation\n\n    Raises\n    ------\n    ValueError\n        If the rotation axis is not 1, 2, or 3\n\n    \"\"\"\n\n    assert rotation_axis in [1, 2, 3], \"rotation_axis must be 1, 2, or 3\"\n    euler_axis = np.zeros(3)\n    euler_axis[rotation_axis - 1] = 1.0\n\n    return euler_axis_angle2direction_cosine_matrix(euler_axis, angle)\n</code></pre>"},{"location":"reference/gps_frames/rotations/#gps_frames.rotations.standard_rotation_matrix_rates","title":"<code>standard_rotation_matrix_rates(rotation_axis, angle, rate)</code>","text":"<p>Get the derivated of a standard rotation matrix.</p> <p>This function is used to compute the derivative of a rotation matrix (direction cosine matrix) for a rotation about one of the principle axes.</p> <p>That is, if the angle of rotation is \\(\\theta\\), the returned matrix is [ \\begin{split}     R_{1}(\\theta) = &amp;         \\left[\\begin{array}{ccc}             0 &amp; 0 &amp; 0 \\             0 &amp;             -\\dot{\\theta}\\sin\\theta &amp;             \\dot{\\theta}\\cos\\theta \\             0 &amp;             -\\dot{\\theta}\\cos\\theta &amp;             -\\dot{\\theta}\\sin\\theta         \\end{array}\\right] \\     R_{2}(\\theta) = &amp;         \\left[\\begin{array}{ccc}             -\\dot{\\theta}\\sin\\theta &amp;             0 &amp;             -\\dot{\\theta}\\cos\\theta\\             0 &amp;             0 &amp;             0 \\             \\dot{\\theta}\\cos\\theta &amp;             0 &amp;             -\\dot{\\theta}\\sin\\theta         \\end{array}\\right] \\     R_{3}(\\theta) = &amp;         \\left[\\begin{array}{ccc}             -\\dot{\\theta}\\sin\\theta             &amp; \\dot{\\theta}\\cos\\theta &amp;             0 \\             -\\dot{\\theta}\\cos\\theta &amp;             -\\dot{\\theta}\\sin\\theta &amp;             0 \\             0 &amp; 0 &amp; 0         \\end{array}\\right] \\end{split} ] respectively for rotations about the 1, 2, or 3 axis.</p> <p>Numba JIT Compiled</p> <p>This function is compiled using Numba. Use care when providing inputs as Numba is strictly typed. The inputs to this function are an int and two floats.</p> <p>Parameters:</p> Name Type Description Default <code>rotation_axis</code> <code>int</code> <p>The axis of rotation</p> required <code>angle</code> <code>float</code> <p>The angle of rotation in radians</p> required <code>rate</code> <code>float</code> <p>The angular rotation rate in radians per second</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The rate of change of the rotation matrix (DCM) for the axis, angle, and rate of rotation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the rotation axis is not 1, 2, or 3</p> Source code in <code>gps_frames/rotations.py</code> <pre><code>@jit(\"float64[:,:](int8, float64, float64)\", nopython=True, cache=True)\ndef standard_rotation_matrix_rates(\n    rotation_axis: int, angle: float, rate: float\n) -&gt; np.ndarray:\n    r\"\"\"Get the derivated of a standard rotation matrix.\n\n    This function is used to compute the derivative of a rotation matrix\n    (direction cosine matrix) for a rotation about one of the principle axes.\n\n    That is, if the angle of rotation is \\(\\theta\\), the returned matrix is\n    \\[\n    \\begin{split}\n        R_{1}(\\theta) = &amp;\n            \\left[\\begin{array}{ccc}\n                0 &amp; 0 &amp; 0 \\\\\n                0 &amp;\n                -\\dot{\\theta}\\sin\\theta &amp;\n                \\dot{\\theta}\\cos\\theta \\\\\n                0 &amp;\n                -\\dot{\\theta}\\cos\\theta &amp;\n                -\\dot{\\theta}\\sin\\theta\n            \\end{array}\\right] \\\\\n        R_{2}(\\theta) = &amp;\n            \\left[\\begin{array}{ccc}\n                -\\dot{\\theta}\\sin\\theta &amp;\n                0 &amp;\n                -\\dot{\\theta}\\cos\\theta\\\\\n                0 &amp;\n                0 &amp;\n                0 \\\\\n                \\dot{\\theta}\\cos\\theta &amp;\n                0 &amp;\n                -\\dot{\\theta}\\sin\\theta\n            \\end{array}\\right] \\\\\n        R_{3}(\\theta) = &amp;\n            \\left[\\begin{array}{ccc}\n                -\\dot{\\theta}\\sin\\theta\n                &amp; \\dot{\\theta}\\cos\\theta &amp;\n                0 \\\\\n                -\\dot{\\theta}\\cos\\theta &amp;\n                -\\dot{\\theta}\\sin\\theta &amp;\n                0 \\\\\n                0 &amp; 0 &amp; 0\n            \\end{array}\\right]\n    \\end{split}\n    \\]\n    respectively for rotations about the 1, 2, or 3 axis.\n\n    !!! note \"Numba JIT Compiled\"\n        This function is compiled using Numba. Use care when providing inputs\n        as Numba is strictly typed. The inputs to this function are an int and\n        two floats.\n\n    Parameters\n    ----------\n    rotation_axis : int\n        The axis of rotation\n    angle : float\n        The angle of rotation in radians\n    rate : float\n        The angular rotation rate in radians per second\n\n    Returns\n    -------\n    np.ndarray\n        The rate of change of the rotation matrix (DCM) for the axis, angle,\n        and rate of rotation\n\n    Raises\n    ------\n    ValueError\n        If the rotation axis is not 1, 2, or 3\n\n    \"\"\"\n    c = np.cos(angle)\n    s = np.sin(angle)\n\n    if rotation_axis == 1:\n        return np.array(\n            [[0.0, 0.0, 0.0], [0.0, -s * rate, c * rate], [0.0, -c * rate, -s * rate]]\n        )\n    elif rotation_axis == 2:\n        return np.array(\n            [[-s * rate, 0.0, -c * rate], [0.0, 0.0, 0.0], [c * rate, 0.0, -s * rate]]\n        )\n    elif rotation_axis == 3:\n        return np.array(\n            [[-s * rate, c * rate, 0.0], [-c * rate, -s * rate, 0.0], [0.0, 0.0, 0.0]]\n        )\n    else:\n        raise ValueError(\"rotation_axis must be 1, 2, or 3\")\n</code></pre>"},{"location":"reference/gps_frames/transforms/","title":"Transforms","text":""},{"location":"reference/gps_frames/transforms/#gps_frames.transforms","title":"<code>gps_frames.transforms</code>","text":"<p>Frame Transformations.</p> <p>This submodule contains the mathematics used for translating between different frames.</p> Todo <ul> <li>Incorporate non-GPS standard frames, e.g. J2000</li> <li>Include velocity transformations into the LLA frame</li> <li>Add local coordinate systems, e.g. ENU</li> <li>Make GPSTime JIT-able</li> <li>Fix ECEF to LLA warning (currently a print for numba compatibility)</li> </ul>"},{"location":"reference/gps_frames/transforms/#gps_frames.transforms.VALID_FRAMES","title":"<code>VALID_FRAMES = ['ECI', 'ECEF', 'LLA']</code>  <code>module-attribute</code>","text":"<p>The frames implemented for this toolbox</p> <p>This list contains the names of the frames available in this module. These frames are</p> <ul> <li>ECI: The ECI frame aligned with the ECEF frame at the start of the week.     When used, the coordinates refer to the X, Y, and Z positions in the     frame in meters</li> <li>ECEF: The ECEF frame. When used, the coordinates refer to the X, Y, and     Z positions in the frame in meters</li> <li>LLA: The WGS84 Latitude, Longitude, and Altitude. When used, the     coordinates refer to the Latitude, Longitude, and Altitude in radians or     meters as appropriate</li> </ul> Notes <p>For consistency, all names must be in all caps.</p>"},{"location":"reference/gps_frames/transforms/#gps_frames.transforms.add_weeks_eci","title":"<code>add_weeks_eci(num_weeks, coordinates)</code>","text":"<p>Move ECI frame to new week.</p> <p>Because the ECI frame is reference to the start of the week, if the frame is moved to a new week, the coordinates change. The purpose of this function is to update the ECI frame by moving forward <code>num_weeks</code> weeks (or backward is <code>num_weeks</code> is negative.</p> <p>This is accomplished by rotating the frame about the 3 axis by an angle of \\(\\omega_{\\oplus}T\\) where \\(\\omega_{\\oplus}\\) is the angular velocity of the Earth and \\(T\\) is the length of a week times the number of weeks to advance.</p> <p>Parameters:</p> Name Type Description Default <code>num_weeks</code> <code>int</code> <p>The number of weeks to advance the ECI frame</p> required <code>coordinates</code> <code>ndarray</code> <p>The coordinates in the initial ECI frame</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The coordinates in the new ECI frame</p> See Also <p>standard_rotation_matrix: Used to get the rotation matrix for the     transformation</p> Source code in <code>gps_frames/transforms.py</code> <pre><code>@jit(\"float64[:](int64, float64[:])\", nopython=True)\ndef add_weeks_eci(num_weeks: int, coordinates: np.ndarray) -&gt; np.ndarray:\n    r\"\"\"Move ECI frame to new week.\n\n    Because the ECI frame is reference to the start of the week, if the frame\n    is moved to a new week, the coordinates change. The purpose of this\n    function is to update the ECI frame by moving forward `num_weeks` weeks\n    (or backward is `num_weeks` is negative.\n\n    This is accomplished by rotating the frame about the 3 axis by an angle of\n    \\(\\omega_{\\oplus}T\\) where \\(\\omega_{\\oplus}\\) is the angular velocity\n    of the Earth and \\(T\\) is the length of a week times the number of weeks\n    to advance.\n\n    Parameters\n    ----------\n    num_weeks : int\n        The number of weeks to advance the ECI frame\n    coordinates : np.ndarray\n        The coordinates in the initial ECI frame\n\n    Returns\n    -------\n    np.ndarray\n        The coordinates in the new ECI frame\n\n    See Also\n    --------\n    standard_rotation_matrix: Used to get the rotation matrix for the\n        transformation\n\n    \"\"\"\n    if num_weeks == 0:\n        return coordinates\n    else:\n        # How far the Earth rotates in a week\n        # coordinates = np.array(coordinates, dtype=float)\n        weekly_eci_rotation = _w_e * 604800 * num_weeks\n\n        # rotation = Rotation(\n        #     dcm=standard_rotation_matrix(3, weekly_eci_rotation))\n\n        return standard_rotation(3, weekly_eci_rotation, coordinates)\n</code></pre>"},{"location":"reference/gps_frames/transforms/#gps_frames.transforms.ecef2eci","title":"<code>ecef2eci(ecef_coordinates, time_of_week)</code>","text":"<p>Rotate from the ECEF to the ECI frame.</p> <p>This function rotates the ECEF coordinates into the ECI frame. Note that the ECI and ECEF frames are aligned at the start of the week.</p> <p>Let \\(\\mathbf{r}^{\\mathcal{F}}\\) be the position in the ECEF frame and \\(t\\) be the time of week. The angle of rotation between the ECI and ECEF frames is \\(\\Theta = \\omega_{\\oplus}t\\), with \\(\\omega_{\\oplus}\\) being the angular velocity of the Earth. Thus, the position in the ECI coordinates is</p> \\[     \\mathbf{r}^{\\mathcal{N}} =         \\left[\\begin{array}{ccc}             \\cos -\\Theta &amp; \\sin -\\Theta &amp; 0 \\\\             -\\sin -\\Theta &amp; \\cos -\\Theta &amp; 0 \\\\             0 &amp; 0 &amp; 1         \\end{array}\\right]\\mathbf{r}^{\\mathcal{F}}     =         \\left[\\begin{array}{ccc}             \\cos \\Theta &amp; -\\sin \\Theta &amp; 0 \\\\             \\sin \\Theta &amp; \\cos \\Theta &amp; 0 \\\\             0 &amp; 0 &amp; 1         \\end{array}\\right]\\mathbf{r}^{\\mathcal{F}} \\] <p>Parameters:</p> Name Type Description Default <code>ecef_coordinates</code> <code>ndarray</code> <p>The coordinates in the ECEF frame</p> required <code>time_of_week</code> <code>float</code> <p>The time of week in seconds associated with the ECEF frame</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The coordinates in the ECI frame</p> See Also <p>standard_rotation_matrix: Used to get the rotation matrix for the     transformation</p> Source code in <code>gps_frames/transforms.py</code> <pre><code>@jit(\"float64[:](float64[:], float64)\", nopython=True)\ndef ecef2eci(ecef_coordinates: np.ndarray, time_of_week: float) -&gt; np.ndarray:\n    r\"\"\"Rotate from the ECEF to the ECI frame.\n\n    This function rotates the ECEF coordinates into the ECI frame. Note that\n    the ECI and ECEF frames are aligned at the start of the week.\n\n    Let \\(\\mathbf{r}^{\\mathcal{F}}\\) be the position in the ECEF frame\n    and \\(t\\) be the time of week. The angle of rotation between the ECI and\n    ECEF frames is \\(\\Theta = \\omega_{\\oplus}t\\), with \\(\\omega_{\\oplus}\\)\n    being the angular velocity of the Earth. Thus, the position in the ECI\n    coordinates is\n\n    $$\n        \\mathbf{r}^{\\mathcal{N}} =\n            \\left[\\begin{array}{ccc}\n                \\cos -\\Theta &amp; \\sin -\\Theta &amp; 0 \\\\\n                -\\sin -\\Theta &amp; \\cos -\\Theta &amp; 0 \\\\\n                0 &amp; 0 &amp; 1\n            \\end{array}\\right]\\mathbf{r}^{\\mathcal{F}}\n        =\n            \\left[\\begin{array}{ccc}\n                \\cos \\Theta &amp; -\\sin \\Theta &amp; 0 \\\\\n                \\sin \\Theta &amp; \\cos \\Theta &amp; 0 \\\\\n                0 &amp; 0 &amp; 1\n            \\end{array}\\right]\\mathbf{r}^{\\mathcal{F}}\n    $$\n\n    Parameters\n    ----------\n    ecef_coordinates : np.ndarray\n        The coordinates in the ECEF frame\n    time_of_week : float\n        The time of week in seconds associated with the ECEF frame\n\n    Returns\n    -------\n    np.ndarray\n        The coordinates in the ECI frame\n\n    See Also\n    --------\n    standard_rotation_matrix: Used to get the rotation matrix for the\n        transformation\n\n    \"\"\"\n\n    # Angle from the ECI to the ECEF frame\n    angle_of_rotation = _w_e * time_of_week\n    # rotation = Rotation(axis=np.array((0., 0., 1.)), angle=-angle_of_rotation)\n\n    return standard_rotation(3, -angle_of_rotation, ecef_coordinates)\n</code></pre>"},{"location":"reference/gps_frames/transforms/#gps_frames.transforms.ecef2lla","title":"<code>ecef2lla(ecef_coordinates)</code>","text":"<p>Transform an ECEF position to LLA position.</p> <p>The purpose of this function is to convert a position in the ECEF frame to the LLA frame relative to the WGS84 ellipsoid. Let the coordinates in the ECEF frame be \\(\\mathbf{r}^{\\mathcal{F}} = [r_{x}, r_{y}, r_{z}]^{T}\\). The longitude is calculated as</p> \\[     \\phi = \\arctan\\left(\\frac{p_{y}}{p_{x}}\\right) \\] <p>Note that a 4-quadrant arctangent function should be used to avoid ambiguity.</p> <p>The latitude cannot be solved analytically and must be solved numerically. The initial guesses for the geodetic latitude \\(\\lambda\\) and reduced latitude \\(\\beta\\) are</p> \\[     \\begin{split}         \\beta = &amp; \\arctan\\left(\\frac{p_{z}}{(1-f)s}\\right) \\\\         \\lambda = &amp; \\arctan\\left(                 \\frac{                     p_{z} + \\frac{e^{2}(1-f)}{1-e^{2}}a\\sin^{3}\\beta                 }{                     s - e^{2}a\\cos^{3}\\beta                 }             \\right)     \\end{split} \\] <p>where \\(a\\) is the semi-major axis of the WGS84 ellipsoid, \\(f\\) is the flattening of the ellipsoid, \\(e^{2}=1-(1-f)^{2}\\), and \\(s = \\sqrt{p_{x}^{2} + p_{y}^{2}}\\).</p> <p>Using the initial guesses, an update to the reduced latitude can be calculated as</p> \\[     \\beta = \\arctan\\left(             \\frac{(1 - f)\\sin\\lambda}{\\cos\\lambda}         \\right) \\] <p>which can in turn be used to update \\(\\lambda\\). This cycle continues until \\(\\lambda\\) converges ([1]_ claims this usually takes 2-3 iterations).</p> <p>From here, it is possible to compute the altitude directly:</p> \\[     h = s \\cos\\lambda + (p_{z} + e^{2}n\\sin\\lambda)\\sin\\lambda - n \\] <p>where \\(n\\) is the radius of curvature in the vertical prime</p> \\[     n = \\frac{a}{\\sqrt{1 - (e\\sin\\lambda)^{2}}} \\] <p>This function is based on the development provided by [1]_</p> <p>Todo</p> <p>If the latitude does not converge, this function prints a warning  instead of using the logger. This is necessary because of use of Numba. In the future, this should be changed to logging a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>ecef_coordinates</code> <code>ndarray</code> <p>The coordinates in the ECEF frame</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The latitude, longitude, altitude coordinates.</p> References <p>.. [1] MathWorks Aerospace Blockset     https://www.mathworks.com/help/aeroblks/ecefpositiontolla.html</p> Source code in <code>gps_frames/transforms.py</code> <pre><code>@jit(\"float64[:](float64[:])\", nopython=True)\ndef ecef2lla(ecef_coordinates: np.ndarray) -&gt; np.ndarray:\n    r\"\"\"Transform an ECEF position to LLA position.\n\n    The purpose of this function is to convert a position in the ECEF frame to\n    the LLA frame relative to the WGS84 ellipsoid. Let the coordinates in the\n    ECEF frame be\n    \\(\\mathbf{r}^{\\mathcal{F}} = [r_{x}, r_{y}, r_{z}]^{T}\\). The\n    longitude is calculated as\n\n    $$\n        \\phi = \\arctan\\left(\\frac{p_{y}}{p_{x}}\\right)\n    $$\n\n    Note that a 4-quadrant arctangent function should be used to avoid\n    ambiguity.\n\n    The latitude cannot be solved analytically and must be solved numerically.\n    The initial guesses for the geodetic latitude \\(\\lambda\\) and reduced\n    latitude \\(\\beta\\) are\n\n    $$\n        \\begin{split}\n            \\beta = &amp; \\arctan\\left(\\frac{p_{z}}{(1-f)s}\\right) \\\\\n            \\lambda = &amp; \\arctan\\left(\n                    \\frac{\n                        p_{z} + \\frac{e^{2}(1-f)}{1-e^{2}}a\\sin^{3}\\beta\n                    }{\n                        s - e^{2}a\\cos^{3}\\beta\n                    }\n                \\right)\n        \\end{split}\n    $$\n\n    where \\(a\\) is the semi-major axis of the WGS84 ellipsoid, \\(f\\) is the\n    flattening of the ellipsoid, \\(e^{2}=1-(1-f)^{2}\\), and\n    \\(s = \\sqrt{p_{x}^{2} + p_{y}^{2}}\\).\n\n    Using the initial guesses, an update to the reduced latitude can be\n    calculated as\n\n    $$\n        \\beta = \\arctan\\left(\n                \\frac{(1 - f)\\sin\\lambda}{\\cos\\lambda}\n            \\right)\n    $$\n\n    which can in turn be used to update \\(\\lambda\\). This cycle continues\n    until \\(\\lambda\\) converges ([1]_ claims this usually takes 2-3\n    iterations).\n\n    From here, it is possible to compute the altitude directly:\n\n    $$\n        h = s \\cos\\lambda + (p_{z} + e^{2}n\\sin\\lambda)\\sin\\lambda - n\n    $$\n\n    where \\(n\\) is the radius of curvature in the vertical prime\n\n    $$\n        n = \\frac{a}{\\sqrt{1 - (e\\sin\\lambda)^{2}}}\n    $$\n\n    This function is based on the development provided by [1]_\n\n    !!! quote \"Todo\"\n        If the latitude does not converge, this function prints a warning \n        instead of using the logger. This is necessary because of use of\n        Numba. In the future, this should be changed to logging a warning\n        message.\n\n    Parameters\n    ----------\n    ecef_coordinates : np.ndarray\n        The coordinates in the ECEF frame\n\n    Returns\n    -------\n    np.ndarray\n        The latitude, longitude, altitude coordinates.\n\n    References\n    ----------\n    .. [1] MathWorks Aerospace Blockset\n        https://www.mathworks.com/help/aeroblks/ecefpositiontolla.html\n\n    \"\"\"\n    x = ecef_coordinates[0]\n    y = ecef_coordinates[1]\n    z = ecef_coordinates[2]\n\n    longitude = np.arctan2(y, x)\n\n    max_iterations = 5\n    desired_accuracy = 1e-15\n\n    s = np.sqrt(x ** 2 + y ** 2)\n\n    beta = np.arctan2(z, (1 - _wgs84f) * s)\n    latitude = _ecef2lla_latitude_func(s, z, beta)\n\n    for ii in range(max_iterations):\n        old_latitude = latitude\n\n        beta = _ecef2lla_beta_func(latitude)\n        latitude = _ecef2lla_latitude_func(s, z, beta)\n\n        if np.abs(latitude - old_latitude) &lt;= desired_accuracy:\n            break\n\n    else:\n        print(\n            \"ecef2lla &gt;&gt; WARNING: latitude did not converge: \",\n            latitude - old_latitude,\n        )\n\n    # logger.debug(f\"ecef2lla took {ii} iterations to converge.\")\n\n    n = _wgs84a / np.sqrt(1 - _wgs84ecc ** 2 * np.sin(latitude) ** 2)\n\n    altitude = (\n        s * np.cos(latitude)\n        + (z + _wgs84ecc ** 2 * n * np.sin(latitude)) * np.sin(latitude)\n        - n\n    )\n\n    return np.array((latitude, longitude, altitude))\n</code></pre>"},{"location":"reference/gps_frames/transforms/#gps_frames.transforms.eci2ecef","title":"<code>eci2ecef(eci_coordinates, time_of_week)</code>","text":"<p>Rotate from the ECI to the ECEF frame.</p> <p>This function rotates the ECI coordinates into the ECEF frame. Note that the ECI and ECEF frames are aligned at the start of the week.</p> <p>Let \\(\\mathbf{r}^{\\mathcal{N}}\\) be the position in the ECI frame and \\(t\\) be the time of week. The angle of rotation between the ECI and ECEF frames is \\(\\Theta = \\omega_{\\oplus}t\\), with \\(\\omega_{\\oplus}\\) being the angular velocity of the Earth. Thus, the position in the ECEF coordinates is</p> \\[     \\mathbf{r}^{\\mathcal{F}} =         \\left[\\begin{array}{ccc}             \\cos \\Theta &amp; \\sin \\Theta &amp; 0 \\\\             -\\sin \\Theta &amp; \\cos \\Theta &amp; 0 \\\\             0 &amp; 0 &amp; 1         \\end{array}\\right]\\mathbf{r}^{\\mathcal{N}} \\] <p>Parameters:</p> Name Type Description Default <code>eci_coordinates</code> <code>ndarray</code> <p>The coordinates in the ECI frame</p> required <code>time_of_week</code> <code>float</code> <p>The time of week in seconds associated with the ECEF frame</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The coordinates in the ECI frame</p> See Also <p>standard_rotation_matrix: Used to get the rotation matrix for the     transformation</p> Source code in <code>gps_frames/transforms.py</code> <pre><code>@jit(\"float64[:](float64[:], float64)\", nopython=True)\ndef eci2ecef(eci_coordinates: np.ndarray, time_of_week: float) -&gt; np.ndarray:\n    r\"\"\"Rotate from the ECI to the ECEF frame.\n\n    This function rotates the ECI coordinates into the ECEF frame. Note that\n    the ECI and ECEF frames are aligned at the start of the week.\n\n    Let \\(\\mathbf{r}^{\\mathcal{N}}\\) be the position in the ECI frame\n    and \\(t\\) be the time of week. The angle of rotation between the ECI and\n    ECEF frames is \\(\\Theta = \\omega_{\\oplus}t\\), with \\(\\omega_{\\oplus}\\)\n    being the angular velocity of the Earth. Thus, the position in the ECEF\n    coordinates is\n\n    $$\n        \\mathbf{r}^{\\mathcal{F}} =\n            \\left[\\begin{array}{ccc}\n                \\cos \\Theta &amp; \\sin \\Theta &amp; 0 \\\\\n                -\\sin \\Theta &amp; \\cos \\Theta &amp; 0 \\\\\n                0 &amp; 0 &amp; 1\n            \\end{array}\\right]\\mathbf{r}^{\\mathcal{N}}\n    $$\n\n    Parameters\n    ----------\n    eci_coordinates : np.ndarray\n        The coordinates in the ECI frame\n    time_of_week : float\n        The time of week in seconds associated with the ECEF frame\n\n    Returns\n    -------\n    np.ndarray\n        The coordinates in the ECI frame\n\n    See Also\n    --------\n    standard_rotation_matrix: Used to get the rotation matrix for the\n        transformation\n\n    \"\"\"\n    # Angle from the ECI to the ECEF frame\n    angle_of_rotation = _w_e * time_of_week\n    # rotation = Rotation(axis=np.array((0., 0., 1.)), angle=angle_of_rotation)\n\n    return standard_rotation(3, angle_of_rotation, eci_coordinates)\n</code></pre>"},{"location":"reference/gps_frames/transforms/#gps_frames.transforms.eci2lla","title":"<code>eci2lla(eci_coordinates, time)</code>","text":"<p>Transform the ECI coordinates into an LLA position.</p> <p>The purpose of this function is to transform ECI coordinates into LLA coordinates. It does to by calling <code>eci2ecef()</code> and <code>ecef2lla()</code></p> <p>Parameters:</p> Name Type Description Default <code>eci_coordinates</code> <code>ndarray</code> <p>The ECI coordinates</p> required <code>time</code> <code>GPSTime</code> <p>The time for which to get the LLA</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The Latitude, Longitude, Altitude coordinates (WGS84)</p> See Also <p>eci2ecef: Convert coordinates (and time) to ECEF frame ecef2lla: Convert ECEF coordinates to LLA position</p> Source code in <code>gps_frames/transforms.py</code> <pre><code>@jit(\"float64[:](float64[:], float64)\", nopython=True)\ndef eci2lla(eci_coordinates: np.ndarray, time: GPSTime) -&gt; np.ndarray:\n    \"\"\"Transform the ECI coordinates into an LLA position.\n\n    The purpose of this function is to transform ECI coordinates into LLA\n    coordinates. It does to by calling `eci2ecef()` and `ecef2lla()`\n\n    Parameters\n    ----------\n    eci_coordinates : np.ndarray\n        The ECI coordinates\n    time : GPSTime\n        The time for which to get the LLA\n\n    Returns\n    -------\n    np.ndarray\n        The Latitude, Longitude, Altitude coordinates (WGS84)\n\n    See Also\n    --------\n    eci2ecef: Convert coordinates (and time) to ECEF frame\n    ecef2lla: Convert ECEF coordinates to LLA position\n\n    \"\"\"\n    return ecef2lla(eci2ecef(eci_coordinates, time))\n</code></pre>"},{"location":"reference/gps_frames/transforms/#gps_frames.transforms.lla2ecef","title":"<code>lla2ecef(lla_coordinates)</code>","text":"<p>Convert LLA to ECEF position.</p> <p>Computes the ECEF position based on the WGS84 ellipsoid latitude, longitude, and altitude. The inputs is are numpy arrays. Returns a numpy array with columns representing the ECEF positions of the elements of the inputs. From [1]_</p> <p>Let \\(\\lambda\\), \\(\\phi\\), \\(h\\), \\(a\\), and \\(e\\) be the latitude, longitude, altitude, WGS84 semi-major axis, and WGS84 eccentricity, repsectively. The effective radius of the Earth is</p> \\[     n = \\frac{a}{\\sqrt{1 - (e\\sin\\lambda)^{2}}} \\] <p>From this, the ECEF \\(x\\), \\(y\\), and \\(z\\) positions can be computed as</p> \\[     \\begin{split}         x = &amp; (n + h)\\cos\\lambda\\cos\\phi \\\\         y = &amp; (n + h)\\cos\\lambda\\sin\\phi \\\\         z = &amp; \\left(n\\left(1 - e^{2}\\right) + h\\right) \\sin\\lambda     \\end{split} \\] <p>Parameters:</p> Name Type Description Default <code>lla_coordinates</code> <code>ndarray</code> <p>The WGS 84 latitude, longitude, and altitude (in that order)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The ECEF position of the given WGS84 LLA</p> References <p>.. [1] G. Xu and Y. Xu, \"GPS: Theory, Algorithms and Applications\" 3rd ed.     https://doi.org/10.1007/978-3-662-50367-6</p> Source code in <code>gps_frames/transforms.py</code> <pre><code>@jit(\"float64[:](float64[:])\", nopython=True)\ndef lla2ecef(lla_coordinates: np.array) -&gt; np.array:\n    r\"\"\"Convert LLA to ECEF position.\n\n    Computes the ECEF position based on the WGS84 ellipsoid latitude,\n    longitude, and altitude. The inputs is are numpy arrays. Returns a\n    numpy array with columns representing the ECEF positions of the\n    elements of the inputs. From [1]_\n\n    Let \\(\\lambda\\), \\(\\phi\\), \\(h\\), \\(a\\), and \\(e\\) be the latitude,\n    longitude, altitude, WGS84 semi-major axis, and WGS84 eccentricity,\n    repsectively. The effective radius of the Earth is\n\n    $$\n        n = \\frac{a}{\\sqrt{1 - (e\\sin\\lambda)^{2}}}\n    $$\n\n    From this, the ECEF \\(x\\), \\(y\\), and \\(z\\) positions can be computed as\n\n    $$\n        \\begin{split}\n            x = &amp; (n + h)\\cos\\lambda\\cos\\phi \\\\\n            y = &amp; (n + h)\\cos\\lambda\\sin\\phi \\\\\n            z = &amp; \\left(n\\left(1 - e^{2}\\right) + h\\right) \\sin\\lambda\n        \\end{split}\n    $$\n\n    Parameters\n    ----------\n    lla_coordinates : np.ndarray\n        The WGS 84 latitude, longitude, and altitude (in that order)\n\n    Returns\n    -------\n    np.ndarray\n        The ECEF position of the given WGS84 LLA\n\n    References\n    ----------\n    .. [1] G. Xu and Y. Xu, \"GPS: Theory, Algorithms and Applications\" 3rd ed.\n        https://doi.org/10.1007/978-3-662-50367-6\n\n    \"\"\"\n    latitude = lla_coordinates[0]\n    longitude = lla_coordinates[1]\n    altitude = lla_coordinates[2]\n\n    n = _wgs84a / np.sqrt(1 - (_wgs84ecc * np.sin(latitude)) ** 2)\n\n    x = (n + altitude) * np.cos(latitude) * np.cos(longitude)\n    y = (n + altitude) * np.cos(latitude) * np.sin(longitude)\n    z = (n * (1 - _wgs84ecc ** 2) + altitude) * np.sin(latitude)\n\n    return np.array((x, y, z))\n</code></pre>"},{"location":"reference/gps_frames/transforms/#gps_frames.transforms.lla2eci","title":"<code>lla2eci(lla_coordinates, time)</code>","text":"<p>Tranform LLA coordinates into ECI.</p> <p>This function is used to transform an LLA position into ECI coordinates. To do this, the coordinates are first converted to ECEF coordinates using <code>lla2ecef()</code>. Then, these new ECEF coordinates are transformed into ECI coordinates using <code>ecef2eci()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>lla_coordinates</code> <code>ndarray</code> <p>The Latitude, Longitude, Altitude position coordinates</p> required <code>time</code> <code>GPSTime</code> <p>The time at which the <code>lla_coordinates</code> are defined</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The position in the ECI frame</p> See Also <p>lla2ecef: Convert LLA coordinates to ECEF coordinates ecef2eci: Convert ECEF coordinates into ECI coordinates</p> Source code in <code>gps_frames/transforms.py</code> <pre><code>@jit(\"float64[:](float64[:], float64)\", nopython=True)\ndef lla2eci(lla_coordinates: np.ndarray, time: float) -&gt; np.ndarray:\n    \"\"\"Tranform LLA coordinates into ECI.\n\n    This function is used to transform an LLA position into ECI coordinates.\n    To do this, the coordinates are first converted to ECEF coordinates using\n    `lla2ecef()`. Then, these new ECEF coordinates are transformed into ECI\n    coordinates using `ecef2eci()`.\n\n    Parameters\n    ----------\n    lla_coordinates : np.ndarray\n        The Latitude, Longitude, Altitude position coordinates\n    time : GPSTime\n        The time at which the `lla_coordinates` are defined\n\n    Returns\n    -------\n    np.ndarray\n        The position in the ECI frame\n\n    See Also\n    --------\n    lla2ecef: Convert LLA coordinates to ECEF coordinates\n    ecef2eci: Convert ECEF coordinates into ECI coordinates\n\n    \"\"\"\n    return ecef2eci(lla2ecef(lla_coordinates), time)\n</code></pre>"},{"location":"reference/gps_frames/transforms/#gps_frames.transforms.position_transform","title":"<code>position_transform(from_frame, to_frame, coordinates, time)</code>","text":"<p>Convert a position from one frame to another.</p> <p>The purpose of this function is to create a general tool to convert a position from one frame to another. The current frame is given as the <code>from_frame</code> and the desired new output frame is given as the <code>to_frame</code>. The position is defined in the <code>from_frame</code> as the <code>coordinates</code>. The <code>time</code> is used to define the time of the frame, as some conversions between frames vary with time, e.g. ECEF to ECI.</p> <p>Parameters:</p> Name Type Description Default <code>from_frame</code> <code>str</code> <p>The frame in which the input coordinates are defined</p> required <code>to_frame</code> <code>str</code> <p>The frame that the coordinates should be provided in</p> required <code>coordinates</code> <code>ndarray</code> <p>The coordinates in the <code>from_frame</code></p> required <code>time</code> <code>GPSTime</code> <p>The time at which the <code>from_frame</code> and <code>to_frame</code> are aligned.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The coordinates in the <code>to_frame</code></p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the <code>from_frame</code> or <code>to_frame</code> are not valid frames</p> See Also <p>VALID_FRAMES: A list of the valid frames for the <code>from_frame</code> and     <code>to_frame</code> args</p> Notes <p>This function is used to transform a position in one frame to another. The time is the same for both the <code>from_frame</code> and <code>to_frame</code></p> Source code in <code>gps_frames/transforms.py</code> <pre><code>def position_transform(\n    from_frame: str, to_frame: str, coordinates: np.array, time: GPSTime\n) -&gt; np.array:\n    \"\"\"Convert a position from one frame to another.\n\n    The purpose of this function is to create a general tool to convert a\n    position from one frame to another. The current frame is given as the\n    `from_frame` and the desired new output frame is given as the `to_frame`.\n    The position is defined in the `from_frame` as the `coordinates`. The\n    `time` is used to define the time of the frame, as some conversions\n    between frames vary with time, e.g. ECEF to ECI.\n\n    Parameters\n    ----------\n    from_frame : str\n        The frame in which the input coordinates are defined\n    to_frame : str\n        The frame that the coordinates should be provided in\n    coordinates : np.ndarray\n        The coordinates in the `from_frame`\n    time : GPSTime\n        The time at which the `from_frame` and `to_frame` are aligned.\n\n    Returns\n    -------\n    np.ndarray\n        The coordinates in the `to_frame`\n\n    Raises\n    ------\n    NotImplementedError\n        If the `from_frame` or `to_frame` are not valid frames\n\n    See Also\n    --------\n    VALID_FRAMES: A list of the valid frames for the `from_frame` and\n        `to_frame` args\n\n    Notes\n    -----\n    This function is used to transform a position in one frame to another. The\n    time is the same for both the `from_frame` and `to_frame`\n\n    \"\"\"\n\n    if not isinstance(coordinates, np.ndarray):\n        coordinates = np.array(coordinates, dtype=float)\n    if from_frame not in VALID_FRAMES:\n        raise NotImplementedError(f\"(from_frame) Unknown Frame: {from_frame}\")\n    if to_frame not in VALID_FRAMES:\n        raise NotImplementedError(f\"(to_frame) Unknown Frame: {to_frame}\")\n\n    if from_frame == \"LLA\":\n        if to_frame == \"LLA\":\n            return coordinates\n        elif to_frame == \"ECEF\":\n            return lla2ecef(coordinates)\n        elif to_frame == \"ECI\":\n            return lla2eci(coordinates, time.time_of_week)\n    elif from_frame == \"ECEF\":\n        if to_frame == \"LLA\":\n            return ecef2lla(coordinates)\n        elif to_frame == \"ECEF\":\n            return coordinates\n        elif to_frame == \"ECI\":\n            return ecef2eci(coordinates, time.time_of_week)\n    elif from_frame == \"ECI\":\n        if to_frame == \"LLA\":\n            return eci2lla(coordinates, time.time_of_week)\n        elif to_frame == \"ECEF\":\n            return eci2ecef(coordinates, time.time_of_week)\n        elif to_frame == \"ECI\":\n            return coordinates\n\n    logger.critical(\"Transformation Failed. Returning input\")\n    return coordinates\n</code></pre>"},{"location":"reference/gps_frames/transforms/#gps_frames.transforms.rotate_ecef","title":"<code>rotate_ecef(old_time, new_time, coordinates)</code>","text":"<p>Rotate the coordinates in one ECEF frame to a new ECEF frame.</p> <p>Because the Earth is rotating, the ECEF frame is constantly moving and the coordinates in the ECEF frame at one time are different than the coordinates at some other time. This function uses the time between <code>old_time</code> and <code>new_time</code> to determine how much the ECEF frame rotates and updates the coordinates accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>old_time</code> <code>GPSTime</code> <p>The time for the ECEF frame where the <code>coordinates</code> are defined</p> required <code>new_time</code> <code>GPSTime</code> <p>The time of the new ECEF frame</p> required <code>coordinates</code> <code>ndarray</code> <p>The coordinates in the <code>old_time</code> ECEF frame</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The coordinates in the <code>new_time</code> ECEF frame</p> See Also <p>standard_rotation_matrix: Used to get the rotation matrix for the     transformation</p> Source code in <code>gps_frames/transforms.py</code> <pre><code>def rotate_ecef(\n    old_time: GPSTime, new_time: GPSTime, coordinates: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"Rotate the coordinates in one ECEF frame to a new ECEF frame.\n\n    Because the Earth is rotating, the ECEF frame is constantly moving and the\n    coordinates in the ECEF frame at one time are different than the\n    coordinates at some other time. This function uses the time between\n    `old_time` and `new_time` to determine how much the ECEF frame rotates and\n    updates the coordinates accordingly.\n\n    Parameters\n    ----------\n    old_time : GPSTime\n        The time for the ECEF frame where the `coordinates` are defined\n    new_time : GPSTime\n        The time of the new ECEF frame\n    coordinates : np.ndarray\n        The coordinates in the `old_time` ECEF frame\n\n    Returns\n    -------\n    np.ndarray\n        The coordinates in the `new_time` ECEF frame\n\n    See Also\n    --------\n    standard_rotation_matrix: Used to get the rotation matrix for the\n        transformation\n\n    \"\"\"\n    time_delta = new_time - old_time\n    assert isinstance(time_delta, float)\n\n    angle_delta = _w_e * time_delta\n    coordinates = np.array(coordinates, dtype=float)\n\n    # rotation = Rotation(dcm=standard_rotation_matrix(3, angle_delta))\n\n    return standard_rotation(3, angle_delta, coordinates)\n</code></pre>"},{"location":"reference/gps_frames/transforms/#gps_frames.transforms.velocity_transform","title":"<code>velocity_transform(from_frame, to_frame, position_coordinates, velocity_components, time)</code>","text":"<p>Transform velocity from one frame to another.</p> <p>Parameters:</p> Name Type Description Default <code>from_frame</code> <code>str</code> <p>The starting frame</p> required <code>to_frame</code> <code>str</code> <p>The desired frame</p> required <code>position_coordinates</code> <code>ndarray</code> <p>The position coordinates in the starting frame</p> required <code>velocity_components</code> <code>ndarray</code> <p>The velocity components in the starting from</p> required <code>time</code> <code>GPSTime</code> <p>The time that the transformation is taking place</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The velocity components in the destination frame</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Does not work with the 'LLA' frame, so raises an error if the to_frame or from_frame are specified as 'LLA'. Will also raise if the to_frame or from_frame are not valid frames.</p> Source code in <code>gps_frames/transforms.py</code> <pre><code>def velocity_transform(\n    from_frame: str,\n    to_frame: str,\n    position_coordinates: np.ndarray,\n    velocity_components: np.ndarray,\n    time: GPSTime,\n) -&gt; np.ndarray:\n    \"\"\"Transform velocity from one frame to another.\n\n    Parameters\n    ----------\n    from_frame : str\n        The starting frame\n    to_frame : str\n        The desired frame\n    position_coordinates : np.ndarray\n        The position coordinates in the starting frame\n    velocity_components : np.ndarray\n        The velocity components in the starting from\n    time : GPSTime\n        The time that the transformation is taking place\n\n    Returns\n    -------\n    np.ndarray\n        The velocity components in the destination frame\n\n    Raises\n    ------\n    ValueError\n        Does not work with the 'LLA' frame, so raises an error if the to_frame\n        or from_frame are specified as 'LLA'. Will also raise if the to_frame\n        or from_frame are not valid frames.\n    \"\"\"\n    position_coordinates = np.array(position_coordinates)\n    velocity_components = np.array(velocity_components)\n    if from_frame == \"LLA\" or to_frame == \"LLA\":\n        raise ValueError(\"from_frame and to_frame cannot be LLA\")\n\n    if from_frame not in VALID_FRAMES:\n        raise ValueError(f\"from_frame ({from_frame}) not valid\")\n    if to_frame not in VALID_FRAMES:\n        raise ValueError(f\"to_frame ({to_frame}) not valid\")\n\n    if from_frame == \"ECEF\":\n        if to_frame == \"ECEF\":\n            angle_of_rotation = 0.0\n            rotation_rate = 0.0\n        elif to_frame == \"ECI\":\n            angle_of_rotation = -_w_e * time.time_of_week\n            rotation_rate = -_w_e\n    elif from_frame == \"ECI\":\n        if to_frame == \"ECEF\":\n            angle_of_rotation = _w_e * time.time_of_week\n            rotation_rate = _w_e\n        elif to_frame == \"ECI\":\n            angle_of_rotation = 0.0\n            rotation_rate = 0.0\n\n    rotation = Rotation(dcm=standard_rotation_matrix(3, angle_of_rotation))\n    rate_matrix = standard_rotation_matrix_rates(3, angle_of_rotation, rotation_rate)\n\n    return rotation.rotate(velocity_components) + rate_matrix @ position_coordinates\n</code></pre>"},{"location":"reference/gps_frames/vectors/","title":"Vectors","text":""},{"location":"reference/gps_frames/vectors/#gps_frames.vectors","title":"<code>gps_frames.vectors</code>","text":"<p>Representation for Vectors.</p> <p>The purpose of this submodule is to provide for the representation of vectors in various reference frames.</p>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.SerializeableVector","title":"<code>SerializeableVector</code>  <code>dataclass</code>","text":"<p>Vector to serialize numpy arrays human readable.</p> <p>Attributes:</p> Name Type Description <code>coordinates</code> <code>ndarray</code> <p>A three element array representing the components of the vector</p> <code>frame_time</code> <code>GPSTime</code> <p>The time at which the frame is defined</p> <code>frame</code> <code>str</code> <p>The frame in which the vector is defined</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>@dataclass\nclass SerializeableVector:\n    \"\"\"Vector to serialize numpy arrays human readable.\n\n    Attributes\n    ----------\n    coordinates : np.ndarray\n        A three element array representing the components of the vector\n    frame_time : GPSTime\n        The time at which the frame is defined\n    frame : str\n        The frame in which the vector is defined\n\n    \"\"\"\n\n    coordinates: np.ndarray\n    frame_time: GPSTime\n    frame: str\n\n    yaml_tag: str = \"!SerializeableVector\"\n\n    def __post_init__(self):\n        \"\"\"Nothing.\"\"\"\n        if not isinstance(self.coordinates, np.ndarray):\n            self.coordinates = np.array(self.coordinates)\n\n        self.coordinates = np.array(self.coordinates, dtype=float)\n\n        if len(np.shape(self.coordinates)) == 2:\n            self.coordinates = np.reshape(self.coordinates, 3)\n        elif len(np.shape(self.coordinates)) &gt; 2:\n            raise ValueError(\"Too many dimensions for coordinates\")\n\n    @classmethod\n    def to_yaml(\n        cls, representer: ruamel.yaml.Representer, node: SerializeableVector\n    ) -&gt; ruamel.yaml.MappingNode:\n        \"\"\"Convert the class into a mapping node for serialzation.\n\n        Takes the attributes of the class and converts them to ScalarNode\n        used in a ruamel.yaml MappingNode to dump the object in a specific\n        format. This method is called by the ruamel.yaml.YAML object\n        when passed to register_class\n\n        Parameters\n        ----------\n        representer : ruamel.yaml.Representer\n            Yaml representer\n        node : SerializeableVector\n            The instance of the class to serialize\n\n        Returns\n        -------\n        ruamel.yaml.MappingNode\n            A mapping node which describes to the yaml dumper how to serialize\n            the object\n\n        \"\"\"\n        coords = [float(d) for d in node.coordinates]\n        return representer.represent_mapping(\n            cls.yaml_tag,\n            {\n                \"frame\": node.frame,\n                \"frame_time\": node.frame_time.to_datetime(),\n                \"coordinates\": coords,\n            },\n        )\n\n    @classmethod\n    def from_yaml(\n        cls: type, constructor: ruamel.yaml.Constructor, node: ruamel.yaml.MappingNode\n    ) -&gt; SerializeableVector:\n        \"\"\"Construct a class from a MappingNode.\n\n        This method is called when using yaml.load if the\n        SerializeableVector class has been registered to the\n        ruamel.yaml.YAML object\n\n        Parameters\n        ----------\n        cls : type\n            The type of the class to deserialize\n        constructor : ruamel.yaml.Constructor\n            The constructor object\n        node : ruamel.yaml.MappingNode\n            Node created from the yaml parser\n\n        Returns\n        -------\n        SerializeableVector\n            Instance of serialized class\n\n        \"\"\"\n        nodes = node.value\n        coordinates = None\n        frame_time = None\n        frame = None\n        for i in range(0, len(nodes)):\n            node_name = nodes[i][0].value\n            if node_name == \"coordinates\":\n                coordinates = np.array(constructor.construct_sequence(nodes[i][1]))\n            elif node_name == \"frame\":\n                frame = constructor.construct_scalar(nodes[i][1])\n            elif node_name == \"frame_time\":\n                frame_time = GPSTime.from_datetime(\n                    constructor.construct_object(nodes[i][1])\n                )\n        return cls(np.array(coordinates, dtype=float), frame_time, frame)\n\n    def __eq__(self, other: SerializeableVector) -&gt; bool:\n        \"\"\"Check equality.\n\n        Parameters\n        ----------\n        other : SerializeableVector\n            Vector to check equality against\n\n        Returns\n        -------\n        bool\n            True if the two are equal\n        \"\"\"\n        return (\n            np.array_equal(self.coordinates, other.coordinates)\n            and self.frame_time == other.frame_time\n            and self.frame == other.frame\n        )\n\n    def __hash__(self):\n        \"\"\"Create hash.\"\"\"\n        return hash(\n            self.frame\n            + str(hash(self.frame_time))\n            + \"\".join([str(_coord) for _coord in self.coordinates])\n        )\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.SerializeableVector.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check equality.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SerializeableVector</code> <p>Vector to check equality against</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the two are equal</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def __eq__(self, other: SerializeableVector) -&gt; bool:\n    \"\"\"Check equality.\n\n    Parameters\n    ----------\n    other : SerializeableVector\n        Vector to check equality against\n\n    Returns\n    -------\n    bool\n        True if the two are equal\n    \"\"\"\n    return (\n        np.array_equal(self.coordinates, other.coordinates)\n        and self.frame_time == other.frame_time\n        and self.frame == other.frame\n    )\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.SerializeableVector.__hash__","title":"<code>__hash__()</code>","text":"<p>Create hash.</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def __hash__(self):\n    \"\"\"Create hash.\"\"\"\n    return hash(\n        self.frame\n        + str(hash(self.frame_time))\n        + \"\".join([str(_coord) for _coord in self.coordinates])\n    )\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.SerializeableVector.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Nothing.</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Nothing.\"\"\"\n    if not isinstance(self.coordinates, np.ndarray):\n        self.coordinates = np.array(self.coordinates)\n\n    self.coordinates = np.array(self.coordinates, dtype=float)\n\n    if len(np.shape(self.coordinates)) == 2:\n        self.coordinates = np.reshape(self.coordinates, 3)\n    elif len(np.shape(self.coordinates)) &gt; 2:\n        raise ValueError(\"Too many dimensions for coordinates\")\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.SerializeableVector.from_yaml","title":"<code>from_yaml(constructor, node)</code>  <code>classmethod</code>","text":"<p>Construct a class from a MappingNode.</p> <p>This method is called when using yaml.load if the SerializeableVector class has been registered to the ruamel.yaml.YAML object</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The type of the class to deserialize</p> required <code>constructor</code> <code>Constructor</code> <p>The constructor object</p> required <code>node</code> <code>MappingNode</code> <p>Node created from the yaml parser</p> required <p>Returns:</p> Type Description <code>SerializeableVector</code> <p>Instance of serialized class</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>@classmethod\ndef from_yaml(\n    cls: type, constructor: ruamel.yaml.Constructor, node: ruamel.yaml.MappingNode\n) -&gt; SerializeableVector:\n    \"\"\"Construct a class from a MappingNode.\n\n    This method is called when using yaml.load if the\n    SerializeableVector class has been registered to the\n    ruamel.yaml.YAML object\n\n    Parameters\n    ----------\n    cls : type\n        The type of the class to deserialize\n    constructor : ruamel.yaml.Constructor\n        The constructor object\n    node : ruamel.yaml.MappingNode\n        Node created from the yaml parser\n\n    Returns\n    -------\n    SerializeableVector\n        Instance of serialized class\n\n    \"\"\"\n    nodes = node.value\n    coordinates = None\n    frame_time = None\n    frame = None\n    for i in range(0, len(nodes)):\n        node_name = nodes[i][0].value\n        if node_name == \"coordinates\":\n            coordinates = np.array(constructor.construct_sequence(nodes[i][1]))\n        elif node_name == \"frame\":\n            frame = constructor.construct_scalar(nodes[i][1])\n        elif node_name == \"frame_time\":\n            frame_time = GPSTime.from_datetime(\n                constructor.construct_object(nodes[i][1])\n            )\n    return cls(np.array(coordinates, dtype=float), frame_time, frame)\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.SerializeableVector.to_yaml","title":"<code>to_yaml(representer, node)</code>  <code>classmethod</code>","text":"<p>Convert the class into a mapping node for serialzation.</p> <p>Takes the attributes of the class and converts them to ScalarNode used in a ruamel.yaml MappingNode to dump the object in a specific format. This method is called by the ruamel.yaml.YAML object when passed to register_class</p> <p>Parameters:</p> Name Type Description Default <code>representer</code> <code>Representer</code> <p>Yaml representer</p> required <code>node</code> <code>SerializeableVector</code> <p>The instance of the class to serialize</p> required <p>Returns:</p> Type Description <code>MappingNode</code> <p>A mapping node which describes to the yaml dumper how to serialize the object</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>@classmethod\ndef to_yaml(\n    cls, representer: ruamel.yaml.Representer, node: SerializeableVector\n) -&gt; ruamel.yaml.MappingNode:\n    \"\"\"Convert the class into a mapping node for serialzation.\n\n    Takes the attributes of the class and converts them to ScalarNode\n    used in a ruamel.yaml MappingNode to dump the object in a specific\n    format. This method is called by the ruamel.yaml.YAML object\n    when passed to register_class\n\n    Parameters\n    ----------\n    representer : ruamel.yaml.Representer\n        Yaml representer\n    node : SerializeableVector\n        The instance of the class to serialize\n\n    Returns\n    -------\n    ruamel.yaml.MappingNode\n        A mapping node which describes to the yaml dumper how to serialize\n        the object\n\n    \"\"\"\n    coords = [float(d) for d in node.coordinates]\n    return representer.represent_mapping(\n        cls.yaml_tag,\n        {\n            \"frame\": node.frame,\n            \"frame_time\": node.frame_time.to_datetime(),\n            \"coordinates\": coords,\n        },\n    )\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.UnitVector","title":"<code>UnitVector</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Vector</code></p> <p>Represention of a unit vector.</p> <p>Attributes:</p> Name Type Description <code>coordinates</code> <code>ndarray</code> <p>The three coordinates that define the position.</p> <code>frame_time</code> <code>GPSTime</code> <p>The time for which the reference frame is defined</p> <code>frame</code> <code>str</code> <p>The name of the frame</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>class UnitVector(Vector):\n    \"\"\"Represention of a unit vector.\n\n    Attributes\n    ----------\n    coordinates : np.ndarray\n        The three coordinates that define the position.\n    frame_time : GPSTime\n        The time for which the reference frame is defined\n    frame : str\n        The name of the frame\n\n    \"\"\"\n\n    yaml_tag: str = \"!SerializeableVector.Vector.UnitVector\"\n\n    def __post_init__(self):\n        \"\"\"Run post-init checks.\n\n        Ensure vector is normalized\n\n        \"\"\"\n        super().__post_init__()\n        self.normalize()\n\n    @classmethod\n    def from_vector(cls, vector: Vector) -&gt; UnitVector:\n        \"\"\"Recast a vector as a unit vector.\n\n        Parameters\n        ----------\n        vector : Vector\n            A vector\n\n        Returns\n        -------\n        UnitVector\n            The vector normalized to a unit vector\n\n        \"\"\"\n        return cls(vector.coordinates, vector.frame_time, vector.frame)\n\n    def normalize(self) -&gt; None:\n        \"\"\"Normalize the Unit Vector to a magnitude of 1.\"\"\"\n        self.coordinates = _norm_numba(self.coordinates)\n\n    def get_unit_vector(self, out_frame: str) -&gt; UnitVector:\n        \"\"\"Get a unit vector object in new frame.\n\n        !!! note \"New Object Created on Output\"\n            This function returns a new `UnitVector` object. It does not change\n            the reference frame used in this object. Use `switch_frame()` to\n            change the frame of the object.\n\n        Parameters\n        ----------\n        out_frame : str\n            The frame to output the unit vector in\n\n        Returns\n        -------\n        UnitVector\n            The unit vector in the desired frame\n\n        See Also\n        --------\n        switch_frame: Change the frame that the unit vector is interally\n            expressed in\n\n        \"\"\"\n        return self.from_vector(super().get_vector(out_frame))\n\n    def switch_frame(self, to_frame: str) -&gt; None:\n        \"\"\"Change the frame used to store this unit vector internally.\n\n        Parameters\n        ----------\n        to_frame : str\n            The desired new frame\n\n        \"\"\"\n        super().switch_frame(to_frame)\n        self.normalize()\n\n    def __mul__(self, other: float) -&gt; Vector:\n        \"\"\"Multiply UnitVector by a float (scale it to a Vector).\n\n        Parameters\n        ----------\n        other : float\n            integer to multiply\n\n        Returns\n        -------\n        Vector\n            New vector\n\n        Raises\n        ------\n        TypeError\n            If other is not a float\n\n        \"\"\"\n        if isinstance(other, int):\n            other = float(other)\n\n        if not isinstance(other, float):\n            raise TypeError(f\"other value must be a float. IS: {type(other)}\")\n\n        new_coordinates = self.coordinates * other\n        return Vector(new_coordinates, self.frame_time, self.frame)\n\n    def __hash__(self):\n        \"\"\"Create hash.\"\"\"\n        return hash(\n            self.frame\n            + str(hash(self.frame_time))\n            + \"\".join([str(_coord) for _coord in self.coordinates])\n        )\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.UnitVector.__hash__","title":"<code>__hash__()</code>","text":"<p>Create hash.</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def __hash__(self):\n    \"\"\"Create hash.\"\"\"\n    return hash(\n        self.frame\n        + str(hash(self.frame_time))\n        + \"\".join([str(_coord) for _coord in self.coordinates])\n    )\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.UnitVector.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiply UnitVector by a float (scale it to a Vector).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>float</code> <p>integer to multiply</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>New vector</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If other is not a float</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def __mul__(self, other: float) -&gt; Vector:\n    \"\"\"Multiply UnitVector by a float (scale it to a Vector).\n\n    Parameters\n    ----------\n    other : float\n        integer to multiply\n\n    Returns\n    -------\n    Vector\n        New vector\n\n    Raises\n    ------\n    TypeError\n        If other is not a float\n\n    \"\"\"\n    if isinstance(other, int):\n        other = float(other)\n\n    if not isinstance(other, float):\n        raise TypeError(f\"other value must be a float. IS: {type(other)}\")\n\n    new_coordinates = self.coordinates * other\n    return Vector(new_coordinates, self.frame_time, self.frame)\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.UnitVector.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Run post-init checks.</p> <p>Ensure vector is normalized</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Run post-init checks.\n\n    Ensure vector is normalized\n\n    \"\"\"\n    super().__post_init__()\n    self.normalize()\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.UnitVector.from_vector","title":"<code>from_vector(vector)</code>  <code>classmethod</code>","text":"<p>Recast a vector as a unit vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>Vector</code> <p>A vector</p> required <p>Returns:</p> Type Description <code>UnitVector</code> <p>The vector normalized to a unit vector</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>@classmethod\ndef from_vector(cls, vector: Vector) -&gt; UnitVector:\n    \"\"\"Recast a vector as a unit vector.\n\n    Parameters\n    ----------\n    vector : Vector\n        A vector\n\n    Returns\n    -------\n    UnitVector\n        The vector normalized to a unit vector\n\n    \"\"\"\n    return cls(vector.coordinates, vector.frame_time, vector.frame)\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.UnitVector.get_unit_vector","title":"<code>get_unit_vector(out_frame)</code>","text":"<p>Get a unit vector object in new frame.</p> <p>New Object Created on Output</p> <p>This function returns a new <code>UnitVector</code> object. It does not change the reference frame used in this object. Use <code>switch_frame()</code> to change the frame of the object.</p> <p>Parameters:</p> Name Type Description Default <code>out_frame</code> <code>str</code> <p>The frame to output the unit vector in</p> required <p>Returns:</p> Type Description <code>UnitVector</code> <p>The unit vector in the desired frame</p> See Also <p>switch_frame: Change the frame that the unit vector is interally     expressed in</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def get_unit_vector(self, out_frame: str) -&gt; UnitVector:\n    \"\"\"Get a unit vector object in new frame.\n\n    !!! note \"New Object Created on Output\"\n        This function returns a new `UnitVector` object. It does not change\n        the reference frame used in this object. Use `switch_frame()` to\n        change the frame of the object.\n\n    Parameters\n    ----------\n    out_frame : str\n        The frame to output the unit vector in\n\n    Returns\n    -------\n    UnitVector\n        The unit vector in the desired frame\n\n    See Also\n    --------\n    switch_frame: Change the frame that the unit vector is interally\n        expressed in\n\n    \"\"\"\n    return self.from_vector(super().get_vector(out_frame))\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.UnitVector.normalize","title":"<code>normalize()</code>","text":"<p>Normalize the Unit Vector to a magnitude of 1.</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def normalize(self) -&gt; None:\n    \"\"\"Normalize the Unit Vector to a magnitude of 1.\"\"\"\n    self.coordinates = _norm_numba(self.coordinates)\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.UnitVector.switch_frame","title":"<code>switch_frame(to_frame)</code>","text":"<p>Change the frame used to store this unit vector internally.</p> <p>Parameters:</p> Name Type Description Default <code>to_frame</code> <code>str</code> <p>The desired new frame</p> required Source code in <code>gps_frames/vectors.py</code> <pre><code>def switch_frame(self, to_frame: str) -&gt; None:\n    \"\"\"Change the frame used to store this unit vector internally.\n\n    Parameters\n    ----------\n    to_frame : str\n        The desired new frame\n\n    \"\"\"\n    super().switch_frame(to_frame)\n    self.normalize()\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.Vector","title":"<code>Vector</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SerializeableVector</code></p> <p>Representation of a vector.</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>@dataclass\nclass Vector(SerializeableVector):\n    \"\"\"Representation of a vector.\"\"\"\n\n    yaml_tag: str = \"!SerializeableVector.Vector\"\n\n    def __post_init__(self):\n        \"\"\"Run post-init checks.\n\n        Ensure that the coordinates are a numpy array and is not in the LLA\n        frame to avoid numerical issues\n\n        \"\"\"\n        super().__post_init__()\n\n        if self.frame == \"LLA\":\n            raise ValueError(\"Vectors cannot be defined in the LLA frame\")\n\n        if self.frame not in [\"ECEF\", \"ECI\"]:\n            raise ValueError(\"Vectors must be defined in either the ECI or ECEF frame\")\n\n    def get_vector(self, out_frame: str) -&gt; Vector:\n        \"\"\"Get a vector object in new frame.\n\n        !!! note \"New Object Created on Output\"\n            This function returns a new `Vector` object. It does not change\n            the reference frame used in this object. Use `switch_frame()` to\n            change the frame of the object.\n\n        Parameters\n        ----------\n        out_frame : str\n            The frame to output the vector in\n\n        Returns\n        -------\n        Vector\n            The vector in the desired frame\n\n        See Also\n        --------\n        switch_frame: Change the frame that the vector is interally\n            expressed in\n\n        \"\"\"\n        if out_frame == \"LLA\":\n            raise ValueError(\"Vectors cannot be defined in the LLA frame\")\n\n        new_coordinates = trans.position_transform(\n            self.frame, out_frame, self.coordinates, self.frame_time\n        )\n\n        new_vector = self.__class__(new_coordinates, self.frame_time, out_frame)\n\n        return new_vector\n\n    def switch_frame(self, to_frame: str) -&gt; None:\n        \"\"\"Change the frame used to store this vector internally.\n\n        Parameters\n        ----------\n        to_frame : str\n            The desired new frame\n\n        \"\"\"\n        if to_frame == \"LLA\":\n            raise ValueError(\"Vectors cannot be defined in the LLA frame\")\n\n        new_coordinates = trans.position_transform(\n            self.frame, to_frame, self.coordinates, self.frame_time\n        )\n\n        self.coordinates = new_coordinates\n        self.frame = to_frame\n\n    def update_frame_time(self, new_frame_time: GPSTime) -&gt; None:\n        \"\"\"Change the reference time for the frame.\n\n        Reference frames can be time dependant. This method is used to change\n        the time reference for a reference frame.\n\n        This method updates the internal representation of the vector to\n        the frame at the new reference time.\n\n        Parameters\n        ----------\n        new_frame_time : GPSTime\n            The new frame reference time\n\n        \"\"\"\n        if self.frame == \"ECI\":\n            delta_weeks = new_frame_time.week_number - self.frame_time.week_number\n\n            self.coordinates = trans.add_weeks_eci(delta_weeks, self.coordinates)\n            self.frame_time = new_frame_time\n\n        elif self.frame == \"ECEF\":\n            self.coordinates = trans.rotate_ecef(\n                self.frame_time, new_frame_time, self.coordinates\n            )\n            self.frame_time = new_frame_time\n\n    def cross_product(self, other: Vector) -&gt; Vector:\n        \"\"\"Cross Product.\n\n        Take the cross product of one vector with respect to annother\n\n        Parameters\n        ----------\n        other : Vector\n            Another vector\n\n        Returns\n        -------\n        Vector\n            self cross other\n\n        \"\"\"\n        other_vector = other.get_vector(self.frame)\n        other_vector.update_frame_time(self.frame_time)\n\n        new_coordinates = _cross_numba(self.coordinates, other_vector.coordinates)\n\n        return self.__class__(new_coordinates, self.frame_time, self.frame)\n\n    def dot_product(self, other: Union[Vector, np.ndarray]) -&gt; float:\n        \"\"\"Dot Product.\n\n        Take the dot product of one vector with repsect to another\n\n        Parameters\n        ----------\n        other : Union[Vector, np.ndarray]\n            If other is a `Vector`, then rotates into the correct frame before\n            taking the dot product. If the other is a `np.ndarray`, it is\n            assumed to already be in the correct frame.\n\n        Returns\n        -------\n        float\n            The dot product\n\n        Raises\n        ------\n        TypeError\n            If the other is not a `Vector` or `np.ndarray`\n\n        \"\"\"\n        if isinstance(other, Vector):\n            other_vector = other.get_vector(self.frame)\n            other_vector.update_frame_time(self.frame_time)\n\n            _coordinates = other_vector.coordinates\n        elif isinstance(other, np.ndarray):\n            _coordinates = other\n        else:\n            raise TypeError(\"other must be a Vector of Numpy array\")\n\n        return np.dot(self.coordinates, _coordinates)\n\n    @property\n    def magnitude(self) -&gt; float:\n        \"\"\"Get the magnitude of the vector.\n\n        Returns\n        -------\n        float\n            The magnitude of the vector\n\n        \"\"\"\n        return np.linalg.norm(self.coordinates)\n\n    def __neg__(self) -&gt; Vector:\n        \"\"\"Negation Operator.\n\n        This flips the direction of the vector\n\n        Returns\n        -------\n        Vector\n            A new vector with the coordinates flipped\n\n        \"\"\"\n        return self.__class__(-self.coordinates, self.frame_time, self.frame)\n\n    def __add__(self, other: Vector) -&gt; Vector:\n        \"\"\"Add two vectors.\n\n        Parameters\n        ----------\n        other : Vector\n            Vector to add\n\n        Returns\n        -------\n        Vector\n            New vector\n\n        \"\"\"\n        other_vector = other.get_vector(self.frame)\n        other_vector.update_frame_time(self.frame_time)\n\n        new_coordinates = self.coordinates + other_vector.coordinates\n\n        return self.__class__(new_coordinates, self.frame_time, self.frame)\n\n    def __sub__(self, other: Vector) -&gt; Vector:\n        \"\"\"Subtract two vectors.\n\n        Parameters\n        ----------\n        other : Vector\n            Vector to subtract\n\n        Returns\n        -------\n        Vector\n            New vector\n\n        \"\"\"\n        other_vector = other.get_vector(self.frame)\n        other_vector.update_frame_time(self.frame_time)\n\n        new_coordinates = self.coordinates - other_vector.coordinates\n\n        return self.__class__(new_coordinates, self.frame_time, self.frame)\n\n    def __mul__(self, other: float) -&gt; Vector:\n        \"\"\"Multiply vector by an integer (scale it).\n\n        Parameters\n        ----------\n        other : float\n            integer to multiply\n\n        Returns\n        -------\n        Vector\n            New vector\n\n        Raises\n        ------\n        TypeError\n            If other is not a float\n\n        \"\"\"\n        if isinstance(other, int):\n            other = float(other)\n\n        if not isinstance(other, float):\n            raise TypeError(f\"other value must be a float. IS: {type(other)}\")\n\n        new_coordinates = self.coordinates * other\n        return self.__class__(new_coordinates, self.frame_time, self.frame)\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.Vector.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude of the vector.</p> <p>Returns:</p> Type Description <code>float</code> <p>The magnitude of the vector</p>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.Vector.__add__","title":"<code>__add__(other)</code>","text":"<p>Add two vectors.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Vector</code> <p>Vector to add</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>New vector</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def __add__(self, other: Vector) -&gt; Vector:\n    \"\"\"Add two vectors.\n\n    Parameters\n    ----------\n    other : Vector\n        Vector to add\n\n    Returns\n    -------\n    Vector\n        New vector\n\n    \"\"\"\n    other_vector = other.get_vector(self.frame)\n    other_vector.update_frame_time(self.frame_time)\n\n    new_coordinates = self.coordinates + other_vector.coordinates\n\n    return self.__class__(new_coordinates, self.frame_time, self.frame)\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.Vector.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiply vector by an integer (scale it).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>float</code> <p>integer to multiply</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>New vector</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If other is not a float</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def __mul__(self, other: float) -&gt; Vector:\n    \"\"\"Multiply vector by an integer (scale it).\n\n    Parameters\n    ----------\n    other : float\n        integer to multiply\n\n    Returns\n    -------\n    Vector\n        New vector\n\n    Raises\n    ------\n    TypeError\n        If other is not a float\n\n    \"\"\"\n    if isinstance(other, int):\n        other = float(other)\n\n    if not isinstance(other, float):\n        raise TypeError(f\"other value must be a float. IS: {type(other)}\")\n\n    new_coordinates = self.coordinates * other\n    return self.__class__(new_coordinates, self.frame_time, self.frame)\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.Vector.__neg__","title":"<code>__neg__()</code>","text":"<p>Negation Operator.</p> <p>This flips the direction of the vector</p> <p>Returns:</p> Type Description <code>Vector</code> <p>A new vector with the coordinates flipped</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def __neg__(self) -&gt; Vector:\n    \"\"\"Negation Operator.\n\n    This flips the direction of the vector\n\n    Returns\n    -------\n    Vector\n        A new vector with the coordinates flipped\n\n    \"\"\"\n    return self.__class__(-self.coordinates, self.frame_time, self.frame)\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.Vector.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Run post-init checks.</p> <p>Ensure that the coordinates are a numpy array and is not in the LLA frame to avoid numerical issues</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Run post-init checks.\n\n    Ensure that the coordinates are a numpy array and is not in the LLA\n    frame to avoid numerical issues\n\n    \"\"\"\n    super().__post_init__()\n\n    if self.frame == \"LLA\":\n        raise ValueError(\"Vectors cannot be defined in the LLA frame\")\n\n    if self.frame not in [\"ECEF\", \"ECI\"]:\n        raise ValueError(\"Vectors must be defined in either the ECI or ECEF frame\")\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.Vector.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtract two vectors.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Vector</code> <p>Vector to subtract</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>New vector</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def __sub__(self, other: Vector) -&gt; Vector:\n    \"\"\"Subtract two vectors.\n\n    Parameters\n    ----------\n    other : Vector\n        Vector to subtract\n\n    Returns\n    -------\n    Vector\n        New vector\n\n    \"\"\"\n    other_vector = other.get_vector(self.frame)\n    other_vector.update_frame_time(self.frame_time)\n\n    new_coordinates = self.coordinates - other_vector.coordinates\n\n    return self.__class__(new_coordinates, self.frame_time, self.frame)\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.Vector.cross_product","title":"<code>cross_product(other)</code>","text":"<p>Cross Product.</p> <p>Take the cross product of one vector with respect to annother</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Vector</code> <p>Another vector</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>self cross other</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def cross_product(self, other: Vector) -&gt; Vector:\n    \"\"\"Cross Product.\n\n    Take the cross product of one vector with respect to annother\n\n    Parameters\n    ----------\n    other : Vector\n        Another vector\n\n    Returns\n    -------\n    Vector\n        self cross other\n\n    \"\"\"\n    other_vector = other.get_vector(self.frame)\n    other_vector.update_frame_time(self.frame_time)\n\n    new_coordinates = _cross_numba(self.coordinates, other_vector.coordinates)\n\n    return self.__class__(new_coordinates, self.frame_time, self.frame)\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.Vector.dot_product","title":"<code>dot_product(other)</code>","text":"<p>Dot Product.</p> <p>Take the dot product of one vector with repsect to another</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[Vector, ndarray]</code> <p>If other is a <code>Vector</code>, then rotates into the correct frame before taking the dot product. If the other is a <code>np.ndarray</code>, it is assumed to already be in the correct frame.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The dot product</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the other is not a <code>Vector</code> or <code>np.ndarray</code></p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def dot_product(self, other: Union[Vector, np.ndarray]) -&gt; float:\n    \"\"\"Dot Product.\n\n    Take the dot product of one vector with repsect to another\n\n    Parameters\n    ----------\n    other : Union[Vector, np.ndarray]\n        If other is a `Vector`, then rotates into the correct frame before\n        taking the dot product. If the other is a `np.ndarray`, it is\n        assumed to already be in the correct frame.\n\n    Returns\n    -------\n    float\n        The dot product\n\n    Raises\n    ------\n    TypeError\n        If the other is not a `Vector` or `np.ndarray`\n\n    \"\"\"\n    if isinstance(other, Vector):\n        other_vector = other.get_vector(self.frame)\n        other_vector.update_frame_time(self.frame_time)\n\n        _coordinates = other_vector.coordinates\n    elif isinstance(other, np.ndarray):\n        _coordinates = other\n    else:\n        raise TypeError(\"other must be a Vector of Numpy array\")\n\n    return np.dot(self.coordinates, _coordinates)\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.Vector.get_vector","title":"<code>get_vector(out_frame)</code>","text":"<p>Get a vector object in new frame.</p> <p>New Object Created on Output</p> <p>This function returns a new <code>Vector</code> object. It does not change the reference frame used in this object. Use <code>switch_frame()</code> to change the frame of the object.</p> <p>Parameters:</p> Name Type Description Default <code>out_frame</code> <code>str</code> <p>The frame to output the vector in</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>The vector in the desired frame</p> See Also <p>switch_frame: Change the frame that the vector is interally     expressed in</p> Source code in <code>gps_frames/vectors.py</code> <pre><code>def get_vector(self, out_frame: str) -&gt; Vector:\n    \"\"\"Get a vector object in new frame.\n\n    !!! note \"New Object Created on Output\"\n        This function returns a new `Vector` object. It does not change\n        the reference frame used in this object. Use `switch_frame()` to\n        change the frame of the object.\n\n    Parameters\n    ----------\n    out_frame : str\n        The frame to output the vector in\n\n    Returns\n    -------\n    Vector\n        The vector in the desired frame\n\n    See Also\n    --------\n    switch_frame: Change the frame that the vector is interally\n        expressed in\n\n    \"\"\"\n    if out_frame == \"LLA\":\n        raise ValueError(\"Vectors cannot be defined in the LLA frame\")\n\n    new_coordinates = trans.position_transform(\n        self.frame, out_frame, self.coordinates, self.frame_time\n    )\n\n    new_vector = self.__class__(new_coordinates, self.frame_time, out_frame)\n\n    return new_vector\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.Vector.switch_frame","title":"<code>switch_frame(to_frame)</code>","text":"<p>Change the frame used to store this vector internally.</p> <p>Parameters:</p> Name Type Description Default <code>to_frame</code> <code>str</code> <p>The desired new frame</p> required Source code in <code>gps_frames/vectors.py</code> <pre><code>def switch_frame(self, to_frame: str) -&gt; None:\n    \"\"\"Change the frame used to store this vector internally.\n\n    Parameters\n    ----------\n    to_frame : str\n        The desired new frame\n\n    \"\"\"\n    if to_frame == \"LLA\":\n        raise ValueError(\"Vectors cannot be defined in the LLA frame\")\n\n    new_coordinates = trans.position_transform(\n        self.frame, to_frame, self.coordinates, self.frame_time\n    )\n\n    self.coordinates = new_coordinates\n    self.frame = to_frame\n</code></pre>"},{"location":"reference/gps_frames/vectors/#gps_frames.vectors.Vector.update_frame_time","title":"<code>update_frame_time(new_frame_time)</code>","text":"<p>Change the reference time for the frame.</p> <p>Reference frames can be time dependant. This method is used to change the time reference for a reference frame.</p> <p>This method updates the internal representation of the vector to the frame at the new reference time.</p> <p>Parameters:</p> Name Type Description Default <code>new_frame_time</code> <code>GPSTime</code> <p>The new frame reference time</p> required Source code in <code>gps_frames/vectors.py</code> <pre><code>def update_frame_time(self, new_frame_time: GPSTime) -&gt; None:\n    \"\"\"Change the reference time for the frame.\n\n    Reference frames can be time dependant. This method is used to change\n    the time reference for a reference frame.\n\n    This method updates the internal representation of the vector to\n    the frame at the new reference time.\n\n    Parameters\n    ----------\n    new_frame_time : GPSTime\n        The new frame reference time\n\n    \"\"\"\n    if self.frame == \"ECI\":\n        delta_weeks = new_frame_time.week_number - self.frame_time.week_number\n\n        self.coordinates = trans.add_weeks_eci(delta_weeks, self.coordinates)\n        self.frame_time = new_frame_time\n\n    elif self.frame == \"ECEF\":\n        self.coordinates = trans.rotate_ecef(\n            self.frame_time, new_frame_time, self.coordinates\n        )\n        self.frame_time = new_frame_time\n</code></pre>"},{"location":"reference/gps_frames/velocity/","title":"Velocity","text":""},{"location":"reference/gps_frames/velocity/#gps_frames.velocity","title":"<code>gps_frames.velocity</code>","text":"<p>Positions in reference frames.</p> <p>The purpose of this submodule is to provide a representation for the velocity of objects and tools to manipulate the velocities.</p>"},{"location":"reference/gps_frames/velocity/#gps_frames.velocity.Velocity","title":"<code>Velocity</code>  <code>dataclass</code>","text":"<p>Dfines the velocity of an object.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Position</code> <p>The position of the object</p> <code>velocity</code> <code>Vector</code> <p>The velocity of the object</p> Notes <p>The position is required in order to translate velocity between inertial and non-inertial frames</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>The <code>update_frame_time()</code> is currently only a placeholder, so it raises an error if called</p> Source code in <code>gps_frames/velocity.py</code> <pre><code>@dataclass\nclass Velocity:\n    \"\"\"Dfines the velocity of an object.\n\n    Attributes\n    ----------\n    position : Position\n        The position of the object\n    velocity : Vector\n        The velocity of the object\n\n    Notes\n    -----\n    The position is required in order to translate velocity between inertial\n    and non-inertial frames\n\n    Raises\n    ------\n    NotImplementedError\n        The `update_frame_time()` is currently only a placeholder, so it\n        raises an error if called\n\n    \"\"\"\n\n    position: Position\n    velocity: Vector\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Initialize positions.\"\"\"\n        self.position = self.position.get_position(self.velocity.frame)\n        self.position.update_frame_time(self.velocity.frame_time)\n\n    def get_velocity(self, out_frame: str) -&gt; Velocity:\n        \"\"\"Get the velocity in a specified frame.\n\n        Parameters\n        ----------\n        out_frame : str\n            Frame to output velocity in\n\n        Returns\n        -------\n        Velocity\n            Velocity in specified frame\n\n        \"\"\"\n        components = self.velocity\n        new_components = velocity_transform(\n            self.position.frame,\n            out_frame,\n            self.position.coordinates,\n            components.coordinates,\n            self.position.frame_time,\n        )\n        new_velocity = Vector(\n            coordinates=new_components,\n            frame_time=self.velocity.frame_time,\n            frame=out_frame,\n        )\n        new_position = self.position.get_position(out_frame)\n\n        return self.__class__(position=new_position, velocity=new_velocity)\n\n    def update_frame_time(self, new_frame_time: GPSTime) -&gt; None:\n        \"\"\"Change the reference time for the frame.\n\n        !!! quote \"Todo\"\n            Placeholder\n            This is a placeholder that raises an error. It is not clear if\n            this is needed in the future.\n\n        Reference frames can be time dependant. This method is used to change\n        the time reference for a reference frame.\n\n        This method updates the internal representation of the velocity to the\n        frame at the new reference time.\n\n        Parameters\n        ----------\n        new_frame_time : GPSTime\n            The new frame reference time\n\n        \"\"\"\n        raise NotImplementedError(\"Placeholder for to mark future needs\")\n</code></pre>"},{"location":"reference/gps_frames/velocity/#gps_frames.velocity.Velocity.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize positions.</p> Source code in <code>gps_frames/velocity.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Initialize positions.\"\"\"\n    self.position = self.position.get_position(self.velocity.frame)\n    self.position.update_frame_time(self.velocity.frame_time)\n</code></pre>"},{"location":"reference/gps_frames/velocity/#gps_frames.velocity.Velocity.get_velocity","title":"<code>get_velocity(out_frame)</code>","text":"<p>Get the velocity in a specified frame.</p> <p>Parameters:</p> Name Type Description Default <code>out_frame</code> <code>str</code> <p>Frame to output velocity in</p> required <p>Returns:</p> Type Description <code>Velocity</code> <p>Velocity in specified frame</p> Source code in <code>gps_frames/velocity.py</code> <pre><code>def get_velocity(self, out_frame: str) -&gt; Velocity:\n    \"\"\"Get the velocity in a specified frame.\n\n    Parameters\n    ----------\n    out_frame : str\n        Frame to output velocity in\n\n    Returns\n    -------\n    Velocity\n        Velocity in specified frame\n\n    \"\"\"\n    components = self.velocity\n    new_components = velocity_transform(\n        self.position.frame,\n        out_frame,\n        self.position.coordinates,\n        components.coordinates,\n        self.position.frame_time,\n    )\n    new_velocity = Vector(\n        coordinates=new_components,\n        frame_time=self.velocity.frame_time,\n        frame=out_frame,\n    )\n    new_position = self.position.get_position(out_frame)\n\n    return self.__class__(position=new_position, velocity=new_velocity)\n</code></pre>"},{"location":"reference/gps_frames/velocity/#gps_frames.velocity.Velocity.update_frame_time","title":"<code>update_frame_time(new_frame_time)</code>","text":"<p>Change the reference time for the frame.</p> <p>Todo</p> <p>Placeholder This is a placeholder that raises an error. It is not clear if this is needed in the future.</p> <p>Reference frames can be time dependant. This method is used to change the time reference for a reference frame.</p> <p>This method updates the internal representation of the velocity to the frame at the new reference time.</p> <p>Parameters:</p> Name Type Description Default <code>new_frame_time</code> <code>GPSTime</code> <p>The new frame reference time</p> required Source code in <code>gps_frames/velocity.py</code> <pre><code>def update_frame_time(self, new_frame_time: GPSTime) -&gt; None:\n    \"\"\"Change the reference time for the frame.\n\n    !!! quote \"Todo\"\n        Placeholder\n        This is a placeholder that raises an error. It is not clear if\n        this is needed in the future.\n\n    Reference frames can be time dependant. This method is used to change\n    the time reference for a reference frame.\n\n    This method updates the internal representation of the velocity to the\n    frame at the new reference time.\n\n    Parameters\n    ----------\n    new_frame_time : GPSTime\n        The new frame reference time\n\n    \"\"\"\n    raise NotImplementedError(\"Placeholder for to mark future needs\")\n</code></pre>"}]}