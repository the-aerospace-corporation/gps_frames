<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gps_frames.basis API documentation</title>
<meta name="description" content="Reference Frame Basis …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gps_frames.basis</code></h1>
</header>
<section id="section-intro">
<p>Reference Frame Basis.</p>
<p>This submodule is used to define the basis for reference frames.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Reference Frame Basis.

This submodule is used to define the basis for reference frames.

&#34;&#34;&#34;
from __future__ import annotations

import numpy as np
import ruamel.yaml
from numba import jit

from logging import getLogger
from typing import List

from .position import Position
from .vectors import UnitVector, SerializeableVector
from .rotations import Rotation

from gps_time import GPSTime

logger = getLogger(__name__)


def get_eci_basis(time: GPSTime) -&gt; Basis:
    &#34;&#34;&#34;Get the ECI basis.

    Parameters
    ----------
    time : GPSTime
        The time to define the ECI basis

    Returns
    -------
    Basis
        The ECI basis

    &#34;&#34;&#34;
    origin = Position(
        coordinates=np.array([0.0, 0.0, 0.0]), frame_time=time, frame=&#34;ECI&#34;
    )
    x_axis = UnitVector(
        coordinates=np.array([1.0, 0.0, 0.0]), frame_time=time, frame=&#34;ECI&#34;
    )
    y_axis = UnitVector(
        coordinates=np.array([0.0, 1.0, 0.0]), frame_time=time, frame=&#34;ECI&#34;
    )
    z_axis = UnitVector(
        coordinates=np.array([0.0, 0.0, 1.0]), frame_time=time, frame=&#34;ECI&#34;
    )

    return Basis(origin=origin, axis1=x_axis, axis2=y_axis, axis3=z_axis)


def get_ecef_basis(time: GPSTime) -&gt; Basis:
    &#34;&#34;&#34;Get the ECE basis.

    Parameters
    ----------
    time : GPSTime
        The time to define the ECEF basis

    Returns
    -------
    Basis
        The ECEF basis

    &#34;&#34;&#34;
    origin = Position(
        coordinates=np.array([0.0, 0.0, 0.0]), frame_time=time, frame=&#34;ECEF&#34;
    )
    x_axis = UnitVector(
        coordinates=np.array([1.0, 0.0, 0.0]), frame_time=time, frame=&#34;ECEF&#34;
    )
    y_axis = UnitVector(
        coordinates=np.array([0.0, 1.0, 0.0]), frame_time=time, frame=&#34;ECEF&#34;
    )
    z_axis = UnitVector(
        coordinates=np.array([0.0, 0.0, 1.0]), frame_time=time, frame=&#34;ECEF&#34;
    )

    return Basis(origin=origin, axis1=x_axis, axis2=y_axis, axis3=z_axis)


def coordinates_in_basis(position: Position, basis: Basis) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the coordinates of a position in a basis.

    Parameters
    ----------
    position : Position
        The position
    basis : Basis
        The basis to express the position in

    Returns
    -------
    np.ndarray
        A three element array reprenting the coordinates of the position in
        the basis.

    &#34;&#34;&#34;
    origin_frame = basis.origin.frame
    origin_frame_time = basis.origin.frame_time

    # Move the position ot the same frame as the basis
    _position = position.get_position(origin_frame)
    _position.update_frame_time(origin_frame_time)

    # Find the relative position
    rp = _position.coordinates - basis.origin.coordinates

    # Project the relative position onto the basis&#39; axes
    v1 = basis.axes[0].dot_product(rp)
    v2 = basis.axes[1].dot_product(rp)
    v3 = basis.axes[2].dot_product(rp)

    return [v1, v2, v3]


class Basis:
    &#34;&#34;&#34;Basis of a reference frame.

    Attributes
    ----------
    origin : Position
        The origin of the basis
    axes : list
        This is a three element array whose elements are of the `UnitVector`
        type. This represent the axes that make up the basis.

    Raises
    ------
    ValueError
        If any of the following:

        - The origin is in the LLA frame
        - The axes and origin are defined in different frames
        - The axes are not orthogonal
        - The basis is not right-handed

    &#34;&#34;&#34;

    UNSAFE = False
    yaml_tag = &#34;!Basis&#34;

    def __init__(
        self, origin: Position, axis1: UnitVector, axis2: UnitVector, axis3: UnitVector
    ) -&gt; None:
        &#34;&#34;&#34;Object constructor.

        Parameters
        ----------
        origin : Position
            The position of the origin
        axis1 : UnitVector
            The 1-axis (e.g. X)
        axis2 : UnitVector
            The 2-axis (e.g. Y)
        axis3 : UnitVector
            The 3-axis (e.g. Z)

        &#34;&#34;&#34;
        self.origin: Position = origin
        self.axes: List[UnitVector] = [axis1, axis2, axis3]

        if not Basis.UNSAFE:
            self.check_frames()
            self.check_orthogonality()
            self.check_right_handedness()

    @classmethod
    def to_yaml(
        cls, representer: ruamel.yaml.Representer, node: SerializeableVector
    ) -&gt; ruamel.yaml.MappingNode:
        &#34;&#34;&#34;Convert the class into a mapping node for serialzation.

        Takes the attributes of the class and converts them to ScalarNode
        used in a ruamel.yaml MappingNode to dump the object in a specific
        format. This method is called by the ruamel.yaml.YAML object
        when passed to register_class

        Parameters
        ----------
        representer : ruamel.yaml.Representer
            Yaml representer
        node : SerializeableVector
            The instance of the class to serialize

        Returns
        -------
        ruamel.yaml.MappingNode
            A mapping node which describes to the yaml dumper how to serialize
            the object

        &#34;&#34;&#34;
        return representer.represent_mapping(
            cls.yaml_tag,
            {
                &#34;origin&#34;: node.origin,
                &#34;axis1&#34;: node.axes[0],
                &#34;axis2&#34;: node.axes[1],
                &#34;axis3&#34;: node.axes[2],
            },
        )

    @classmethod
    def from_yaml(
        cls: type, constructor: ruamel.yaml.Constructor, node: ruamel.yaml.MappingNode
    ) -&gt; SerializeableVector:
        &#34;&#34;&#34;Construct a class from a MappingNode.

        This method is called when using yaml.load if the
        SerializeableVector class has been registered to the
        ruamel.yaml.YAML object

        Parameters
        ----------
        cls : type
            The type of the class to deserialize
        constructor : ruamel.yaml.Constructor
            The constructor object
        node : ruamel.yaml.MappingNode
            Node created from the yaml parser

        Returns
        -------
        SerializeableVector
            Instance of serialized class

        &#34;&#34;&#34;
        nodes = node.value
        origin = None
        axes = [None, None, None]
        for i in range(len(nodes)):
            node_name = nodes[i][0].value
            if node_name == &#34;axis1&#34;:
                axes[0] = constructor.construct_object(nodes[i][1])
            elif node_name == &#34;axis2&#34;:
                axes[1] = constructor.construct_object(nodes[i][1])
            elif node_name == &#34;axis3&#34;:
                axes[2] = constructor.construct_object(nodes[i][1])
            elif node_name == &#34;origin&#34;:
                origin = constructor.construct_object(nodes[i][1])
        return cls(origin, *axes)

    def check_frames(self) -&gt; None:
        &#34;&#34;&#34;Ensure that the frames are consistent.

        .. note:: LLA Frame
            If the LLA frame is provided for the origin, will attempt to
            convert to the ECEF frame. Will log an error

        Raises
        ------
        ValueError
            If the axes are not all in the same frame as the origin

        &#34;&#34;&#34;
        if self.origin.frame == &#34;LLA&#34;:
            logger.warning(&#34;LLA frame used for basis of origin, ECEF will be used&#34;)
            self.origin.switch_frame(to_frame=&#34;ECEF&#34;)

        origin_frame = self.origin.frame
        origin_frame_time = self.origin.frame_time

        if any([axis.frame != origin_frame for axis in self.axes]):
            raise ValueError(&#34;Not all axes and origin in the same frame&#34;)

        if any([axis.frame_time != origin_frame_time for axis in self.axes]):
            raise ValueError(&#34;Not all axes and origin have same frame time&#34;)

    def check_orthogonality(self, eps: float = 1e-12) -&gt; None:
        &#34;&#34;&#34;Check that the axes are orthogonal.

        Parameters
        ----------
        eps : float, optional
            The amount of allowable numerical error, by default 1e-12

        Raises
        ------
        ValueError
            If the axes are not mutually orthogonal

        &#34;&#34;&#34;
        v1 = self.axes[0].coordinates
        v2 = self.axes[1].coordinates
        v3 = self.axes[2].coordinates

        checks = np.array(
            [np.abs(np.dot(v1, v2)), np.abs(np.dot(v2, v3)), np.abs(np.dot(v3, v1))]
        )
        if any(checks &gt; eps):
            raise ValueError(&#34;Axes are not orthogonal&#34;)

    def check_right_handedness(self, eps: float = 1e-12) -&gt; None:
        &#34;&#34;&#34;Check that the axes are right-handed.

        Parameters
        ----------
        eps : float, optional
            The amount of allowable numerical error, by default 1e-12

        Raises
        ------
        ValueError
            If the basis is not right-handed

        &#34;&#34;&#34;
        Basis.right_hand_numba(
            np.array(
                [
                    self.axes[0].coordinates,
                    self.axes[1].coordinates,
                    self.axes[2].coordinates,
                ]
            )
        )

    @staticmethod
    @jit(nopython=True)
    def right_hand_numba(axes: np.array, eps: float = 1e-12) -&gt; None:

        v1 = axes[0]
        v2 = axes[1]
        v3 = axes[2]

        check1 = np.linalg.norm(np.cross(v1, v2) - v3) &gt; eps
        check2 = np.linalg.norm(np.cross(v2, v3) - v1) &gt; eps
        check3 = np.linalg.norm(np.cross(v3, v1) - v2) &gt; eps

        if np.any(np.array([check1, check2, check3])):
            raise ValueError(&#34;Basis is not right-handed&#34;)

    def __hash__(self):
        &#34;&#34;&#34;Make basis hashable.&#34;&#34;&#34;
        return hash(
            str(hash(self.origin))
            + str(hash(self.axes[0]))
            + str(hash(self.axes[1]))
            + str(hash(self.axes[2]))
        )


def rotate_basis(rotation: Rotation, basis: Basis) -&gt; Basis:
    &#34;&#34;&#34;Rotate a basis about its origin.

    Parameters
    ----------
    rotation : Rotation
        A rotation object
    basis : Basis
        A basis

    Returns
    -------
    Basis
        A basis with the same origin as the input basis, but whose axes are
        rotated according to the given rotation.

    &#34;&#34;&#34;
    v1 = UnitVector(
        rotation.rotate(basis.axes[0].coordinates),
        basis.origin.frame_time,
        basis.origin.frame,
    )
    v2 = UnitVector(
        rotation.rotate(basis.axes[1].coordinates),
        basis.origin.frame_time,
        basis.origin.frame,
    )
    v3 = UnitVector(
        rotation.rotate(basis.axes[2].coordinates),
        basis.origin.frame_time,
        basis.origin.frame,
    )

    return Basis(origin=basis.origin, axis1=v1, axis2=v2, axis3=v3)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gps_frames.basis.coordinates_in_basis"><code class="name flex">
<span>def <span class="ident">coordinates_in_basis</span></span>(<span>position: Position, basis: <a title="gps_frames.basis.Basis" href="#gps_frames.basis.Basis">Basis</a>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Get the coordinates of a position in a basis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>Position</code></dt>
<dd>The position</dd>
<dt><strong><code>basis</code></strong> :&ensp;<code><a title="gps_frames.basis.Basis" href="#gps_frames.basis.Basis">Basis</a></code></dt>
<dd>The basis to express the position in</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>A three element array reprenting the coordinates of the position in
the basis.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coordinates_in_basis(position: Position, basis: Basis) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the coordinates of a position in a basis.

    Parameters
    ----------
    position : Position
        The position
    basis : Basis
        The basis to express the position in

    Returns
    -------
    np.ndarray
        A three element array reprenting the coordinates of the position in
        the basis.

    &#34;&#34;&#34;
    origin_frame = basis.origin.frame
    origin_frame_time = basis.origin.frame_time

    # Move the position ot the same frame as the basis
    _position = position.get_position(origin_frame)
    _position.update_frame_time(origin_frame_time)

    # Find the relative position
    rp = _position.coordinates - basis.origin.coordinates

    # Project the relative position onto the basis&#39; axes
    v1 = basis.axes[0].dot_product(rp)
    v2 = basis.axes[1].dot_product(rp)
    v3 = basis.axes[2].dot_product(rp)

    return [v1, v2, v3]</code></pre>
</details>
</dd>
<dt id="gps_frames.basis.get_ecef_basis"><code class="name flex">
<span>def <span class="ident">get_ecef_basis</span></span>(<span>time: GPSTime) ‑> <a title="gps_frames.basis.Basis" href="#gps_frames.basis.Basis">Basis</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the ECE basis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>GPSTime</code></dt>
<dd>The time to define the ECEF basis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gps_frames.basis.Basis" href="#gps_frames.basis.Basis">Basis</a></code></dt>
<dd>The ECEF basis</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ecef_basis(time: GPSTime) -&gt; Basis:
    &#34;&#34;&#34;Get the ECE basis.

    Parameters
    ----------
    time : GPSTime
        The time to define the ECEF basis

    Returns
    -------
    Basis
        The ECEF basis

    &#34;&#34;&#34;
    origin = Position(
        coordinates=np.array([0.0, 0.0, 0.0]), frame_time=time, frame=&#34;ECEF&#34;
    )
    x_axis = UnitVector(
        coordinates=np.array([1.0, 0.0, 0.0]), frame_time=time, frame=&#34;ECEF&#34;
    )
    y_axis = UnitVector(
        coordinates=np.array([0.0, 1.0, 0.0]), frame_time=time, frame=&#34;ECEF&#34;
    )
    z_axis = UnitVector(
        coordinates=np.array([0.0, 0.0, 1.0]), frame_time=time, frame=&#34;ECEF&#34;
    )

    return Basis(origin=origin, axis1=x_axis, axis2=y_axis, axis3=z_axis)</code></pre>
</details>
</dd>
<dt id="gps_frames.basis.get_eci_basis"><code class="name flex">
<span>def <span class="ident">get_eci_basis</span></span>(<span>time: GPSTime) ‑> <a title="gps_frames.basis.Basis" href="#gps_frames.basis.Basis">Basis</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the ECI basis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>GPSTime</code></dt>
<dd>The time to define the ECI basis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gps_frames.basis.Basis" href="#gps_frames.basis.Basis">Basis</a></code></dt>
<dd>The ECI basis</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_eci_basis(time: GPSTime) -&gt; Basis:
    &#34;&#34;&#34;Get the ECI basis.

    Parameters
    ----------
    time : GPSTime
        The time to define the ECI basis

    Returns
    -------
    Basis
        The ECI basis

    &#34;&#34;&#34;
    origin = Position(
        coordinates=np.array([0.0, 0.0, 0.0]), frame_time=time, frame=&#34;ECI&#34;
    )
    x_axis = UnitVector(
        coordinates=np.array([1.0, 0.0, 0.0]), frame_time=time, frame=&#34;ECI&#34;
    )
    y_axis = UnitVector(
        coordinates=np.array([0.0, 1.0, 0.0]), frame_time=time, frame=&#34;ECI&#34;
    )
    z_axis = UnitVector(
        coordinates=np.array([0.0, 0.0, 1.0]), frame_time=time, frame=&#34;ECI&#34;
    )

    return Basis(origin=origin, axis1=x_axis, axis2=y_axis, axis3=z_axis)</code></pre>
</details>
</dd>
<dt id="gps_frames.basis.rotate_basis"><code class="name flex">
<span>def <span class="ident">rotate_basis</span></span>(<span>rotation: Rotation, basis: <a title="gps_frames.basis.Basis" href="#gps_frames.basis.Basis">Basis</a>) ‑> <a title="gps_frames.basis.Basis" href="#gps_frames.basis.Basis">Basis</a></span>
</code></dt>
<dd>
<div class="desc"><p>Rotate a basis about its origin.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rotation</code></strong> :&ensp;<code>Rotation</code></dt>
<dd>A rotation object</dd>
<dt><strong><code>basis</code></strong> :&ensp;<code><a title="gps_frames.basis.Basis" href="#gps_frames.basis.Basis">Basis</a></code></dt>
<dd>A basis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gps_frames.basis.Basis" href="#gps_frames.basis.Basis">Basis</a></code></dt>
<dd>A basis with the same origin as the input basis, but whose axes are
rotated according to the given rotation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_basis(rotation: Rotation, basis: Basis) -&gt; Basis:
    &#34;&#34;&#34;Rotate a basis about its origin.

    Parameters
    ----------
    rotation : Rotation
        A rotation object
    basis : Basis
        A basis

    Returns
    -------
    Basis
        A basis with the same origin as the input basis, but whose axes are
        rotated according to the given rotation.

    &#34;&#34;&#34;
    v1 = UnitVector(
        rotation.rotate(basis.axes[0].coordinates),
        basis.origin.frame_time,
        basis.origin.frame,
    )
    v2 = UnitVector(
        rotation.rotate(basis.axes[1].coordinates),
        basis.origin.frame_time,
        basis.origin.frame,
    )
    v3 = UnitVector(
        rotation.rotate(basis.axes[2].coordinates),
        basis.origin.frame_time,
        basis.origin.frame,
    )

    return Basis(origin=basis.origin, axis1=v1, axis2=v2, axis3=v3)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gps_frames.basis.Basis"><code class="flex name class">
<span>class <span class="ident">Basis</span></span>
<span>(</span><span>origin: Position, axis1: UnitVector, axis2: UnitVector, axis3: UnitVector)</span>
</code></dt>
<dd>
<div class="desc"><p>Basis of a reference frame.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>origin</code></strong> :&ensp;<code>Position</code></dt>
<dd>The origin of the basis</dd>
<dt><strong><code>axes</code></strong> :&ensp;<code>list</code></dt>
<dd>This is a three element array whose elements are of the <code>UnitVector</code>
type. This represent the axes that make up the basis.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>
<p>If any of the following:</p>
<ul>
<li>The origin is in the LLA frame</li>
<li>The axes and origin are defined in different frames</li>
<li>The axes are not orthogonal</li>
<li>The basis is not right-handed</li>
</ul>
</dd>
</dl>
<p>Object constructor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>origin</code></strong> :&ensp;<code>Position</code></dt>
<dd>The position of the origin</dd>
<dt><strong><code>axis1</code></strong> :&ensp;<code>UnitVector</code></dt>
<dd>The 1-axis (e.g. X)</dd>
<dt><strong><code>axis2</code></strong> :&ensp;<code>UnitVector</code></dt>
<dd>The 2-axis (e.g. Y)</dd>
<dt><strong><code>axis3</code></strong> :&ensp;<code>UnitVector</code></dt>
<dd>The 3-axis (e.g. Z)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Basis:
    &#34;&#34;&#34;Basis of a reference frame.

    Attributes
    ----------
    origin : Position
        The origin of the basis
    axes : list
        This is a three element array whose elements are of the `UnitVector`
        type. This represent the axes that make up the basis.

    Raises
    ------
    ValueError
        If any of the following:

        - The origin is in the LLA frame
        - The axes and origin are defined in different frames
        - The axes are not orthogonal
        - The basis is not right-handed

    &#34;&#34;&#34;

    UNSAFE = False
    yaml_tag = &#34;!Basis&#34;

    def __init__(
        self, origin: Position, axis1: UnitVector, axis2: UnitVector, axis3: UnitVector
    ) -&gt; None:
        &#34;&#34;&#34;Object constructor.

        Parameters
        ----------
        origin : Position
            The position of the origin
        axis1 : UnitVector
            The 1-axis (e.g. X)
        axis2 : UnitVector
            The 2-axis (e.g. Y)
        axis3 : UnitVector
            The 3-axis (e.g. Z)

        &#34;&#34;&#34;
        self.origin: Position = origin
        self.axes: List[UnitVector] = [axis1, axis2, axis3]

        if not Basis.UNSAFE:
            self.check_frames()
            self.check_orthogonality()
            self.check_right_handedness()

    @classmethod
    def to_yaml(
        cls, representer: ruamel.yaml.Representer, node: SerializeableVector
    ) -&gt; ruamel.yaml.MappingNode:
        &#34;&#34;&#34;Convert the class into a mapping node for serialzation.

        Takes the attributes of the class and converts them to ScalarNode
        used in a ruamel.yaml MappingNode to dump the object in a specific
        format. This method is called by the ruamel.yaml.YAML object
        when passed to register_class

        Parameters
        ----------
        representer : ruamel.yaml.Representer
            Yaml representer
        node : SerializeableVector
            The instance of the class to serialize

        Returns
        -------
        ruamel.yaml.MappingNode
            A mapping node which describes to the yaml dumper how to serialize
            the object

        &#34;&#34;&#34;
        return representer.represent_mapping(
            cls.yaml_tag,
            {
                &#34;origin&#34;: node.origin,
                &#34;axis1&#34;: node.axes[0],
                &#34;axis2&#34;: node.axes[1],
                &#34;axis3&#34;: node.axes[2],
            },
        )

    @classmethod
    def from_yaml(
        cls: type, constructor: ruamel.yaml.Constructor, node: ruamel.yaml.MappingNode
    ) -&gt; SerializeableVector:
        &#34;&#34;&#34;Construct a class from a MappingNode.

        This method is called when using yaml.load if the
        SerializeableVector class has been registered to the
        ruamel.yaml.YAML object

        Parameters
        ----------
        cls : type
            The type of the class to deserialize
        constructor : ruamel.yaml.Constructor
            The constructor object
        node : ruamel.yaml.MappingNode
            Node created from the yaml parser

        Returns
        -------
        SerializeableVector
            Instance of serialized class

        &#34;&#34;&#34;
        nodes = node.value
        origin = None
        axes = [None, None, None]
        for i in range(len(nodes)):
            node_name = nodes[i][0].value
            if node_name == &#34;axis1&#34;:
                axes[0] = constructor.construct_object(nodes[i][1])
            elif node_name == &#34;axis2&#34;:
                axes[1] = constructor.construct_object(nodes[i][1])
            elif node_name == &#34;axis3&#34;:
                axes[2] = constructor.construct_object(nodes[i][1])
            elif node_name == &#34;origin&#34;:
                origin = constructor.construct_object(nodes[i][1])
        return cls(origin, *axes)

    def check_frames(self) -&gt; None:
        &#34;&#34;&#34;Ensure that the frames are consistent.

        .. note:: LLA Frame
            If the LLA frame is provided for the origin, will attempt to
            convert to the ECEF frame. Will log an error

        Raises
        ------
        ValueError
            If the axes are not all in the same frame as the origin

        &#34;&#34;&#34;
        if self.origin.frame == &#34;LLA&#34;:
            logger.warning(&#34;LLA frame used for basis of origin, ECEF will be used&#34;)
            self.origin.switch_frame(to_frame=&#34;ECEF&#34;)

        origin_frame = self.origin.frame
        origin_frame_time = self.origin.frame_time

        if any([axis.frame != origin_frame for axis in self.axes]):
            raise ValueError(&#34;Not all axes and origin in the same frame&#34;)

        if any([axis.frame_time != origin_frame_time for axis in self.axes]):
            raise ValueError(&#34;Not all axes and origin have same frame time&#34;)

    def check_orthogonality(self, eps: float = 1e-12) -&gt; None:
        &#34;&#34;&#34;Check that the axes are orthogonal.

        Parameters
        ----------
        eps : float, optional
            The amount of allowable numerical error, by default 1e-12

        Raises
        ------
        ValueError
            If the axes are not mutually orthogonal

        &#34;&#34;&#34;
        v1 = self.axes[0].coordinates
        v2 = self.axes[1].coordinates
        v3 = self.axes[2].coordinates

        checks = np.array(
            [np.abs(np.dot(v1, v2)), np.abs(np.dot(v2, v3)), np.abs(np.dot(v3, v1))]
        )
        if any(checks &gt; eps):
            raise ValueError(&#34;Axes are not orthogonal&#34;)

    def check_right_handedness(self, eps: float = 1e-12) -&gt; None:
        &#34;&#34;&#34;Check that the axes are right-handed.

        Parameters
        ----------
        eps : float, optional
            The amount of allowable numerical error, by default 1e-12

        Raises
        ------
        ValueError
            If the basis is not right-handed

        &#34;&#34;&#34;
        Basis.right_hand_numba(
            np.array(
                [
                    self.axes[0].coordinates,
                    self.axes[1].coordinates,
                    self.axes[2].coordinates,
                ]
            )
        )

    @staticmethod
    @jit(nopython=True)
    def right_hand_numba(axes: np.array, eps: float = 1e-12) -&gt; None:

        v1 = axes[0]
        v2 = axes[1]
        v3 = axes[2]

        check1 = np.linalg.norm(np.cross(v1, v2) - v3) &gt; eps
        check2 = np.linalg.norm(np.cross(v2, v3) - v1) &gt; eps
        check3 = np.linalg.norm(np.cross(v3, v1) - v2) &gt; eps

        if np.any(np.array([check1, check2, check3])):
            raise ValueError(&#34;Basis is not right-handed&#34;)

    def __hash__(self):
        &#34;&#34;&#34;Make basis hashable.&#34;&#34;&#34;
        return hash(
            str(hash(self.origin))
            + str(hash(self.axes[0]))
            + str(hash(self.axes[1]))
            + str(hash(self.axes[2]))
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gps_frames.basis.Basis.UNSAFE"><code class="name">var <span class="ident">UNSAFE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gps_frames.basis.Basis.yaml_tag"><code class="name">var <span class="ident">yaml_tag</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="gps_frames.basis.Basis.from_yaml"><code class="name flex">
<span>def <span class="ident">from_yaml</span></span>(<span>constructor: ruamel.yaml.Constructor, node: ruamel.yaml.MappingNode) ‑> <a title="gps_frames.vectors.SerializeableVector" href="vectors.html#gps_frames.vectors.SerializeableVector">SerializeableVector</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct a class from a MappingNode.</p>
<p>This method is called when using yaml.load if the
SerializeableVector class has been registered to the
ruamel.yaml.YAML object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cls</code></strong> :&ensp;<code>type</code></dt>
<dd>The type of the class to deserialize</dd>
<dt><strong><code>constructor</code></strong> :&ensp;<code>ruamel.yaml.Constructor</code></dt>
<dd>The constructor object</dd>
<dt><strong><code>node</code></strong> :&ensp;<code>ruamel.yaml.MappingNode</code></dt>
<dd>Node created from the yaml parser</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SerializeableVector</code></dt>
<dd>Instance of serialized class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_yaml(
    cls: type, constructor: ruamel.yaml.Constructor, node: ruamel.yaml.MappingNode
) -&gt; SerializeableVector:
    &#34;&#34;&#34;Construct a class from a MappingNode.

    This method is called when using yaml.load if the
    SerializeableVector class has been registered to the
    ruamel.yaml.YAML object

    Parameters
    ----------
    cls : type
        The type of the class to deserialize
    constructor : ruamel.yaml.Constructor
        The constructor object
    node : ruamel.yaml.MappingNode
        Node created from the yaml parser

    Returns
    -------
    SerializeableVector
        Instance of serialized class

    &#34;&#34;&#34;
    nodes = node.value
    origin = None
    axes = [None, None, None]
    for i in range(len(nodes)):
        node_name = nodes[i][0].value
        if node_name == &#34;axis1&#34;:
            axes[0] = constructor.construct_object(nodes[i][1])
        elif node_name == &#34;axis2&#34;:
            axes[1] = constructor.construct_object(nodes[i][1])
        elif node_name == &#34;axis3&#34;:
            axes[2] = constructor.construct_object(nodes[i][1])
        elif node_name == &#34;origin&#34;:
            origin = constructor.construct_object(nodes[i][1])
    return cls(origin, *axes)</code></pre>
</details>
</dd>
<dt id="gps_frames.basis.Basis.right_hand_numba"><code class="name flex">
<span>def <span class="ident">right_hand_numba</span></span>(<span>axes: np.array, eps: float = 1e-12) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@jit(nopython=True)
def right_hand_numba(axes: np.array, eps: float = 1e-12) -&gt; None:

    v1 = axes[0]
    v2 = axes[1]
    v3 = axes[2]

    check1 = np.linalg.norm(np.cross(v1, v2) - v3) &gt; eps
    check2 = np.linalg.norm(np.cross(v2, v3) - v1) &gt; eps
    check3 = np.linalg.norm(np.cross(v3, v1) - v2) &gt; eps

    if np.any(np.array([check1, check2, check3])):
        raise ValueError(&#34;Basis is not right-handed&#34;)</code></pre>
</details>
</dd>
<dt id="gps_frames.basis.Basis.to_yaml"><code class="name flex">
<span>def <span class="ident">to_yaml</span></span>(<span>representer: ruamel.yaml.Representer, node: SerializeableVector) ‑> ruamel.yaml.nodes.MappingNode</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the class into a mapping node for serialzation.</p>
<p>Takes the attributes of the class and converts them to ScalarNode
used in a ruamel.yaml MappingNode to dump the object in a specific
format. This method is called by the ruamel.yaml.YAML object
when passed to register_class</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>representer</code></strong> :&ensp;<code>ruamel.yaml.Representer</code></dt>
<dd>Yaml representer</dd>
<dt><strong><code>node</code></strong> :&ensp;<code>SerializeableVector</code></dt>
<dd>The instance of the class to serialize</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ruamel.yaml.MappingNode</code></dt>
<dd>A mapping node which describes to the yaml dumper how to serialize
the object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def to_yaml(
    cls, representer: ruamel.yaml.Representer, node: SerializeableVector
) -&gt; ruamel.yaml.MappingNode:
    &#34;&#34;&#34;Convert the class into a mapping node for serialzation.

    Takes the attributes of the class and converts them to ScalarNode
    used in a ruamel.yaml MappingNode to dump the object in a specific
    format. This method is called by the ruamel.yaml.YAML object
    when passed to register_class

    Parameters
    ----------
    representer : ruamel.yaml.Representer
        Yaml representer
    node : SerializeableVector
        The instance of the class to serialize

    Returns
    -------
    ruamel.yaml.MappingNode
        A mapping node which describes to the yaml dumper how to serialize
        the object

    &#34;&#34;&#34;
    return representer.represent_mapping(
        cls.yaml_tag,
        {
            &#34;origin&#34;: node.origin,
            &#34;axis1&#34;: node.axes[0],
            &#34;axis2&#34;: node.axes[1],
            &#34;axis3&#34;: node.axes[2],
        },
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gps_frames.basis.Basis.check_frames"><code class="name flex">
<span>def <span class="ident">check_frames</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure that the frames are consistent.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;LLA Frame</p>
<p>If the LLA frame is provided for the origin, will attempt to
convert to the ECEF frame. Will log an error</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the axes are not all in the same frame as the origin</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_frames(self) -&gt; None:
    &#34;&#34;&#34;Ensure that the frames are consistent.

    .. note:: LLA Frame
        If the LLA frame is provided for the origin, will attempt to
        convert to the ECEF frame. Will log an error

    Raises
    ------
    ValueError
        If the axes are not all in the same frame as the origin

    &#34;&#34;&#34;
    if self.origin.frame == &#34;LLA&#34;:
        logger.warning(&#34;LLA frame used for basis of origin, ECEF will be used&#34;)
        self.origin.switch_frame(to_frame=&#34;ECEF&#34;)

    origin_frame = self.origin.frame
    origin_frame_time = self.origin.frame_time

    if any([axis.frame != origin_frame for axis in self.axes]):
        raise ValueError(&#34;Not all axes and origin in the same frame&#34;)

    if any([axis.frame_time != origin_frame_time for axis in self.axes]):
        raise ValueError(&#34;Not all axes and origin have same frame time&#34;)</code></pre>
</details>
</dd>
<dt id="gps_frames.basis.Basis.check_orthogonality"><code class="name flex">
<span>def <span class="ident">check_orthogonality</span></span>(<span>self, eps: float = 1e-12) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Check that the axes are orthogonal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The amount of allowable numerical error, by default 1e-12</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the axes are not mutually orthogonal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_orthogonality(self, eps: float = 1e-12) -&gt; None:
    &#34;&#34;&#34;Check that the axes are orthogonal.

    Parameters
    ----------
    eps : float, optional
        The amount of allowable numerical error, by default 1e-12

    Raises
    ------
    ValueError
        If the axes are not mutually orthogonal

    &#34;&#34;&#34;
    v1 = self.axes[0].coordinates
    v2 = self.axes[1].coordinates
    v3 = self.axes[2].coordinates

    checks = np.array(
        [np.abs(np.dot(v1, v2)), np.abs(np.dot(v2, v3)), np.abs(np.dot(v3, v1))]
    )
    if any(checks &gt; eps):
        raise ValueError(&#34;Axes are not orthogonal&#34;)</code></pre>
</details>
</dd>
<dt id="gps_frames.basis.Basis.check_right_handedness"><code class="name flex">
<span>def <span class="ident">check_right_handedness</span></span>(<span>self, eps: float = 1e-12) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Check that the axes are right-handed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The amount of allowable numerical error, by default 1e-12</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the basis is not right-handed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_right_handedness(self, eps: float = 1e-12) -&gt; None:
    &#34;&#34;&#34;Check that the axes are right-handed.

    Parameters
    ----------
    eps : float, optional
        The amount of allowable numerical error, by default 1e-12

    Raises
    ------
    ValueError
        If the basis is not right-handed

    &#34;&#34;&#34;
    Basis.right_hand_numba(
        np.array(
            [
                self.axes[0].coordinates,
                self.axes[1].coordinates,
                self.axes[2].coordinates,
            ]
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gps_frames" href="index.html">gps_frames</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gps_frames.basis.coordinates_in_basis" href="#gps_frames.basis.coordinates_in_basis">coordinates_in_basis</a></code></li>
<li><code><a title="gps_frames.basis.get_ecef_basis" href="#gps_frames.basis.get_ecef_basis">get_ecef_basis</a></code></li>
<li><code><a title="gps_frames.basis.get_eci_basis" href="#gps_frames.basis.get_eci_basis">get_eci_basis</a></code></li>
<li><code><a title="gps_frames.basis.rotate_basis" href="#gps_frames.basis.rotate_basis">rotate_basis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gps_frames.basis.Basis" href="#gps_frames.basis.Basis">Basis</a></code></h4>
<ul class="">
<li><code><a title="gps_frames.basis.Basis.UNSAFE" href="#gps_frames.basis.Basis.UNSAFE">UNSAFE</a></code></li>
<li><code><a title="gps_frames.basis.Basis.check_frames" href="#gps_frames.basis.Basis.check_frames">check_frames</a></code></li>
<li><code><a title="gps_frames.basis.Basis.check_orthogonality" href="#gps_frames.basis.Basis.check_orthogonality">check_orthogonality</a></code></li>
<li><code><a title="gps_frames.basis.Basis.check_right_handedness" href="#gps_frames.basis.Basis.check_right_handedness">check_right_handedness</a></code></li>
<li><code><a title="gps_frames.basis.Basis.from_yaml" href="#gps_frames.basis.Basis.from_yaml">from_yaml</a></code></li>
<li><code><a title="gps_frames.basis.Basis.right_hand_numba" href="#gps_frames.basis.Basis.right_hand_numba">right_hand_numba</a></code></li>
<li><code><a title="gps_frames.basis.Basis.to_yaml" href="#gps_frames.basis.Basis.to_yaml">to_yaml</a></code></li>
<li><code><a title="gps_frames.basis.Basis.yaml_tag" href="#gps_frames.basis.Basis.yaml_tag">yaml_tag</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>