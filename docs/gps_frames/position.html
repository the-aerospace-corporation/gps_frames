<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gps_frames.position API documentation</title>
<meta name="description" content="Positions in reference frames â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gps_frames.position</code></h1>
</header>
<section id="section-intro">
<p>Positions in reference frames.</p>
<p>The purpose of this submodule is to provide a representation for the position
of objects and tools to manipulate the positions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Positions in reference frames.

The purpose of this submodule is to provide a representation for the position
of objects and tools to manipulate the positions.

&#34;&#34;&#34;
from __future__ import annotations

import numpy as np
from dataclasses import dataclass

from . import transforms as trans
from .parameters import GeoidData, EarthParam
from .vectors import Vector, SerializeableVector

from gps_time import GPSTime


def distance(position1: Position, position2: Position) -&gt; float:
    &#34;&#34;&#34;Compute the distance between two positions.

    This function is used to calculate the distance between two positions. To
    do this, it first computes the positions in their ECEF reference frames
    (for their frame refer times). It then rotates the ECEF frame of
    `position2` into the ECEF frame of `position1`. From there, it simply
    takes the 2-norm of the difference of the position coordinates.

    Although the calculation of distance is done in the ECEF frame, the
    distance between two points is the same regardless of which frames are
    used.

    Parameters
    ----------
    position1 : Position
        A Position
    position2 : Position
        Another Position

    Returns
    -------
    float
        The distance between `position1` and `position2`

    &#34;&#34;&#34;
    # Get both positions in the ECEF frame
    eci_position1 = position1.get_position(&#34;ECI&#34;)
    eci_position2 = position2.get_position(&#34;ECI&#34;)

    # Rotate the second into the frame of the first
    eci_position2.update_frame_time(eci_position1.frame_time)

    distance_vector = eci_position1.coordinates - eci_position2.coordinates

    return np.linalg.norm(distance_vector)


@dataclass(eq=False)
class Position(SerializeableVector):
    &#34;&#34;&#34;Represent a position in multiple frames.&#34;&#34;&#34;

    yaml_tag = &#34;!SerializeableVector.Position&#34;

    def __post_init__(self) -&gt; None:
        &#34;&#34;&#34;Check for proper coordinate shape.&#34;&#34;&#34;
        if len(np.shape(self.coordinates)) == 2:
            self.coordinates = np.reshape(self.coordinates, 3)
        elif len(np.shape(self.coordinates)) &gt; 2:
            raise ValueError(&#34;Too many dimensions for position&#34;)

    def get_position(self, out_frame: str) -&gt; Position:
        &#34;&#34;&#34;Get a position object in new frame.

        .. note:: New Object Created on Output
            This function returns a new position object. It does not change
            the reference frame used in this object. Use `switch_frame()` to
            change the frame of the object.

        Parameters
        ----------
        out_frame : str
            The frame to output the position in

        Returns
        -------
        Position
            The position expressed in a new frame

        See Also
        --------
        switch_frame: Change the frame that the position is interally
            expressed in

        &#34;&#34;&#34;
        new_coordinates = trans.position_transform(
            self.frame, out_frame, self.coordinates, self.frame_time
        )

        return self.__class__(new_coordinates, self.frame_time, out_frame)

    def switch_frame(self, to_frame: str) -&gt; None:
        &#34;&#34;&#34;Change the frame used to store this position internally.

        Parameters
        ----------
        to_frame : str
            The desired new frame

        &#34;&#34;&#34;
        new_coordinates = trans.position_transform(
            self.frame, to_frame, self.coordinates, self.frame_time
        )

        self.coordinates = new_coordinates
        self.frame = to_frame

    def update_frame_time(self, new_frame_time: GPSTime) -&gt; None:
        &#34;&#34;&#34;Change the reference time for the frame.

        Reference frames can be time dependant. This method is used to change
        the time reference for a reference frame.

        This method updates the internal representation of the position to the
        frame at the new reference time.

        Parameters
        ----------
        new_frame_time : GPSTime
            The new frame reference time

        &#34;&#34;&#34;
        coordinates = self.coordinates
        if self.frame == &#34;ECI&#34;:
            delta_weeks = new_frame_time.week_number - self.frame_time.week_number

            self.coordinates = trans.add_weeks_eci(delta_weeks, coordinates)
            self.frame_time = new_frame_time

        elif self.frame == &#34;ECEF&#34;:
            self.coordinates = trans.rotate_ecef(
                self.frame_time, new_frame_time, coordinates
            )
            self.frame_time = new_frame_time

        elif self.frame == &#34;LLA&#34;:
            self.switch_frame(&#34;ECEF&#34;)
            coordinates = self.coordinates
            self.coordinates = trans.rotate_ecef(
                self.frame_time, new_frame_time, coordinates
            )
            self.frame_time = new_frame_time

            self.switch_frame(&#34;LLA&#34;)

    def get_altitude_msl(self) -&gt; float:
        &#34;&#34;&#34;Get the Altitude above Mean Sea Level.

        Returns
        -------
        float
            The altitude above mean sea level

        &#34;&#34;&#34;
        lla = trans.position_transform(
            self.frame, &#34;LLA&#34;, self.coordinates, self.frame_time
        )

        geoid_height = GeoidData.get_geoid_height(lla[0], lla[1])

        return lla[2] - geoid_height

    def get_altitude_hae(self) -&gt; float:
        &#34;&#34;&#34;Get the altitude, height above ellipsoid.

        Returns
        -------
        float
            The height above ellipsoid

        &#34;&#34;&#34;
        lla = trans.position_transform(
            self.frame, &#34;LLA&#34;, self.coordinates, self.frame_time
        )

        return lla[2]

    def get_radius(self) -&gt; float:
        &#34;&#34;&#34;Get the radius of the position.

        Get the radius of the position, i.e. the distance from the position to
        the center of the Earth

        Returns
        -------
        float
            The distance to the center of the Earth

        &#34;&#34;&#34;
        ecef = trans.position_transform(
            self.frame, &#34;ECEF&#34;, self.coordinates, self.frame_time
        )

        return np.linalg.norm(ecef)

    def get_altitude_spherical(self) -&gt; float:
        &#34;&#34;&#34;Get the altitude above the spherical Earth.

        Get the altitude for the position if the Earth was a perfect sphere.
        This is done by subtracting the radius of the Earth from the value
        returned by get_radius() method.

        Returns
        -------
        float
            The altitude above the spherical Earth

        &#34;&#34;&#34;
        return self.get_radius() - EarthParam.r_e

    def __hash__(self):
        &#34;&#34;&#34;Make position hashable.&#34;&#34;&#34;
        return super().__hash__()

    @classmethod
    def from_vector(cls, vector: Vector) -&gt; Position:
        &#34;&#34;&#34;Create a position from a vector.

        Parameters
        ----------
        vector : Vector
            The vector

        Returns
        -------
        Position
            The vector represented as a position

        &#34;&#34;&#34;
        return cls(
            coordinates=vector.coordinates,
            frame_time=vector.frame_time,
            frame=vector.frame,
        )

    def to_vector(self) -&gt; Vector:
        &#34;&#34;&#34;Recast Position as a Vector.

        Returns
        -------
        Vector
            New vector

        &#34;&#34;&#34;
        return Vector(
            coordinates=self.coordinates, frame_time=self.frame_time, frame=self.frame
        )

    def __eq__(self, other: object) -&gt; bool:
        &#34;&#34;&#34;Equality Comparision.

        Parameters
        ----------
        other : Position
            Another position

        Returns
        -------
        bool
            If the distance between the positions is less than 1e-6

        Raises
        ------
        TypeError
            If the other value is not a Position

        &#34;&#34;&#34;
        if not isinstance(other, self.__class__):
            raise TypeError(&#34;Equality only defined between two Positions&#34;)

        eps = 1e-6

        return distance(self, other) &lt; eps

    def __add__(self, other: Vector) -&gt; Position:
        &#34;&#34;&#34;Add a vector to a position.

        Parameters
        ----------
        other : Vector
            Vector to add

        Returns
        -------
        Position
            New position

        Raises
        ------
        TypeError
            Other is not a vector

        &#34;&#34;&#34;
        if not isinstance(other, Vector):
            raise TypeError(&#34;other must be a vector&#34;)

        vec1 = self.to_vector()

        new_vec = vec1 + other

        return self.from_vector(new_vec)

    def __sub__(self, other: Vector) -&gt; Position:
        &#34;&#34;&#34;Subtract a vector from a position.

        Parameters
        ----------
        other : Vector
            Vector to subtract

        Returns
        -------
        Position
            New position

        Raises
        ------
        TypeError
            If other is not a vector
        &#34;&#34;&#34;
        if not isinstance(other, Vector):
            raise TypeError(&#34;other must be a vector&#34;)

        vec1 = self.to_vector()

        new_vec = vec1 - other

        return self.from_vector(new_vec)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gps_frames.position.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>position1:Â <a title="gps_frames.position.Position" href="#gps_frames.position.Position">Position</a>, position2:Â <a title="gps_frames.position.Position" href="#gps_frames.position.Position">Position</a>) â€‘>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the distance between two positions.</p>
<p>This function is used to calculate the distance between two positions. To
do this, it first computes the positions in their ECEF reference frames
(for their frame refer times). It then rotates the ECEF frame of
<code>position2</code> into the ECEF frame of <code>position1</code>. From there, it simply
takes the 2-norm of the difference of the position coordinates.</p>
<p>Although the calculation of distance is done in the ECEF frame, the
distance between two points is the same regardless of which frames are
used.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position1</code></strong> :&ensp;<code><a title="gps_frames.position.Position" href="#gps_frames.position.Position">Position</a></code></dt>
<dd>A Position</dd>
<dt><strong><code>position2</code></strong> :&ensp;<code><a title="gps_frames.position.Position" href="#gps_frames.position.Position">Position</a></code></dt>
<dd>Another Position</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The distance between <code>position1</code> and <code>position2</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance(position1: Position, position2: Position) -&gt; float:
    &#34;&#34;&#34;Compute the distance between two positions.

    This function is used to calculate the distance between two positions. To
    do this, it first computes the positions in their ECEF reference frames
    (for their frame refer times). It then rotates the ECEF frame of
    `position2` into the ECEF frame of `position1`. From there, it simply
    takes the 2-norm of the difference of the position coordinates.

    Although the calculation of distance is done in the ECEF frame, the
    distance between two points is the same regardless of which frames are
    used.

    Parameters
    ----------
    position1 : Position
        A Position
    position2 : Position
        Another Position

    Returns
    -------
    float
        The distance between `position1` and `position2`

    &#34;&#34;&#34;
    # Get both positions in the ECEF frame
    eci_position1 = position1.get_position(&#34;ECI&#34;)
    eci_position2 = position2.get_position(&#34;ECI&#34;)

    # Rotate the second into the frame of the first
    eci_position2.update_frame_time(eci_position1.frame_time)

    distance_vector = eci_position1.coordinates - eci_position2.coordinates

    return np.linalg.norm(distance_vector)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gps_frames.position.Position"><code class="flex name class">
<span>class <span class="ident">Position</span></span>
<span>(</span><span>coordinates:Â np.ndarray, frame_time:Â GPSTime, frame:Â str, yaml_tag:Â strÂ =Â '!SerializeableVector')</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a position in multiple frames.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Position(SerializeableVector):
    &#34;&#34;&#34;Represent a position in multiple frames.&#34;&#34;&#34;

    yaml_tag = &#34;!SerializeableVector.Position&#34;

    def __post_init__(self) -&gt; None:
        &#34;&#34;&#34;Check for proper coordinate shape.&#34;&#34;&#34;
        if len(np.shape(self.coordinates)) == 2:
            self.coordinates = np.reshape(self.coordinates, 3)
        elif len(np.shape(self.coordinates)) &gt; 2:
            raise ValueError(&#34;Too many dimensions for position&#34;)

    def get_position(self, out_frame: str) -&gt; Position:
        &#34;&#34;&#34;Get a position object in new frame.

        .. note:: New Object Created on Output
            This function returns a new position object. It does not change
            the reference frame used in this object. Use `switch_frame()` to
            change the frame of the object.

        Parameters
        ----------
        out_frame : str
            The frame to output the position in

        Returns
        -------
        Position
            The position expressed in a new frame

        See Also
        --------
        switch_frame: Change the frame that the position is interally
            expressed in

        &#34;&#34;&#34;
        new_coordinates = trans.position_transform(
            self.frame, out_frame, self.coordinates, self.frame_time
        )

        return self.__class__(new_coordinates, self.frame_time, out_frame)

    def switch_frame(self, to_frame: str) -&gt; None:
        &#34;&#34;&#34;Change the frame used to store this position internally.

        Parameters
        ----------
        to_frame : str
            The desired new frame

        &#34;&#34;&#34;
        new_coordinates = trans.position_transform(
            self.frame, to_frame, self.coordinates, self.frame_time
        )

        self.coordinates = new_coordinates
        self.frame = to_frame

    def update_frame_time(self, new_frame_time: GPSTime) -&gt; None:
        &#34;&#34;&#34;Change the reference time for the frame.

        Reference frames can be time dependant. This method is used to change
        the time reference for a reference frame.

        This method updates the internal representation of the position to the
        frame at the new reference time.

        Parameters
        ----------
        new_frame_time : GPSTime
            The new frame reference time

        &#34;&#34;&#34;
        coordinates = self.coordinates
        if self.frame == &#34;ECI&#34;:
            delta_weeks = new_frame_time.week_number - self.frame_time.week_number

            self.coordinates = trans.add_weeks_eci(delta_weeks, coordinates)
            self.frame_time = new_frame_time

        elif self.frame == &#34;ECEF&#34;:
            self.coordinates = trans.rotate_ecef(
                self.frame_time, new_frame_time, coordinates
            )
            self.frame_time = new_frame_time

        elif self.frame == &#34;LLA&#34;:
            self.switch_frame(&#34;ECEF&#34;)
            coordinates = self.coordinates
            self.coordinates = trans.rotate_ecef(
                self.frame_time, new_frame_time, coordinates
            )
            self.frame_time = new_frame_time

            self.switch_frame(&#34;LLA&#34;)

    def get_altitude_msl(self) -&gt; float:
        &#34;&#34;&#34;Get the Altitude above Mean Sea Level.

        Returns
        -------
        float
            The altitude above mean sea level

        &#34;&#34;&#34;
        lla = trans.position_transform(
            self.frame, &#34;LLA&#34;, self.coordinates, self.frame_time
        )

        geoid_height = GeoidData.get_geoid_height(lla[0], lla[1])

        return lla[2] - geoid_height

    def get_altitude_hae(self) -&gt; float:
        &#34;&#34;&#34;Get the altitude, height above ellipsoid.

        Returns
        -------
        float
            The height above ellipsoid

        &#34;&#34;&#34;
        lla = trans.position_transform(
            self.frame, &#34;LLA&#34;, self.coordinates, self.frame_time
        )

        return lla[2]

    def get_radius(self) -&gt; float:
        &#34;&#34;&#34;Get the radius of the position.

        Get the radius of the position, i.e. the distance from the position to
        the center of the Earth

        Returns
        -------
        float
            The distance to the center of the Earth

        &#34;&#34;&#34;
        ecef = trans.position_transform(
            self.frame, &#34;ECEF&#34;, self.coordinates, self.frame_time
        )

        return np.linalg.norm(ecef)

    def get_altitude_spherical(self) -&gt; float:
        &#34;&#34;&#34;Get the altitude above the spherical Earth.

        Get the altitude for the position if the Earth was a perfect sphere.
        This is done by subtracting the radius of the Earth from the value
        returned by get_radius() method.

        Returns
        -------
        float
            The altitude above the spherical Earth

        &#34;&#34;&#34;
        return self.get_radius() - EarthParam.r_e

    def __hash__(self):
        &#34;&#34;&#34;Make position hashable.&#34;&#34;&#34;
        return super().__hash__()

    @classmethod
    def from_vector(cls, vector: Vector) -&gt; Position:
        &#34;&#34;&#34;Create a position from a vector.

        Parameters
        ----------
        vector : Vector
            The vector

        Returns
        -------
        Position
            The vector represented as a position

        &#34;&#34;&#34;
        return cls(
            coordinates=vector.coordinates,
            frame_time=vector.frame_time,
            frame=vector.frame,
        )

    def to_vector(self) -&gt; Vector:
        &#34;&#34;&#34;Recast Position as a Vector.

        Returns
        -------
        Vector
            New vector

        &#34;&#34;&#34;
        return Vector(
            coordinates=self.coordinates, frame_time=self.frame_time, frame=self.frame
        )

    def __eq__(self, other: object) -&gt; bool:
        &#34;&#34;&#34;Equality Comparision.

        Parameters
        ----------
        other : Position
            Another position

        Returns
        -------
        bool
            If the distance between the positions is less than 1e-6

        Raises
        ------
        TypeError
            If the other value is not a Position

        &#34;&#34;&#34;
        if not isinstance(other, self.__class__):
            raise TypeError(&#34;Equality only defined between two Positions&#34;)

        eps = 1e-6

        return distance(self, other) &lt; eps

    def __add__(self, other: Vector) -&gt; Position:
        &#34;&#34;&#34;Add a vector to a position.

        Parameters
        ----------
        other : Vector
            Vector to add

        Returns
        -------
        Position
            New position

        Raises
        ------
        TypeError
            Other is not a vector

        &#34;&#34;&#34;
        if not isinstance(other, Vector):
            raise TypeError(&#34;other must be a vector&#34;)

        vec1 = self.to_vector()

        new_vec = vec1 + other

        return self.from_vector(new_vec)

    def __sub__(self, other: Vector) -&gt; Position:
        &#34;&#34;&#34;Subtract a vector from a position.

        Parameters
        ----------
        other : Vector
            Vector to subtract

        Returns
        -------
        Position
            New position

        Raises
        ------
        TypeError
            If other is not a vector
        &#34;&#34;&#34;
        if not isinstance(other, Vector):
            raise TypeError(&#34;other must be a vector&#34;)

        vec1 = self.to_vector()

        new_vec = vec1 - other

        return self.from_vector(new_vec)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gps_frames.vectors.SerializeableVector" href="vectors.html#gps_frames.vectors.SerializeableVector">SerializeableVector</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gps_frames.position.Position.coordinates"><code class="name">var <span class="ident">coordinates</span> :Â numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gps_frames.position.Position.frame"><code class="name">var <span class="ident">frame</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gps_frames.position.Position.frame_time"><code class="name">var <span class="ident">frame_time</span> :Â gps_time.core.GPSTime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gps_frames.position.Position.yaml_tag"><code class="name">var <span class="ident">yaml_tag</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="gps_frames.position.Position.from_vector"><code class="name flex">
<span>def <span class="ident">from_vector</span></span>(<span>vector:Â Vector) â€‘>Â <a title="gps_frames.position.Position" href="#gps_frames.position.Position">Position</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a position from a vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>Vector</code></dt>
<dd>The vector</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gps_frames.position.Position" href="#gps_frames.position.Position">Position</a></code></dt>
<dd>The vector represented as a position</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_vector(cls, vector: Vector) -&gt; Position:
    &#34;&#34;&#34;Create a position from a vector.

    Parameters
    ----------
    vector : Vector
        The vector

    Returns
    -------
    Position
        The vector represented as a position

    &#34;&#34;&#34;
    return cls(
        coordinates=vector.coordinates,
        frame_time=vector.frame_time,
        frame=vector.frame,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gps_frames.position.Position.get_altitude_hae"><code class="name flex">
<span>def <span class="ident">get_altitude_hae</span></span>(<span>self) â€‘>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Get the altitude, height above ellipsoid.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The height above ellipsoid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_altitude_hae(self) -&gt; float:
    &#34;&#34;&#34;Get the altitude, height above ellipsoid.

    Returns
    -------
    float
        The height above ellipsoid

    &#34;&#34;&#34;
    lla = trans.position_transform(
        self.frame, &#34;LLA&#34;, self.coordinates, self.frame_time
    )

    return lla[2]</code></pre>
</details>
</dd>
<dt id="gps_frames.position.Position.get_altitude_msl"><code class="name flex">
<span>def <span class="ident">get_altitude_msl</span></span>(<span>self) â€‘>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Altitude above Mean Sea Level.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The altitude above mean sea level</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_altitude_msl(self) -&gt; float:
    &#34;&#34;&#34;Get the Altitude above Mean Sea Level.

    Returns
    -------
    float
        The altitude above mean sea level

    &#34;&#34;&#34;
    lla = trans.position_transform(
        self.frame, &#34;LLA&#34;, self.coordinates, self.frame_time
    )

    geoid_height = GeoidData.get_geoid_height(lla[0], lla[1])

    return lla[2] - geoid_height</code></pre>
</details>
</dd>
<dt id="gps_frames.position.Position.get_altitude_spherical"><code class="name flex">
<span>def <span class="ident">get_altitude_spherical</span></span>(<span>self) â€‘>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Get the altitude above the spherical Earth.</p>
<p>Get the altitude for the position if the Earth was a perfect sphere.
This is done by subtracting the radius of the Earth from the value
returned by get_radius() method.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The altitude above the spherical Earth</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_altitude_spherical(self) -&gt; float:
    &#34;&#34;&#34;Get the altitude above the spherical Earth.

    Get the altitude for the position if the Earth was a perfect sphere.
    This is done by subtracting the radius of the Earth from the value
    returned by get_radius() method.

    Returns
    -------
    float
        The altitude above the spherical Earth

    &#34;&#34;&#34;
    return self.get_radius() - EarthParam.r_e</code></pre>
</details>
</dd>
<dt id="gps_frames.position.Position.get_position"><code class="name flex">
<span>def <span class="ident">get_position</span></span>(<span>self, out_frame:Â str) â€‘>Â <a title="gps_frames.position.Position" href="#gps_frames.position.Position">Position</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get a position object in new frame.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;New Object Created on Output</p>
<p>This function returns a new position object. It does not change
the reference frame used in this object. Use <code>switch_frame()</code> to
change the frame of the object.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>out_frame</code></strong> :&ensp;<code>str</code></dt>
<dd>The frame to output the position in</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gps_frames.position.Position" href="#gps_frames.position.Position">Position</a></code></dt>
<dd>The position expressed in a new frame</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>switch_frame</code></dt>
<dd>Change the frame that the position is interally expressed in</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_position(self, out_frame: str) -&gt; Position:
    &#34;&#34;&#34;Get a position object in new frame.

    .. note:: New Object Created on Output
        This function returns a new position object. It does not change
        the reference frame used in this object. Use `switch_frame()` to
        change the frame of the object.

    Parameters
    ----------
    out_frame : str
        The frame to output the position in

    Returns
    -------
    Position
        The position expressed in a new frame

    See Also
    --------
    switch_frame: Change the frame that the position is interally
        expressed in

    &#34;&#34;&#34;
    new_coordinates = trans.position_transform(
        self.frame, out_frame, self.coordinates, self.frame_time
    )

    return self.__class__(new_coordinates, self.frame_time, out_frame)</code></pre>
</details>
</dd>
<dt id="gps_frames.position.Position.get_radius"><code class="name flex">
<span>def <span class="ident">get_radius</span></span>(<span>self) â€‘>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Get the radius of the position.</p>
<p>Get the radius of the position, i.e. the distance from the position to
the center of the Earth</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The distance to the center of the Earth</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_radius(self) -&gt; float:
    &#34;&#34;&#34;Get the radius of the position.

    Get the radius of the position, i.e. the distance from the position to
    the center of the Earth

    Returns
    -------
    float
        The distance to the center of the Earth

    &#34;&#34;&#34;
    ecef = trans.position_transform(
        self.frame, &#34;ECEF&#34;, self.coordinates, self.frame_time
    )

    return np.linalg.norm(ecef)</code></pre>
</details>
</dd>
<dt id="gps_frames.position.Position.switch_frame"><code class="name flex">
<span>def <span class="ident">switch_frame</span></span>(<span>self, to_frame:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Change the frame used to store this position internally.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>to_frame</code></strong> :&ensp;<code>str</code></dt>
<dd>The desired new frame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switch_frame(self, to_frame: str) -&gt; None:
    &#34;&#34;&#34;Change the frame used to store this position internally.

    Parameters
    ----------
    to_frame : str
        The desired new frame

    &#34;&#34;&#34;
    new_coordinates = trans.position_transform(
        self.frame, to_frame, self.coordinates, self.frame_time
    )

    self.coordinates = new_coordinates
    self.frame = to_frame</code></pre>
</details>
</dd>
<dt id="gps_frames.position.Position.to_vector"><code class="name flex">
<span>def <span class="ident">to_vector</span></span>(<span>self) â€‘>Â <a title="gps_frames.vectors.Vector" href="vectors.html#gps_frames.vectors.Vector">Vector</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recast Position as a Vector.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Vector</code></dt>
<dd>New vector</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_vector(self) -&gt; Vector:
    &#34;&#34;&#34;Recast Position as a Vector.

    Returns
    -------
    Vector
        New vector

    &#34;&#34;&#34;
    return Vector(
        coordinates=self.coordinates, frame_time=self.frame_time, frame=self.frame
    )</code></pre>
</details>
</dd>
<dt id="gps_frames.position.Position.update_frame_time"><code class="name flex">
<span>def <span class="ident">update_frame_time</span></span>(<span>self, new_frame_time:Â GPSTime) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Change the reference time for the frame.</p>
<p>Reference frames can be time dependant. This method is used to change
the time reference for a reference frame.</p>
<p>This method updates the internal representation of the position to the
frame at the new reference time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>new_frame_time</code></strong> :&ensp;<code>GPSTime</code></dt>
<dd>The new frame reference time</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_frame_time(self, new_frame_time: GPSTime) -&gt; None:
    &#34;&#34;&#34;Change the reference time for the frame.

    Reference frames can be time dependant. This method is used to change
    the time reference for a reference frame.

    This method updates the internal representation of the position to the
    frame at the new reference time.

    Parameters
    ----------
    new_frame_time : GPSTime
        The new frame reference time

    &#34;&#34;&#34;
    coordinates = self.coordinates
    if self.frame == &#34;ECI&#34;:
        delta_weeks = new_frame_time.week_number - self.frame_time.week_number

        self.coordinates = trans.add_weeks_eci(delta_weeks, coordinates)
        self.frame_time = new_frame_time

    elif self.frame == &#34;ECEF&#34;:
        self.coordinates = trans.rotate_ecef(
            self.frame_time, new_frame_time, coordinates
        )
        self.frame_time = new_frame_time

    elif self.frame == &#34;LLA&#34;:
        self.switch_frame(&#34;ECEF&#34;)
        coordinates = self.coordinates
        self.coordinates = trans.rotate_ecef(
            self.frame_time, new_frame_time, coordinates
        )
        self.frame_time = new_frame_time

        self.switch_frame(&#34;LLA&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gps_frames.vectors.SerializeableVector" href="vectors.html#gps_frames.vectors.SerializeableVector">SerializeableVector</a></b></code>:
<ul class="hlist">
<li><code><a title="gps_frames.vectors.SerializeableVector.from_yaml" href="vectors.html#gps_frames.vectors.SerializeableVector.from_yaml">from_yaml</a></code></li>
<li><code><a title="gps_frames.vectors.SerializeableVector.to_yaml" href="vectors.html#gps_frames.vectors.SerializeableVector.to_yaml">to_yaml</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gps_frames" href="index.html">gps_frames</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gps_frames.position.distance" href="#gps_frames.position.distance">distance</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gps_frames.position.Position" href="#gps_frames.position.Position">Position</a></code></h4>
<ul class="">
<li><code><a title="gps_frames.position.Position.coordinates" href="#gps_frames.position.Position.coordinates">coordinates</a></code></li>
<li><code><a title="gps_frames.position.Position.frame" href="#gps_frames.position.Position.frame">frame</a></code></li>
<li><code><a title="gps_frames.position.Position.frame_time" href="#gps_frames.position.Position.frame_time">frame_time</a></code></li>
<li><code><a title="gps_frames.position.Position.from_vector" href="#gps_frames.position.Position.from_vector">from_vector</a></code></li>
<li><code><a title="gps_frames.position.Position.get_altitude_hae" href="#gps_frames.position.Position.get_altitude_hae">get_altitude_hae</a></code></li>
<li><code><a title="gps_frames.position.Position.get_altitude_msl" href="#gps_frames.position.Position.get_altitude_msl">get_altitude_msl</a></code></li>
<li><code><a title="gps_frames.position.Position.get_altitude_spherical" href="#gps_frames.position.Position.get_altitude_spherical">get_altitude_spherical</a></code></li>
<li><code><a title="gps_frames.position.Position.get_position" href="#gps_frames.position.Position.get_position">get_position</a></code></li>
<li><code><a title="gps_frames.position.Position.get_radius" href="#gps_frames.position.Position.get_radius">get_radius</a></code></li>
<li><code><a title="gps_frames.position.Position.switch_frame" href="#gps_frames.position.Position.switch_frame">switch_frame</a></code></li>
<li><code><a title="gps_frames.position.Position.to_vector" href="#gps_frames.position.Position.to_vector">to_vector</a></code></li>
<li><code><a title="gps_frames.position.Position.update_frame_time" href="#gps_frames.position.Position.update_frame_time">update_frame_time</a></code></li>
<li><code><a title="gps_frames.position.Position.yaml_tag" href="#gps_frames.position.Position.yaml_tag">yaml_tag</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>