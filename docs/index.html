<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gps_frames API documentation</title>
<meta name="description" content="gps_frames
Reference frame representation, transformations, and operations for GPS â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>gps_frames</code></h1>
</header>
<section id="section-intro">
<h1 id="gps_frames">gps_frames</h1>
<p>Reference frame representation, transformations, and operations for GPS.</p>
<p><a href="https://github.com/the-aerospace-corporation/gps_frames/actions/workflows/python-package.yml"><img alt="Test Python package" src="https://github.com/the-aerospace-corporation/gps_frames/actions/workflows/python-package.yml/badge.svg"></a>
<a href="https://github.com/the-aerospace-corporation/gps_frames/actions/workflows/codeql-analysis.yml"><img alt="CodeQL" src="https://github.com/the-aerospace-corporation/gps_frames/actions/workflows/codeql-analysis.yml/badge.svg"></a>
<a href="https://github.com/the-aerospace-corporation/gps_frames/actions/workflows/python-publish.yml"><img alt="Upload Python Package" src="https://github.com/the-aerospace-corporation/gps_frames/actions/workflows/python-publish.yml/badge.svg"></a></p>
<h2 id="installation">Installation</h2>
<p>This module can be installed using PyPI:</p>
<pre><code>pip install gps-frames
</code></pre>
<h2 id="running-tests">Running Tests</h2>
<p>This module includes tests for all of the major functionality. To run the tests, you can use the commands in the makefile <code>make test</code>. Because some of the functions use JIT compilation via Numba, <code>make test-nojit</code> runs all of the tests without JIT compilation to enable better code coverage analysis.</p>
<h2 id="using-gps_frames">Using gps_frames</h2>
<p>To motivating use case of this module is it determine distances between two points in space while accounting for non-inertial reference frames and non-simultaneous position measures. The basic functionality is demonstrated in <code>example.py</code>.ma</p>
<p>Note: When first run, gps-frames has significant overhead due to JIT compliation. This should only occur on the first run. Additionally, you may see <code>NumbaPerformanceWarning</code> messages related to the <code>@</code> (matrix multiplication) operator. These can be disregarded and should only appear the first time gps-frames is run.</p>
<h2 id="licence">Licence</h2>
<p>The <code><a title="gps_frames" href="#gps_frames">gps_frames</a></code> module is released under the GNU AGPL v3 license.</p>
<p>Copyright (c) 2022 The Aerospace Corportation.</p>
<h2 id="open-source-licenses">Open Source Licenses</h2>
<h3 id="egm96-data-source">EGM96 Data Source</h3>
<p>This module makes use of data related to the EGM96 gravity model. This data was generated by the National Geospatial-intelligence Agency (NGA) and the data used is derived from <a href="https://github.com/vectorstofinal/geoid_heights,">https://github.com/vectorstofinal/geoid_heights,</a> used under the MIT License Copyright (c) 2015 vectorstofinal.</p>
<h3 id="pdoc3">pdoc3</h3>
<p>The documentation is generated using <a href="https://pdoc3.github.io/pdoc/">pdoc3</a>. The documentation templates are based on the default template provided therefrom and used under the AGPL v3 license.
Gps_Frames</p>
<hr>
<p>Define the reference frames for use throughout the model.</p>
<p>The purpose of this module is to provide tools for translating between the
different reference frames used for GPS. At first, only the WGS84 (LLA) frame,
the ECEF frame, and the GPS ECI frame (relative to start of week) will be
included.</p>
<h2 id="notes">Notes</h2>
<p>Like all internal modules, distances are stored here as meters and angles are
stored as radians.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2022 The Aerospace Corporation
&#34;&#34;&#34;
.. include::../README.md

gps_frames
----------
Define the reference frames for use throughout the model.

The purpose of this module is to provide tools for translating between the
different reference frames used for GPS. At first, only the WGS84 (LLA) frame,
the ECEF frame, and the GPS ECI frame (relative to start of week) will be
included.

Notes
-----
Like all internal modules, distances are stored here as meters and angles are
stored as radians.

&#34;&#34;&#34;
__version__ = &#34;2.8.0&#34;
__copyright__ = &#34;Copyright (C) 2022 The Aerospace Corporation&#34;
__license__ = &#34;GNU AGPL v3&#34;
__distribution_statement__ = (
    &#34;UNCLASSIFIED // APPROVED FOR RELEASE ON OSS20-0011 // GNU AGPL v3&#34;
)

import numpy as np
from numba import jit

from typing import Tuple
import logging
import functools

from gps_time.logutils import (
    AlignedColorFormatter,
    BasicColorTheme,
    display_distro_statement,
)

from .basis import Basis, coordinates_in_basis
from .vectors import UnitVector, Vector  # noqa: F401
from .position import Position, distance  # noqa: F401
from .velocity import Velocity  # noqa: F401

from .parameters import EarthParam

from gps_time import GPSTime  # noqa: F401
from gps_time.utilities import arange_gpstime  # noqa: F401
from gps_time.datetime import datetime2zcount, arange_datetime  # noqa: F401

logger = logging.getLogger(__name__)
ch = logging.StreamHandler()
theme = BasicColorTheme()
formatter = AlignedColorFormatter(theme)
ch.setFormatter(formatter)
logger.addHandler(ch)

logger.setLevel(logging.WARNING)

logger.debug(&#34;Running &#34; + __name__ + &#34; version &#34; + __version__)
logger.debug(__copyright__)
logger.debug(__license__)

display_distro_statement(__distribution_statement__, logger, level=&#34;debug&#34;)


def get_east_north_up_basis(position: Position) -&gt; Basis:
    &#34;&#34;&#34;Get the East-North-Up Basis for the input position.

    Parameters
    ----------
    position : Position
        The position of interest

    Returns
    -------
    Basis
        The basis representing the East-North-Up frame

    &#34;&#34;&#34;
    lla_pos = position.get_position(&#34;LLA&#34;)
    lla = lla_pos.coordinates
    upx = np.cos(lla[0]) * np.cos(lla[1])
    upy = np.cos(lla[0]) * np.sin(lla[1])
    upz = np.sin(lla[0])

    updirection = UnitVector(
        np.array([upx, upy, upz], dtype=float), position.frame_time, &#34;ECEF&#34;
    )

    localeast_coords = np.array(
        [-updirection.coordinates[1], updirection.coordinates[0], 0], dtype=float
    )
    localeast = UnitVector(localeast_coords, lla_pos.frame_time, &#34;ECEF&#34;)

    # Local North is the cross between the up and east directions, i.e.
    # north = up cross east
    localnorth = UnitVector.from_vector(updirection.cross_product(localeast))

    return Basis(position.get_position(&#34;ECEF&#34;), localeast, localnorth, updirection)


def get_relative_angles(
    basis: Basis, target_position: Position, look_axis: int, reference_axis: int
) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;Get the angles from a basis to an object.

    Parameters
    ----------
    basis : Basis
        The basis to measure angles relative to
    target_position : Position
        The position of the target
    look_axis : int
        The axis that represents the look direction of the basis (i.e. the
        boresight)
    reference_axis : int
        The axis to measure the angle around the bore relative to (right-hand
        positive about the look_axis)

    Returns
    -------
    Tuple[float]
        The angle off of the look_axis and the angle about the look_axis, rad

    Raises
    ------
    ValueError
        If the look_axis and reference_axis have the same value or if they are
        not 1, 2, or 3

    &#34;&#34;&#34;
    if look_axis == reference_axis:
        raise ValueError(&#34;look_axis and reference_axis must be different&#34;)

    if look_axis not in [1, 2, 3]:
        raise ValueError(&#34;look_axis must be 1, 2, or 3&#34;)

    if reference_axis not in [1, 2, 3]:
        raise ValueError(&#34;reference_axis must be 1, 2, or 3&#34;)

    # Get the position relative to the basis
    rp = coordinates_in_basis(target_position, basis)

    # Assign the components along the basis to the internal variables
    for axis in [1, 2, 3]:
        if axis == look_axis:
            look_component = rp[axis - 1]
        elif axis == reference_axis:
            reference_component = rp[axis - 1]
        else:
            other_componet = rp[axis - 1]

    # Compute the angle off of the boresight (look_axis)
    off_bore_component = np.sqrt(reference_component ** 2 + other_componet ** 2)
    angle_off_bore = np.arctan2(off_bore_component, look_component)

    # Determine if the reference_axis is next in the cyclic order after the
    # look_axis
    _cyclic_order = reference_axis == (look_axis % 3) + 1

    # If the order is cyclic, simply compute the angle directly, If not, flip
    # the value of the other axis and compute the angle about the boresight
    # relative to the reference axis
    if _cyclic_order:
        angle_from_ref = np.arctan2(other_componet, reference_component)
    else:
        angle_from_ref = np.arctan2(-other_componet, reference_component)

    return angle_off_bore, angle_from_ref


def get_range_azimuth_elevation(
    enu_basis: Basis, target_position: Position
) -&gt; Tuple[float, float, float]:
    &#34;&#34;&#34;Get the azimuth and elevation of a target relative to a basis.

    Parameters
    ----------
    enu_basis : Basis
        The East-North-Up basis
    target_position : Position
        The position of the target

    Returns
    Tuple[float, float, float]
        The (1) range, (2) azimuth, and (3) elevation of the target relative
        to ENU basis provided.

    &#34;&#34;&#34;
    rp = coordinates_in_basis(target_position, enu_basis)
    range_ = np.linalg.norm(rp)

    elevation = (np.pi / 2.0) - np.arccos(rp[2] / range_)
    azimuth = np.arctan2(rp[0], rp[1])

    return range_, azimuth, elevation


def get_azimuth_elevation(
    enu_basis: Basis, target_position: Position
) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;Get the azimuth and elevation of a target relative to a basis.

    Parameters
    ----------
    enu_basis : Basis
        The East-North-Up basis
    target_position : Position
        The position of the target

    Returns
    -------
    Tuple[float, float]
        The (1) azimuth and (2) elevation of the target relative to ENU
        basis provided.

    &#34;&#34;&#34;
    _, azimuth, elevation = get_range_azimuth_elevation(enu_basis, target_position)

    return azimuth, elevation


def check_earth_obscuration(
    position1: Position,
    position2: Position,
    convert_hae_altitude: bool = False,
    earth_adjustment_m: float = 30e3,
    transition_altitude_m: float = -np.infty,
    elevation_mask_angle_rad: float = -0.1,
) -&gt; bool:
    r&#34;&#34;&#34;Determine if position2 is visiable from position1.

    .. note:: Assumptions
        This function is meant to be a quick check of Earth obscuration. As
        such, it does not account for things like time delays, signal
        refraction, or a non-spherical Earth. All calculations are done under
        the assumptions of simultanity, geometric line-of-sight, and a
        spherical Earth. In fact, this includes the option to naively use the
        height above ellipsoid as the height above the spherical Earth.

    This function is meant to determine if an object at position 2 has a
    direct line of sight to the object at position 1. There are two ways that
    this function checks to see if an object is visible.

    First, it checks to see if the object at position 2 is above the limb of
    the Earth. This means that the horizon object at position 2 is above the
    horizon viewed from position 1. Let the position 1 be a distance \(r\) from
    the center of the Earth. For the purposes of determining the angle to the
    horizon, let the adjusted radius of the Earth be
    $$
        R_{\oplus}&#39; = R_{\oplus} - \delta R
    $$
    where \(R_{\oplus}\) is the actual radius of the Earth and \(\delta R\)
    is a correction factor for the radius. Thus the angle between the nadir
    vector from position 1 to the limb is
    $$
        \lambda = \sin^{-1} \left(\frac{R_{\oplus}&#39;}{r}\right)
    $$
    Let the angle from the anti-nadir vector of position 1 to position 2 be
    \(\psi\). Position 2 will be above the horizon if
    $$
        \pi - \lambda \geq \psi
    $$

    The first method works well for determining if a satellite in view from a
    terrestrial object, but is not useful for determining if a terrestrial
    object is in view of a satellite. This is because if a terrestrial object
    is between a satellite and the Earth, it will be definitionally below the
    horizon, but obviously in view of the satellite. For this reason a second
    test is implemented. An object at position 1 is defined to be in view of
    an object at position 1 if the distance from position 1 to 2 is less than
    the distance from position 1 to the horizon. This technically allows for a
    significant amount of the interior of the Earth to be considered in view,
    but would in practice only return objects in view because subterranian
    objects are not feasible. Let \(d\) be the distance from position 1 to
    position 2. This second condition is
    $$
        d &lt; r \cos\lambda
    $$

    This function also includes a sort of safety factor; it allows for the
    radius of the Earth used for determining the horizon to be reduced. This
    factor can be used to account for the non-sphereical Earth and timing
    issues.

    Parameters
    ----------
    position1 : Position
        The position of object 1
    position2 : Position
        The position of object 2
    convert_hae_altitude : bool, optional
        If the position is in the LLA frame, then its altitude is in height
        above ellispoid (HAE). If this is true, actual spherical altitude will
        be calculated. However, it it is False, the HAE altitude will naively
        be used as a spherical altitude, which is less accurate but will
        provide a faster estimate and can be accounted for using the
        earth_adjustment_m parameter, by default False
    earth_adjustment_m : float, optional
        Effectively reduces the radius of the Earth for the purposes of the
        computing the obscuration. This distance (in meters) is subtracted
        from the radius of the Earth when calculating idealized mask angles,
        by default 100e3

    Returns
    -------
    bool
        True if the position2 is visible from position1

    &#34;&#34;&#34;
    if earth_adjustment_m &lt; 0:
        logger.debug(
            &#34;Earth Obscuration: Earth Radius Adjustment is negative, which &#34;
            &#34;makes Earth larger.&#34;
        )

    elevation_mask_angle_rad = 5 * np.pi / 180

    position1_radius = position1.get_radius()
    position2_radius = position2.get_radius()

    if position1_radius &lt; position2_radius:
        lower_position = position1
        lower_radius = position1_radius
        lower_altitude = position1.get_altitude_hae()

        upper_position = position2
        # upper_radius = position2_radius
    else:
        upper_position = position1
        # upper_radius = position1_radius

        lower_position = position2
        lower_radius = position2_radius
        lower_altitude = position2.get_altitude_hae()

    lower_enu_basis = get_east_north_up_basis(lower_position)
    _distance, _azimuth, _elevation = get_range_azimuth_elevation(
        lower_enu_basis, upper_position
    )

    if transition_altitude_m &gt; lower_altitude:
        min_elevation = elevation_mask_angle_rad
    else:
        adjusted_earth_radius = EarthParam.r_e - earth_adjustment_m
        sin_limb_angle = adjusted_earth_radius / lower_radius
        limb_angle = np.arcsin(np.min([1.0, sin_limb_angle]))
        min_elevation = limb_angle - (np.pi / 2) + elevation_mask_angle_rad

    in_view = _elevation &gt;= min_elevation

    return in_view


def _get_spherical_radius(position: Position, correct_lla: bool) -&gt; float:
    &#34;&#34;&#34;Get the spherical radius.

    .. deprectated:: Functionality moved to Position object
        This method will be deprecated in favor of the
        gps_frames.position.Position.get_altitude_spherical() and
        gps_frames.position.Position.get_radius() methods. This function is
        just an alias for the Position.get_radius() method.

    Get the spherical radius of the object. If the position is expressed
    in LLA, then the radius will either be the HAE plus the radius of the
    earth (if correct_lla is True) or the position will be converted to
    the ECEF frame. In the ECEF and ECI frame, the spherical radius is the
    norm of the position coordinates.

    Parameters
    ----------
    position : Position
        The position
    correct_lla : bool
        If True, accounts for HAE vs spherical Earth

    Returns
    -------
    float
        The spherical radius of the position

    .. todo:: Move into position object

    &#34;&#34;&#34;
    logger.error(&#34;DEPRECATION: This function is superseded by methods in Position&#34;)
    if not correct_lla:
        logger.critical(
            &#34;DEPRECATION: correct_lla argument is not mirrored in new method&#34;
        )

    return position.get_radius()</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="gps_frames.basis" href="basis.html">gps_frames.basis</a></code></dt>
<dd>
<div class="desc"><p>Reference Frame Basis â€¦</p></div>
</dd>
<dt><code class="name"><a title="gps_frames.parameters" href="parameters.html">gps_frames.parameters</a></code></dt>
<dd>
<div class="desc"><p>Standard parameters used throughout the simulator â€¦</p></div>
</dd>
<dt><code class="name"><a title="gps_frames.paths" href="paths.html">gps_frames.paths</a></code></dt>
<dd>
<div class="desc"><p>Compute information about signal paths â€¦</p></div>
</dd>
<dt><code class="name"><a title="gps_frames.position" href="position.html">gps_frames.position</a></code></dt>
<dd>
<div class="desc"><p>Positions in reference frames â€¦</p></div>
</dd>
<dt><code class="name"><a title="gps_frames.rotations" href="rotations.html">gps_frames.rotations</a></code></dt>
<dd>
<div class="desc"><p>Representation for Rotations â€¦</p></div>
</dd>
<dt><code class="name"><a title="gps_frames.transforms" href="transforms.html">gps_frames.transforms</a></code></dt>
<dd>
<div class="desc"><p>Frame Transformations â€¦</p></div>
</dd>
<dt><code class="name"><a title="gps_frames.vectors" href="vectors.html">gps_frames.vectors</a></code></dt>
<dd>
<div class="desc"><p>Representation for Vectors â€¦</p></div>
</dd>
<dt><code class="name"><a title="gps_frames.velocity" href="velocity.html">gps_frames.velocity</a></code></dt>
<dd>
<div class="desc"><p>Positions in reference frames â€¦</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gps_frames.check_earth_obscuration"><code class="name flex">
<span>def <span class="ident">check_earth_obscuration</span></span>(<span>position1:Â <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>, position2:Â <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>, convert_hae_altitude:Â boolÂ =Â False, earth_adjustment_m:Â floatÂ =Â 30000.0, transition_altitude_m:Â floatÂ =Â -inf, elevation_mask_angle_rad:Â floatÂ =Â -0.1) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if position2 is visiable from position1.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;Assumptions</p>
<p>This function is meant to be a quick check of Earth obscuration. As
such, it does not account for things like time delays, signal
refraction, or a non-spherical Earth. All calculations are done under
the assumptions of simultanity, geometric line-of-sight, and a
spherical Earth. In fact, this includes the option to naively use the
height above ellipsoid as the height above the spherical Earth.</p>
</div>
<p>This function is meant to determine if an object at position 2 has a
direct line of sight to the object at position 1. There are two ways that
this function checks to see if an object is visible.</p>
<p>First, it checks to see if the object at position 2 is above the limb of
the Earth. This means that the horizon object at position 2 is above the
horizon viewed from position 1. Let the position 1 be a distance <span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> from
the center of the Earth. For the purposes of determining the angle to the
horizon, let the adjusted radius of the Earth be
<span><span class="MathJax_Preview">
R_{\oplus}' = R_{\oplus} - \delta R
</span><script type="math/tex; mode=display">
R_{\oplus}' = R_{\oplus} - \delta R
</script></span>
where <span><span class="MathJax_Preview">R_{\oplus}</span><script type="math/tex">R_{\oplus}</script></span> is the actual radius of the Earth and <span><span class="MathJax_Preview">\delta R</span><script type="math/tex">\delta R</script></span>
is a correction factor for the radius. Thus the angle between the nadir
vector from position 1 to the limb is
<span><span class="MathJax_Preview">
\lambda = \sin^{-1} \left(\frac{R_{\oplus}'}{r}\right)
</span><script type="math/tex; mode=display">
\lambda = \sin^{-1} \left(\frac{R_{\oplus}'}{r}\right)
</script></span>
Let the angle from the anti-nadir vector of position 1 to position 2 be
<span><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span>. Position 2 will be above the horizon if
<span><span class="MathJax_Preview">
\pi - \lambda \geq \psi
</span><script type="math/tex; mode=display">
\pi - \lambda \geq \psi
</script></span></p>
<p>The first method works well for determining if a satellite in view from a
terrestrial object, but is not useful for determining if a terrestrial
object is in view of a satellite. This is because if a terrestrial object
is between a satellite and the Earth, it will be definitionally below the
horizon, but obviously in view of the satellite. For this reason a second
test is implemented. An object at position 1 is defined to be in view of
an object at position 1 if the distance from position 1 to 2 is less than
the distance from position 1 to the horizon. This technically allows for a
significant amount of the interior of the Earth to be considered in view,
but would in practice only return objects in view because subterranian
objects are not feasible. Let <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> be the distance from position 1 to
position 2. This second condition is
<span><span class="MathJax_Preview">
d &lt; r \cos\lambda
</span><script type="math/tex; mode=display">
d < r \cos\lambda
</script></span></p>
<p>This function also includes a sort of safety factor; it allows for the
radius of the Earth used for determining the horizon to be reduced. This
factor can be used to account for the non-sphereical Earth and timing
issues.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position1</code></strong> :&ensp;<code>Position</code></dt>
<dd>The position of object 1</dd>
<dt><strong><code>position2</code></strong> :&ensp;<code>Position</code></dt>
<dd>The position of object 2</dd>
<dt><strong><code>convert_hae_altitude</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the position is in the LLA frame, then its altitude is in height
above ellispoid (HAE). If this is true, actual spherical altitude will
be calculated. However, it it is False, the HAE altitude will naively
be used as a spherical altitude, which is less accurate but will
provide a faster estimate and can be accounted for using the
earth_adjustment_m parameter, by default False</dd>
<dt><strong><code>earth_adjustment_m</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Effectively reduces the radius of the Earth for the purposes of the
computing the obscuration. This distance (in meters) is subtracted
from the radius of the Earth when calculating idealized mask angles,
by default 100e3</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the position2 is visible from position1</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_earth_obscuration(
    position1: Position,
    position2: Position,
    convert_hae_altitude: bool = False,
    earth_adjustment_m: float = 30e3,
    transition_altitude_m: float = -np.infty,
    elevation_mask_angle_rad: float = -0.1,
) -&gt; bool:
    r&#34;&#34;&#34;Determine if position2 is visiable from position1.

    .. note:: Assumptions
        This function is meant to be a quick check of Earth obscuration. As
        such, it does not account for things like time delays, signal
        refraction, or a non-spherical Earth. All calculations are done under
        the assumptions of simultanity, geometric line-of-sight, and a
        spherical Earth. In fact, this includes the option to naively use the
        height above ellipsoid as the height above the spherical Earth.

    This function is meant to determine if an object at position 2 has a
    direct line of sight to the object at position 1. There are two ways that
    this function checks to see if an object is visible.

    First, it checks to see if the object at position 2 is above the limb of
    the Earth. This means that the horizon object at position 2 is above the
    horizon viewed from position 1. Let the position 1 be a distance \(r\) from
    the center of the Earth. For the purposes of determining the angle to the
    horizon, let the adjusted radius of the Earth be
    $$
        R_{\oplus}&#39; = R_{\oplus} - \delta R
    $$
    where \(R_{\oplus}\) is the actual radius of the Earth and \(\delta R\)
    is a correction factor for the radius. Thus the angle between the nadir
    vector from position 1 to the limb is
    $$
        \lambda = \sin^{-1} \left(\frac{R_{\oplus}&#39;}{r}\right)
    $$
    Let the angle from the anti-nadir vector of position 1 to position 2 be
    \(\psi\). Position 2 will be above the horizon if
    $$
        \pi - \lambda \geq \psi
    $$

    The first method works well for determining if a satellite in view from a
    terrestrial object, but is not useful for determining if a terrestrial
    object is in view of a satellite. This is because if a terrestrial object
    is between a satellite and the Earth, it will be definitionally below the
    horizon, but obviously in view of the satellite. For this reason a second
    test is implemented. An object at position 1 is defined to be in view of
    an object at position 1 if the distance from position 1 to 2 is less than
    the distance from position 1 to the horizon. This technically allows for a
    significant amount of the interior of the Earth to be considered in view,
    but would in practice only return objects in view because subterranian
    objects are not feasible. Let \(d\) be the distance from position 1 to
    position 2. This second condition is
    $$
        d &lt; r \cos\lambda
    $$

    This function also includes a sort of safety factor; it allows for the
    radius of the Earth used for determining the horizon to be reduced. This
    factor can be used to account for the non-sphereical Earth and timing
    issues.

    Parameters
    ----------
    position1 : Position
        The position of object 1
    position2 : Position
        The position of object 2
    convert_hae_altitude : bool, optional
        If the position is in the LLA frame, then its altitude is in height
        above ellispoid (HAE). If this is true, actual spherical altitude will
        be calculated. However, it it is False, the HAE altitude will naively
        be used as a spherical altitude, which is less accurate but will
        provide a faster estimate and can be accounted for using the
        earth_adjustment_m parameter, by default False
    earth_adjustment_m : float, optional
        Effectively reduces the radius of the Earth for the purposes of the
        computing the obscuration. This distance (in meters) is subtracted
        from the radius of the Earth when calculating idealized mask angles,
        by default 100e3

    Returns
    -------
    bool
        True if the position2 is visible from position1

    &#34;&#34;&#34;
    if earth_adjustment_m &lt; 0:
        logger.debug(
            &#34;Earth Obscuration: Earth Radius Adjustment is negative, which &#34;
            &#34;makes Earth larger.&#34;
        )

    elevation_mask_angle_rad = 5 * np.pi / 180

    position1_radius = position1.get_radius()
    position2_radius = position2.get_radius()

    if position1_radius &lt; position2_radius:
        lower_position = position1
        lower_radius = position1_radius
        lower_altitude = position1.get_altitude_hae()

        upper_position = position2
        # upper_radius = position2_radius
    else:
        upper_position = position1
        # upper_radius = position1_radius

        lower_position = position2
        lower_radius = position2_radius
        lower_altitude = position2.get_altitude_hae()

    lower_enu_basis = get_east_north_up_basis(lower_position)
    _distance, _azimuth, _elevation = get_range_azimuth_elevation(
        lower_enu_basis, upper_position
    )

    if transition_altitude_m &gt; lower_altitude:
        min_elevation = elevation_mask_angle_rad
    else:
        adjusted_earth_radius = EarthParam.r_e - earth_adjustment_m
        sin_limb_angle = adjusted_earth_radius / lower_radius
        limb_angle = np.arcsin(np.min([1.0, sin_limb_angle]))
        min_elevation = limb_angle - (np.pi / 2) + elevation_mask_angle_rad

    in_view = _elevation &gt;= min_elevation

    return in_view</code></pre>
</details>
</dd>
<dt id="gps_frames.get_azimuth_elevation"><code class="name flex">
<span>def <span class="ident">get_azimuth_elevation</span></span>(<span>enu_basis:Â <a title="gps_frames.basis.Basis" href="basis.html#gps_frames.basis.Basis">Basis</a>, target_position:Â <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>) â€‘>Â Tuple[float,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the azimuth and elevation of a target relative to a basis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>enu_basis</code></strong> :&ensp;<code>Basis</code></dt>
<dd>The East-North-Up basis</dd>
<dt><strong><code>target_position</code></strong> :&ensp;<code>Position</code></dt>
<dd>The position of the target</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[float, float]</code></dt>
<dd>The (1) azimuth and (2) elevation of the target relative to ENU
basis provided.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_azimuth_elevation(
    enu_basis: Basis, target_position: Position
) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;Get the azimuth and elevation of a target relative to a basis.

    Parameters
    ----------
    enu_basis : Basis
        The East-North-Up basis
    target_position : Position
        The position of the target

    Returns
    -------
    Tuple[float, float]
        The (1) azimuth and (2) elevation of the target relative to ENU
        basis provided.

    &#34;&#34;&#34;
    _, azimuth, elevation = get_range_azimuth_elevation(enu_basis, target_position)

    return azimuth, elevation</code></pre>
</details>
</dd>
<dt id="gps_frames.get_east_north_up_basis"><code class="name flex">
<span>def <span class="ident">get_east_north_up_basis</span></span>(<span>position:Â <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>) â€‘>Â <a title="gps_frames.basis.Basis" href="basis.html#gps_frames.basis.Basis">Basis</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the East-North-Up Basis for the input position.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>Position</code></dt>
<dd>The position of interest</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Basis</code></dt>
<dd>The basis representing the East-North-Up frame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_east_north_up_basis(position: Position) -&gt; Basis:
    &#34;&#34;&#34;Get the East-North-Up Basis for the input position.

    Parameters
    ----------
    position : Position
        The position of interest

    Returns
    -------
    Basis
        The basis representing the East-North-Up frame

    &#34;&#34;&#34;
    lla_pos = position.get_position(&#34;LLA&#34;)
    lla = lla_pos.coordinates
    upx = np.cos(lla[0]) * np.cos(lla[1])
    upy = np.cos(lla[0]) * np.sin(lla[1])
    upz = np.sin(lla[0])

    updirection = UnitVector(
        np.array([upx, upy, upz], dtype=float), position.frame_time, &#34;ECEF&#34;
    )

    localeast_coords = np.array(
        [-updirection.coordinates[1], updirection.coordinates[0], 0], dtype=float
    )
    localeast = UnitVector(localeast_coords, lla_pos.frame_time, &#34;ECEF&#34;)

    # Local North is the cross between the up and east directions, i.e.
    # north = up cross east
    localnorth = UnitVector.from_vector(updirection.cross_product(localeast))

    return Basis(position.get_position(&#34;ECEF&#34;), localeast, localnorth, updirection)</code></pre>
</details>
</dd>
<dt id="gps_frames.get_range_azimuth_elevation"><code class="name flex">
<span>def <span class="ident">get_range_azimuth_elevation</span></span>(<span>enu_basis:Â <a title="gps_frames.basis.Basis" href="basis.html#gps_frames.basis.Basis">Basis</a>, target_position:Â <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>) â€‘>Â Tuple[float,Â float,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the azimuth and elevation of a target relative to a basis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>enu_basis</code></strong> :&ensp;<code>Basis</code></dt>
<dd>The East-North-Up basis</dd>
<dt><strong><code>target_position</code></strong> :&ensp;<code>Position</code></dt>
<dd>The position of the target</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Tuple[float, float, float]
The (1) range, (2) azimuth, and (3) elevation of the target relative
to ENU basis provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_range_azimuth_elevation(
    enu_basis: Basis, target_position: Position
) -&gt; Tuple[float, float, float]:
    &#34;&#34;&#34;Get the azimuth and elevation of a target relative to a basis.

    Parameters
    ----------
    enu_basis : Basis
        The East-North-Up basis
    target_position : Position
        The position of the target

    Returns
    Tuple[float, float, float]
        The (1) range, (2) azimuth, and (3) elevation of the target relative
        to ENU basis provided.

    &#34;&#34;&#34;
    rp = coordinates_in_basis(target_position, enu_basis)
    range_ = np.linalg.norm(rp)

    elevation = (np.pi / 2.0) - np.arccos(rp[2] / range_)
    azimuth = np.arctan2(rp[0], rp[1])

    return range_, azimuth, elevation</code></pre>
</details>
</dd>
<dt id="gps_frames.get_relative_angles"><code class="name flex">
<span>def <span class="ident">get_relative_angles</span></span>(<span>basis:Â <a title="gps_frames.basis.Basis" href="basis.html#gps_frames.basis.Basis">Basis</a>, target_position:Â <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>, look_axis:Â int, reference_axis:Â int) â€‘>Â Tuple[float,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the angles from a basis to an object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>basis</code></strong> :&ensp;<code>Basis</code></dt>
<dd>The basis to measure angles relative to</dd>
<dt><strong><code>target_position</code></strong> :&ensp;<code>Position</code></dt>
<dd>The position of the target</dd>
<dt><strong><code>look_axis</code></strong> :&ensp;<code>int</code></dt>
<dd>The axis that represents the look direction of the basis (i.e. the
boresight)</dd>
<dt><strong><code>reference_axis</code></strong> :&ensp;<code>int</code></dt>
<dd>The axis to measure the angle around the bore relative to (right-hand
positive about the look_axis)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[float]</code></dt>
<dd>The angle off of the look_axis and the angle about the look_axis, rad</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the look_axis and reference_axis have the same value or if they are
not 1, 2, or 3</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_relative_angles(
    basis: Basis, target_position: Position, look_axis: int, reference_axis: int
) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;Get the angles from a basis to an object.

    Parameters
    ----------
    basis : Basis
        The basis to measure angles relative to
    target_position : Position
        The position of the target
    look_axis : int
        The axis that represents the look direction of the basis (i.e. the
        boresight)
    reference_axis : int
        The axis to measure the angle around the bore relative to (right-hand
        positive about the look_axis)

    Returns
    -------
    Tuple[float]
        The angle off of the look_axis and the angle about the look_axis, rad

    Raises
    ------
    ValueError
        If the look_axis and reference_axis have the same value or if they are
        not 1, 2, or 3

    &#34;&#34;&#34;
    if look_axis == reference_axis:
        raise ValueError(&#34;look_axis and reference_axis must be different&#34;)

    if look_axis not in [1, 2, 3]:
        raise ValueError(&#34;look_axis must be 1, 2, or 3&#34;)

    if reference_axis not in [1, 2, 3]:
        raise ValueError(&#34;reference_axis must be 1, 2, or 3&#34;)

    # Get the position relative to the basis
    rp = coordinates_in_basis(target_position, basis)

    # Assign the components along the basis to the internal variables
    for axis in [1, 2, 3]:
        if axis == look_axis:
            look_component = rp[axis - 1]
        elif axis == reference_axis:
            reference_component = rp[axis - 1]
        else:
            other_componet = rp[axis - 1]

    # Compute the angle off of the boresight (look_axis)
    off_bore_component = np.sqrt(reference_component ** 2 + other_componet ** 2)
    angle_off_bore = np.arctan2(off_bore_component, look_component)

    # Determine if the reference_axis is next in the cyclic order after the
    # look_axis
    _cyclic_order = reference_axis == (look_axis % 3) + 1

    # If the order is cyclic, simply compute the angle directly, If not, flip
    # the value of the other axis and compute the angle about the boresight
    # relative to the reference axis
    if _cyclic_order:
        angle_from_ref = np.arctan2(other_componet, reference_component)
    else:
        angle_from_ref = np.arctan2(-other_componet, reference_component)

    return angle_off_bore, angle_from_ref</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#gps_frames">gps_frames</a><ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#running-tests">Running Tests</a></li>
<li><a href="#using-gps_frames">Using gps_frames</a></li>
<li><a href="#licence">Licence</a></li>
<li><a href="#open-source-licenses">Open Source Licenses</a><ul>
<li><a href="#egm96-data-source">EGM96 Data Source</a></li>
<li><a href="#pdoc3">pdoc3</a></li>
</ul>
</li>
<li><a href="#notes">Notes</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="gps_frames.basis" href="basis.html">gps_frames.basis</a></code></li>
<li><code><a title="gps_frames.parameters" href="parameters.html">gps_frames.parameters</a></code></li>
<li><code><a title="gps_frames.paths" href="paths.html">gps_frames.paths</a></code></li>
<li><code><a title="gps_frames.position" href="position.html">gps_frames.position</a></code></li>
<li><code><a title="gps_frames.rotations" href="rotations.html">gps_frames.rotations</a></code></li>
<li><code><a title="gps_frames.transforms" href="transforms.html">gps_frames.transforms</a></code></li>
<li><code><a title="gps_frames.vectors" href="vectors.html">gps_frames.vectors</a></code></li>
<li><code><a title="gps_frames.velocity" href="velocity.html">gps_frames.velocity</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gps_frames.check_earth_obscuration" href="#gps_frames.check_earth_obscuration">check_earth_obscuration</a></code></li>
<li><code><a title="gps_frames.get_azimuth_elevation" href="#gps_frames.get_azimuth_elevation">get_azimuth_elevation</a></code></li>
<li><code><a title="gps_frames.get_east_north_up_basis" href="#gps_frames.get_east_north_up_basis">get_east_north_up_basis</a></code></li>
<li><code><a title="gps_frames.get_range_azimuth_elevation" href="#gps_frames.get_range_azimuth_elevation">get_range_azimuth_elevation</a></code></li>
<li><code><a title="gps_frames.get_relative_angles" href="#gps_frames.get_relative_angles">get_relative_angles</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>