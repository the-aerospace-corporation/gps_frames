<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gps_frames.paths API documentation</title>
<meta name="description" content="Compute information about signal paths …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gps_frames.paths</code></h1>
</header>
<section id="section-intro">
<p>Compute information about signal paths.</p>
<p>This submodule contains tools that can be used to determine information about a signal
path.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2022 The Aerospace Corporation
&#34;&#34;&#34;Compute information about signal paths.

This submodule contains tools that can be used to determine information about a signal
path.

&#34;&#34;&#34;

import numpy as np

from typing import List
from logging import getLogger

from .parameters import EarthParam
from .position import Position, distance
from .vectors import Vector

logger = getLogger(__name__)


def get_distance_between_points(positions: List[Position]) -&gt; List[float]:
    &#34;&#34;&#34;Compute the distance between Positions in a list.

    .. note:: Length of Return Object
        Because it requires two points to compute a distance, the length of
        the returned list is one element shorter than the input list.

    Parameters
    ----------
    positions : List[Position]
        A list of positions

    Returns
    -------
    List[float]
        A list of distances between the positions. The first returned element
        is the distance between first and second positions, the second
        returned element is the distance between the second and third, and
        so on.

    &#34;&#34;&#34;
    logger.debug(f&#34;Calculating Distance between {len(positions)} points&#34;)
    return [
        distance(_pos1, _pos2) for _pos1, _pos2 in zip(positions[:-1], positions[1:])
    ]


def get_altitude_intersection_point(
    altitude: float, origin_position: Position, target_position: Position
) -&gt; Position:
    &#34;&#34;&#34;Get the point where a unit vector crosses an altitude

    The purpose of this function is to calculate the point at which a vector,
    starting at the origin, will cross a specific altitude.

    .. note:: Spherical Earth
        The function assumes a spherical Earth, not WGS84 ellipsoid

    Parameters
    ----------
    altitude : float
        The altitude in meters
    origin_position : Position
        The position of the origin
    target_position : Position
        The position of the target

    Returns
    -------
    Position
        The position where the path from the origin to the target passes
        through the specified altitude.

    &#34;&#34;&#34;

    path_vector = target_position.to_vector() - origin_position.to_vector()
    path_length = path_vector.magnitude

    origin_radius = origin_position.get_radius()
    target_radius = target_position.get_radius()

    cos_e_p2 = (origin_radius ** 2 + path_length ** 2 - target_radius ** 2) / (
        2 * origin_radius * path_length
    )

    k = origin_radius * cos_e_p2 + np.sqrt(
        (EarthParam.r_e + altitude) ** 2 - origin_radius ** 2 * (1 - cos_e_p2 ** 2)
    )

    intersection_point = origin_position + (path_vector * (k / path_length))

    return intersection_point


def get_points_along_path(
    start_point: Position, end_point: Position, num_points: int
) -&gt; List[Position]:
    &#34;&#34;&#34;Get evenly space points along the path.

    Get a list of evenly spaced points along a path. This list includes the
    start and end points, so the number of points along the path must be at
    least 2 (the start and end points).

    Parameters
    ----------
    start_point : Position
        The starting position of the path
    end_point : Position
        The ending position of the path
    num_points : int
        The number of points to return along the path.

    Returns
    -------
    List[Position]
        A list of points along the path, including the start and end points.
        The length of the returned list is num_points.

    Raises
    ------
    ValueError
        If num_points &lt; 2
    &#34;&#34;&#34;
    if num_points &lt; 2:
        raise ValueError(&#34;num_points must be &gt;= 2&#34;)

    start_vector = start_point.to_vector()
    end_vector = end_point.to_vector()

    path_vector = end_vector - start_vector
    path_length = path_vector.magnitude

    return [
        start_point + (path_vector * (_d / path_length))
        for _d in np.linspace(0, path_length, num_points)
    ]


def get_point_closest_approach(
    start_point: Position,
    path_vector: Vector,
    elevation: float,
    max_length: float = np.infty,
) -&gt; Position:
    &#34;&#34;&#34;Get the point along the path that is is closest to Earth.

    Compute the point along the path that it is closest to the spherical Earth

    Parameters
    ----------
    start_point : Position
        The start position of the path
    path_vector : Vector
        The vector (not unit vector) describing the path from the start point
        to the end point, i.e. `end_point = start_point + path_vector` or
        `path_vector = end_point - start_point`.
    elevation : float
        The elevation of the end point of the path relative to the start point
    max_length : float, optional
        The maximum distance from the start point to the point of closest
        approach, by default infinity (np.infty). It is generally useful to
        specify that the length of the path is the maximum distance, otherwise
        this algorithm will find a point of closest approach beyond the end point.

    Returns
    -------
    Position
        The point of closest approach along the path.

    &#34;&#34;&#34;
    if elevation &gt;= 0:
        logger.warning(
            &#34;Attempted to find closest approach when the end point was above &#34;
            &#34;the start point&#39;s horizon. Because the path starts at the start &#34;
            &#34;point and the path moves away from the Earth, the start point &#34;
            &#34;is by definition the point of closest approach.&#34;
        )
        return start_point
    else:
        dc = start_point.get_radius() * np.sin(-elevation)

        if dc &gt; max_length:
            dc = max_length

        return start_point + (path_vector * (dc / path_vector.magnitude))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gps_frames.paths.get_altitude_intersection_point"><code class="name flex">
<span>def <span class="ident">get_altitude_intersection_point</span></span>(<span>altitude: float, origin_position: <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>, target_position: <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>) ‑> <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the point where a unit vector crosses an altitude</p>
<p>The purpose of this function is to calculate the point at which a vector,
starting at the origin, will cross a specific altitude.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;Spherical Earth</p>
<p>The function assumes a spherical Earth, not WGS84 ellipsoid</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>altitude</code></strong> :&ensp;<code>float</code></dt>
<dd>The altitude in meters</dd>
<dt><strong><code>origin_position</code></strong> :&ensp;<code>Position</code></dt>
<dd>The position of the origin</dd>
<dt><strong><code>target_position</code></strong> :&ensp;<code>Position</code></dt>
<dd>The position of the target</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Position</code></dt>
<dd>The position where the path from the origin to the target passes
through the specified altitude.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_altitude_intersection_point(
    altitude: float, origin_position: Position, target_position: Position
) -&gt; Position:
    &#34;&#34;&#34;Get the point where a unit vector crosses an altitude

    The purpose of this function is to calculate the point at which a vector,
    starting at the origin, will cross a specific altitude.

    .. note:: Spherical Earth
        The function assumes a spherical Earth, not WGS84 ellipsoid

    Parameters
    ----------
    altitude : float
        The altitude in meters
    origin_position : Position
        The position of the origin
    target_position : Position
        The position of the target

    Returns
    -------
    Position
        The position where the path from the origin to the target passes
        through the specified altitude.

    &#34;&#34;&#34;

    path_vector = target_position.to_vector() - origin_position.to_vector()
    path_length = path_vector.magnitude

    origin_radius = origin_position.get_radius()
    target_radius = target_position.get_radius()

    cos_e_p2 = (origin_radius ** 2 + path_length ** 2 - target_radius ** 2) / (
        2 * origin_radius * path_length
    )

    k = origin_radius * cos_e_p2 + np.sqrt(
        (EarthParam.r_e + altitude) ** 2 - origin_radius ** 2 * (1 - cos_e_p2 ** 2)
    )

    intersection_point = origin_position + (path_vector * (k / path_length))

    return intersection_point</code></pre>
</details>
</dd>
<dt id="gps_frames.paths.get_distance_between_points"><code class="name flex">
<span>def <span class="ident">get_distance_between_points</span></span>(<span>positions: List[<a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>]) ‑> List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the distance between Positions in a list.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;Length of Return Object</p>
<p>Because it requires two points to compute a distance, the length of
the returned list is one element shorter than the input list.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>List[Position]</code></dt>
<dd>A list of positions</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[float]</code></dt>
<dd>A list of distances between the positions. The first returned element
is the distance between first and second positions, the second
returned element is the distance between the second and third, and
so on.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_distance_between_points(positions: List[Position]) -&gt; List[float]:
    &#34;&#34;&#34;Compute the distance between Positions in a list.

    .. note:: Length of Return Object
        Because it requires two points to compute a distance, the length of
        the returned list is one element shorter than the input list.

    Parameters
    ----------
    positions : List[Position]
        A list of positions

    Returns
    -------
    List[float]
        A list of distances between the positions. The first returned element
        is the distance between first and second positions, the second
        returned element is the distance between the second and third, and
        so on.

    &#34;&#34;&#34;
    logger.debug(f&#34;Calculating Distance between {len(positions)} points&#34;)
    return [
        distance(_pos1, _pos2) for _pos1, _pos2 in zip(positions[:-1], positions[1:])
    ]</code></pre>
</details>
</dd>
<dt id="gps_frames.paths.get_point_closest_approach"><code class="name flex">
<span>def <span class="ident">get_point_closest_approach</span></span>(<span>start_point: <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>, path_vector: <a title="gps_frames.vectors.Vector" href="vectors.html#gps_frames.vectors.Vector">Vector</a>, elevation: float, max_length: float = inf) ‑> <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the point along the path that is is closest to Earth.</p>
<p>Compute the point along the path that it is closest to the spherical Earth</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start_point</code></strong> :&ensp;<code>Position</code></dt>
<dd>The start position of the path</dd>
<dt><strong><code>path_vector</code></strong> :&ensp;<code>Vector</code></dt>
<dd>The vector (not unit vector) describing the path from the start point
to the end point, i.e. <code>end_point = start_point + path_vector</code> or
<code>path_vector = end_point - start_point</code>.</dd>
<dt><strong><code>elevation</code></strong> :&ensp;<code>float</code></dt>
<dd>The elevation of the end point of the path relative to the start point</dd>
<dt><strong><code>max_length</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The maximum distance from the start point to the point of closest
approach, by default infinity (np.infty). It is generally useful to
specify that the length of the path is the maximum distance, otherwise
this algorithm will find a point of closest approach beyond the end point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Position</code></dt>
<dd>The point of closest approach along the path.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_point_closest_approach(
    start_point: Position,
    path_vector: Vector,
    elevation: float,
    max_length: float = np.infty,
) -&gt; Position:
    &#34;&#34;&#34;Get the point along the path that is is closest to Earth.

    Compute the point along the path that it is closest to the spherical Earth

    Parameters
    ----------
    start_point : Position
        The start position of the path
    path_vector : Vector
        The vector (not unit vector) describing the path from the start point
        to the end point, i.e. `end_point = start_point + path_vector` or
        `path_vector = end_point - start_point`.
    elevation : float
        The elevation of the end point of the path relative to the start point
    max_length : float, optional
        The maximum distance from the start point to the point of closest
        approach, by default infinity (np.infty). It is generally useful to
        specify that the length of the path is the maximum distance, otherwise
        this algorithm will find a point of closest approach beyond the end point.

    Returns
    -------
    Position
        The point of closest approach along the path.

    &#34;&#34;&#34;
    if elevation &gt;= 0:
        logger.warning(
            &#34;Attempted to find closest approach when the end point was above &#34;
            &#34;the start point&#39;s horizon. Because the path starts at the start &#34;
            &#34;point and the path moves away from the Earth, the start point &#34;
            &#34;is by definition the point of closest approach.&#34;
        )
        return start_point
    else:
        dc = start_point.get_radius() * np.sin(-elevation)

        if dc &gt; max_length:
            dc = max_length

        return start_point + (path_vector * (dc / path_vector.magnitude))</code></pre>
</details>
</dd>
<dt id="gps_frames.paths.get_points_along_path"><code class="name flex">
<span>def <span class="ident">get_points_along_path</span></span>(<span>start_point: <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>, end_point: <a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>, num_points: int) ‑> List[<a title="gps_frames.position.Position" href="position.html#gps_frames.position.Position">Position</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get evenly space points along the path.</p>
<p>Get a list of evenly spaced points along a path. This list includes the
start and end points, so the number of points along the path must be at
least 2 (the start and end points).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start_point</code></strong> :&ensp;<code>Position</code></dt>
<dd>The starting position of the path</dd>
<dt><strong><code>end_point</code></strong> :&ensp;<code>Position</code></dt>
<dd>The ending position of the path</dd>
<dt><strong><code>num_points</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of points to return along the path.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Position]</code></dt>
<dd>A list of points along the path, including the start and end points.
The length of the returned list is num_points.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If num_points &lt; 2</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_points_along_path(
    start_point: Position, end_point: Position, num_points: int
) -&gt; List[Position]:
    &#34;&#34;&#34;Get evenly space points along the path.

    Get a list of evenly spaced points along a path. This list includes the
    start and end points, so the number of points along the path must be at
    least 2 (the start and end points).

    Parameters
    ----------
    start_point : Position
        The starting position of the path
    end_point : Position
        The ending position of the path
    num_points : int
        The number of points to return along the path.

    Returns
    -------
    List[Position]
        A list of points along the path, including the start and end points.
        The length of the returned list is num_points.

    Raises
    ------
    ValueError
        If num_points &lt; 2
    &#34;&#34;&#34;
    if num_points &lt; 2:
        raise ValueError(&#34;num_points must be &gt;= 2&#34;)

    start_vector = start_point.to_vector()
    end_vector = end_point.to_vector()

    path_vector = end_vector - start_vector
    path_length = path_vector.magnitude

    return [
        start_point + (path_vector * (_d / path_length))
        for _d in np.linspace(0, path_length, num_points)
    ]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gps_frames" href="index.html">gps_frames</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gps_frames.paths.get_altitude_intersection_point" href="#gps_frames.paths.get_altitude_intersection_point">get_altitude_intersection_point</a></code></li>
<li><code><a title="gps_frames.paths.get_distance_between_points" href="#gps_frames.paths.get_distance_between_points">get_distance_between_points</a></code></li>
<li><code><a title="gps_frames.paths.get_point_closest_approach" href="#gps_frames.paths.get_point_closest_approach">get_point_closest_approach</a></code></li>
<li><code><a title="gps_frames.paths.get_points_along_path" href="#gps_frames.paths.get_points_along_path">get_points_along_path</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>