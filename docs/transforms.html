<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gps_frames.transforms API documentation</title>
<meta name="description" content="Frame Transformations â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gps_frames.transforms</code></h1>
</header>
<section id="section-intro">
<p>Frame Transformations.</p>
<p>This submodule contains the mathematics used for translating between different
frames.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>Incorporate non-GPS standard frames, e.g. J2000</li>
<li>Include velocity transformations into the LLA frame</li>
<li>Add local coordinate systems, e.g. ENU</li>
<li>Make GPSTime JIT-able</li>
<li>Fix ECEF to LLA warning (currently a print for numba compatibility)</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2022 The Aerospace Corporation
&#34;&#34;&#34;Frame Transformations.

This submodule contains the mathematics used for translating between different
frames.

Todo
----
- Incorporate non-GPS standard frames, e.g. J2000
- Include velocity transformations into the LLA frame
- Add local coordinate systems, e.g. ENU
- Make GPSTime JIT-able
- Fix ECEF to LLA warning (currently a print for numba compatibility)

&#34;&#34;&#34;
import warnings
import numpy as np
import functools
from numba import jit

from logging import getLogger

from gps_time import GPSTime

from .parameters import EarthParam
from .rotations import (
    Rotation,  # noqa: F401
    standard_rotation,
    standard_rotation_matrix,
    standard_rotation_matrix_rates,
)

logger = getLogger(__name__)

VALID_FRAMES = [&#34;ECI&#34;, &#34;ECEF&#34;, &#34;LLA&#34;]
&#34;&#34;&#34;The frames implemented for this toolbox

This list contains the names of the frames available in this module. These
frames are

- ECI: The ECI frame aligned with the ECEF frame at the start of the week.
    When used, the coordinates refer to the X, Y, and Z positions in the
    frame in meters
- ECEF: The ECEF frame. When used, the coordinates refer to the X, Y, and
    Z positions in the frame in meters
- LLA: The WGS84 Latitude, Longitude, and Altitude. When used, the
    coordinates refer to the Latitude, Longitude, and Altitude in radians or
    meters as appropriate

Notes
-----
For consistency, all names must be in all caps.
&#34;&#34;&#34;

_wgs84a: float = EarthParam.wgs84a
_wgs84f: float = EarthParam.wgs84f
_wgs84ecc: float = EarthParam.wgs84ecc
_w_e: float = EarthParam.w_e


def velocity_transform(
    from_frame: str,
    to_frame: str,
    position_coordinates: np.ndarray,
    velocity_components: np.ndarray,
    time: GPSTime,
) -&gt; np.ndarray:
    &#34;&#34;&#34;Transform velocity from one frame to another.

    Parameters
    ----------
    from_frame : str
        The starting frame
    to_frame : str
        The desired frame
    position_coordinates : np.ndarray
        The position coordinates in the starting frame
    velocity_components : np.ndarray
        The velocity components in the starting from
    time : GPSTime
        The time that the transformation is taking place

    Returns
    -------
    np.ndarray
        The velocity components in the destination frame

    Raises
    ------
    ValueError
        Does not work with the &#39;LLA&#39; frame, so raises an error if the to_frame
        or from_frame are specified as &#39;LLA&#39;. Will also raise if the to_frame
        or from_frame are not valid frames.
    &#34;&#34;&#34;
    position_coordinates = np.array(position_coordinates)
    velocity_components = np.array(velocity_components)
    if from_frame == &#34;LLA&#34; or to_frame == &#34;LLA&#34;:
        raise ValueError(&#34;from_frame and to_frame cannot be LLA&#34;)

    if from_frame not in VALID_FRAMES:
        raise ValueError(f&#34;from_frame ({from_frame}) not valid&#34;)
    if to_frame not in VALID_FRAMES:
        raise ValueError(f&#34;to_frame ({to_frame}) not valid&#34;)

    if from_frame == &#34;ECEF&#34;:
        if to_frame == &#34;ECEF&#34;:
            angle_of_rotation = 0.0
            rotation_rate = 0.0
        elif to_frame == &#34;ECI&#34;:
            angle_of_rotation = -_w_e * time.time_of_week
            rotation_rate = -_w_e
    elif from_frame == &#34;ECI&#34;:
        if to_frame == &#34;ECEF&#34;:
            angle_of_rotation = _w_e * time.time_of_week
            rotation_rate = _w_e
        elif to_frame == &#34;ECI&#34;:
            angle_of_rotation = 0.0
            rotation_rate = 0.0

    rotation = Rotation(dcm=standard_rotation_matrix(3, angle_of_rotation))
    rate_matrix = standard_rotation_matrix_rates(3, angle_of_rotation, rotation_rate)

    return rotation.rotate(velocity_components) + rate_matrix @ position_coordinates


def position_transform(
    from_frame: str, to_frame: str, coordinates: np.array, time: GPSTime
) -&gt; np.array:
    &#34;&#34;&#34;Convert a position from one frame to another.

    The purpose of this function is to create a general tool to convert a
    position from one frame to another. The current frame is given as the
    `from_frame` and the desired new output frame is given as the `to_frame`.
    The position is defined in the `from_frame` as the `coordinates`. The
    `time` is used to define the time of the frame, as some conversions
    between frames vary with time, e.g. ECEF to ECI.

    Parameters
    ----------
    from_frame : str
        The frame in which the input coordinates are defined
    to_frame : str
        The frame that the coordinates should be provided in
    coordinates : np.ndarray
        The coordinates in the `from_frame`
    time : GPSTime
        The time at which the `from_frame` and `to_frame` are aligned.

    Returns
    -------
    np.ndarray
        The coordinates in the `to_frame`

    Raises
    ------
    NotImplementedError
        If the `from_frame` or `to_frame` are not valid frames

    See Also
    --------
    VALID_FRAMES: A list of the valid frames for the `from_frame` and
        `to_frame` args

    Notes
    -----
    This function is used to transform a position in one frame to another. The
    time is the same for both the `from_frame` and `to_frame`

    &#34;&#34;&#34;

    if not isinstance(coordinates, np.ndarray):
        coordinates = np.array(coordinates, dtype=float)
    if from_frame not in VALID_FRAMES:
        raise NotImplementedError(f&#34;(from_frame) Unknown Frame: {from_frame}&#34;)
    if to_frame not in VALID_FRAMES:
        raise NotImplementedError(f&#34;(to_frame) Unknown Frame: {to_frame}&#34;)

    if from_frame == &#34;LLA&#34;:
        if to_frame == &#34;LLA&#34;:
            return coordinates
        elif to_frame == &#34;ECEF&#34;:
            return lla2ecef(coordinates)
        elif to_frame == &#34;ECI&#34;:
            return lla2eci(coordinates, time.time_of_week)
    elif from_frame == &#34;ECEF&#34;:
        if to_frame == &#34;LLA&#34;:
            return ecef2lla(coordinates)
        elif to_frame == &#34;ECEF&#34;:
            return coordinates
        elif to_frame == &#34;ECI&#34;:
            return ecef2eci(coordinates, time.time_of_week)
    elif from_frame == &#34;ECI&#34;:
        if to_frame == &#34;LLA&#34;:
            return eci2lla(coordinates, time.time_of_week)
        elif to_frame == &#34;ECEF&#34;:
            return eci2ecef(coordinates, time.time_of_week)
        elif to_frame == &#34;ECI&#34;:
            return coordinates

    logger.critical(&#34;Transformation Failed. Returning input&#34;)
    return coordinates


@jit(&#34;float64[:](float64[:])&#34;, nopython=True)
def lla2ecef(lla_coordinates: np.array) -&gt; np.array:
    r&#34;&#34;&#34;Convert LLA to ECEF position.

    Computes the ECEF position based on the WGS84 ellipsoid latitude,
    longitude, and altitude. The inputs is are numpy arrays. Returns a
    numpy array with columns representing the ECEF positions of the
    elements of the inputs. From [1]_

    Let \(\lambda\), \(\phi\), \(h\), \(a\), and \(e\) be the latitude,
    longitude, altitude, WGS84 semi-major axis, and WGS84 eccentricity,
    repsectively. The effective radius of the Earth is
    $$
        n = \frac{a}{\sqrt{1 - (e\sin\lambda)^{2}}}
    $$
    From this, the ECEF \(x\), \(y\), and \(z\) positions can be computed as
    $$
        \begin{split}
            x = &amp; (n + h)\cos\lambda\cos\phi \\
            y = &amp; (n + h)\cos\lambda\sin\phi \\
            z = &amp; \left(n\left(1 - e^{2}\right) + h\right) \sin\lambda
        \end{split}
    $$

    Parameters
    ----------
    lla_coordinates : np.ndarray
        The WGS 84 latitude, longitude, and altitude (in that order)

    Returns
    -------
    np.ndarray
        The ECEF position of the given WGS84 LLA

    References
    ----------
    .. [1] G. Xu and Y. Xu, &#34;GPS: Theory, Algorithms and Applications&#34; 3rd ed.
        https://doi.org/10.1007/978-3-662-50367-6

    &#34;&#34;&#34;
    latitude = lla_coordinates[0]
    longitude = lla_coordinates[1]
    altitude = lla_coordinates[2]

    n = _wgs84a / np.sqrt(1 - (_wgs84ecc * np.sin(latitude)) ** 2)

    x = (n + altitude) * np.cos(latitude) * np.cos(longitude)
    y = (n + altitude) * np.cos(latitude) * np.sin(longitude)
    z = (n * (1 - _wgs84ecc ** 2) + altitude) * np.sin(latitude)

    return np.array((x, y, z))


@jit(&#34;float64[:](float64[:], float64)&#34;, nopython=True)
def ecef2eci(ecef_coordinates: np.ndarray, time_of_week: float) -&gt; np.ndarray:
    r&#34;&#34;&#34;Rotate from the ECEF to the ECI frame.

    This function rotates the ECEF coordinates into the ECI frame. Note that
    the ECI and ECEF frames are aligned at the start of the week.

    Let \(\boldsymbol{r}^{\mathcal{F}}\) be the position in the ECEF frame
    and \(t\) be the time of week. The angle of rotation between the ECI and
    ECEF frames is \(\Theta = \omega_{\oplus}t\), with \(\omega_{\oplus}\)
    being the angular velocity of the Earth. Thus, the position in the ECI
    coordinates is
    $$
        \boldsymbol{r}^{\mathcal{N}} =
            \left[\begin{array}{ccc}
                \cos -\Theta &amp; \sin -\Theta &amp; 0 \\
                -\sin -\Theta &amp; \cos -\Theta &amp; 0 \\
                0 &amp; 0 &amp; 1
            \end{array}\right]\boldsymbol{r}^{\mathcal{F}}
        =
            \left[\begin{array}{ccc}
                \cos \Theta &amp; -\sin \Theta &amp; 0 \\
                \sin \Theta &amp; \cos \Theta &amp; 0 \\
                0 &amp; 0 &amp; 1
            \end{array}\right]\boldsymbol{r}^{\mathcal{F}}
    $$

    Parameters
    ----------
    ecef_coordinates : np.ndarray
        The coordinates in the ECEF frame
    time : GPSTime
        The time associated with the ECEF frame

    Returns
    -------
    np.ndarray
        The coordinates in the ECI frame

    See Also
    --------
    standard_rotation_matrix: Used to get the rotation matrix for the
        transformation

    &#34;&#34;&#34;

    # Angle from the ECI to the ECEF frame
    angle_of_rotation = _w_e * time_of_week
    # rotation = Rotation(axis=np.array((0., 0., 1.)), angle=-angle_of_rotation)

    return standard_rotation(3, -angle_of_rotation, ecef_coordinates)


@jit(&#34;float64[:](float64[:], float64)&#34;, nopython=True)
def lla2eci(lla_coordinates: np.ndarray, time: float) -&gt; np.ndarray:
    &#34;&#34;&#34;Tranform LLA coordinates into ECI.

    This function is used to transform an LLA position into ECI coordinates.
    To do this, the coordinates are first converted to ECEF coordinates using
    `lla2ecef()`. Then, these new ECEF coordinates are transformed into ECI
    coordinates using `ecef2eci()`.

    Parameters
    ----------
    lla_coordinates : np.ndarray
        The Latitude, Longitude, Altitude position coordinates
    time : GPSTime
        The time at which the `lla_coordinates` are defined

    Returns
    -------
    np.ndarray
        The position in the ECI frame

    See Also
    --------
    lla2ecef: Convert LLA coordinates to ECEF coordinates
    ecef2eci: Convert ECEF coordinates into ECI coordinates

    &#34;&#34;&#34;
    return ecef2eci(lla2ecef(lla_coordinates), time)


@jit(&#34;float64(float64)&#34;, nopython=True)
def _ecef2lla_beta_func(latitude: float) -&gt; float:
    return np.arctan2((1 - _wgs84f) * np.sin(latitude), np.cos(latitude))


@jit(&#34;float64(float64, float64, float64)&#34;, nopython=True)
def _ecef2lla_latitude_func(s: float, z: float, beta: float) -&gt; float:
    num = (
        z
        + (_wgs84ecc ** 2 * (1 - _wgs84f) / (1 - _wgs84ecc ** 2))
        * _wgs84a
        * np.sin(beta) ** 3
    )
    den = s - _wgs84ecc ** 2 * _wgs84a * np.cos(beta) ** 3

    return np.arctan2(num, den)


@jit(&#34;float64[:](float64[:])&#34;, nopython=True)
def ecef2lla(ecef_coordinates: np.ndarray) -&gt; np.ndarray:
    r&#34;&#34;&#34;Transform an ECEF position to LLA position.

    The purpose of this function is to convert a position in the ECEF frame to
    the LLA frame relative to the WGS84 ellipsoid. Let the coordinates in the
    ECEF frame be
    \(\boldsymbol{r}^{\mathcal{F}} = [r_{x}, r_{y}, r_{z}]^{T}\). The
    longitude is calculated as
    $$
        \phi = \arctan\left(\frac{p_{y}}{p_{x}}\right)
    $$
    Note that a 4-quadrant arctangent function should be used to avoid
    ambiguity.

    The latitude cannot be solved analytically and must be solved numerically.
    The initial guesses for the geodetic latitude \(\lambda\) and reduced
    latitude \(\beta\) are
    $$
        \begin{split}
            \beta = &amp; \arctan\left(\frac{p_{z}}{(1-f)s}\right) \\
            \lambda = &amp; \arctan\left(
                    \frac{
                        p_{z} + \frac{e^{2}(1-f)}{1-e^{2}}a\sin^{3}\beta
                    }{
                        s - e^{2}a\cos^{3}\beta
                    }
                \right)
        \end{split}
    $$
    where \(a\) is the semi-major axis of the WGS84 ellipsoid, \(f\) is the
    flattening of the ellipsoid, \(e^{2}=1-(1-f)^{2}\), and
    \(s = \sqrt{p_{x}^{2} + p_{y}^{2}}\).

    Using the initial guesses, an update to the reduced latitude can be
    calculated as
    $$
        \beta = \arctan\left(
                \frac{(1 - f)\sin\lambda}{\cos\lambda}
            \right)
    $$
    which can in turn be used to update \(\lambda\). This cycle continues
    until \(\lambda\) converges ([1]_ claims this usually takes 2-3
    iterations).

    From here, it is possible to compute the altitude directly:
    $$
        h = s \cos\lambda + (p_{z} + e^{2}n\sin\lambda)\sin\lambda - n
    $$
    where \(n\) is the radius of curvature in the vertical prime
    $$
        n = \frac{a}{\sqrt{1 - (e\sin\lambda)^{2}}}
    $$

    This function is based on the development provided by [1]_

    .. todo:: 
        If the latitude does not converge, this function prints a warning 
        instead of using the logger. This is necessary because of use of
        Numba. In the future, this should be changed to logging a warning
        message.

    Parameters
    ----------
    ecef_coordinates : np.ndarray
        The coordinates in the ECEF frame

    Returns
    -------
    np.ndarray
        The latitude, longitude, altitude coordinates.

    References
    ----------
    .. [1] MathWorks Aerospace Blockset
        https://www.mathworks.com/help/aeroblks/ecefpositiontolla.html

    &#34;&#34;&#34;
    x = ecef_coordinates[0]
    y = ecef_coordinates[1]
    z = ecef_coordinates[2]

    longitude = np.arctan2(y, x)

    max_iterations = 5
    desired_accuracy = 1e-15

    s = np.sqrt(x ** 2 + y ** 2)

    beta = np.arctan2(z, (1 - _wgs84f) * s)
    latitude = _ecef2lla_latitude_func(s, z, beta)

    for ii in range(max_iterations):
        old_latitude = latitude

        beta = _ecef2lla_beta_func(latitude)
        latitude = _ecef2lla_latitude_func(s, z, beta)

        if np.abs(latitude - old_latitude) &lt;= desired_accuracy:
            break

    else:
        print(
            &#34;ecef2lla &gt;&gt; WARNING: latitude did not converge: &#34;,
            latitude - old_latitude,
        )

    # logger.debug(f&#34;ecef2lla took {ii} iterations to converge.&#34;)

    n = _wgs84a / np.sqrt(1 - _wgs84ecc ** 2 * np.sin(latitude) ** 2)

    altitude = (
        s * np.cos(latitude)
        + (z + _wgs84ecc ** 2 * n * np.sin(latitude)) * np.sin(latitude)
        - n
    )

    return np.array((latitude, longitude, altitude))


@jit(&#34;float64[:](float64[:], float64)&#34;, nopython=True)
def eci2ecef(eci_coordinates: np.ndarray, time_of_week: float) -&gt; np.ndarray:
    r&#34;&#34;&#34;Rotate from the ECI to the ECEF frame.

    This function rotates the ECI coordinates into the ECEF frame. Note that
    the ECI and ECEF frames are aligned at the start of the week.

    Let \(\boldsymbol{r}^{\mathcal{N}}\) be the position in the ECI frame
    and \(t\) be the time of week. The angle of rotation between the ECI and
    ECEF frames is \(\Theta = \omega_{\oplus}t\), with \(\omega_{\oplus}\)
    being the angular velocity of the Earth. Thus, the position in the ECEF
    coordinates is
    $$
        \boldsymbol{r}^{\mathcal{F}} =
            \left[\begin{array}{ccc}
                \cos \Theta &amp; \sin \Theta &amp; 0 \\
                -\sin \Theta &amp; \cos \Theta &amp; 0 \\
                0 &amp; 0 &amp; 1
            \end{array}\right]\boldsymbol{r}^{\mathcal{N}}
    $$

    Parameters
    ----------
    ecef_coordinates : np.ndarray
        The coordinates in the ECEF frame
    time : GPSTime
        The time associated with the ECEF frame

    Returns
    -------
    np.ndarray
        The coordinates in the ECI frame

    See Also
    --------
    standard_rotation_matrix: Used to get the rotation matrix for the
        transformation

    &#34;&#34;&#34;
    # Angle from the ECI to the ECEF frame
    angle_of_rotation = _w_e * time_of_week
    # rotation = Rotation(axis=np.array((0., 0., 1.)), angle=angle_of_rotation)

    return standard_rotation(3, angle_of_rotation, eci_coordinates)


@jit(&#34;float64[:](float64[:], float64)&#34;, nopython=True)
def eci2lla(eci_coordinates: np.ndarray, time: GPSTime) -&gt; np.ndarray:
    &#34;&#34;&#34;Transform the ECI coordinates into an LLA position.

    The purpose of this function is to transform ECI coordinates into LLA
    coordinates. It does to by calling `eci2ecef()` and `ecef2lla()`

    Parameters
    ----------
    eci_coordinates : np.ndarray
        The ECI coordinates
    time : GPSTime
        The time for which to get the LLA

    Returns
    -------
    np.ndarray
        The Latitude, Longitude, Altitude coordinates (WGS84)

    See Also
    --------
    eci2ecef: Convert coordinates (and time) to ECEF frame
    ecef2lla: Convert ECEF coordinates to LLA position

    &#34;&#34;&#34;
    return ecef2lla(eci2ecef(eci_coordinates, time))


@jit(&#34;float64[:](int64, float64[:])&#34;, nopython=True)
def add_weeks_eci(num_weeks: int, coordinates: np.ndarray) -&gt; np.ndarray:
    r&#34;&#34;&#34;Move ECI frame to new week.

    Because the ECI frame is reference to the start of the week, if the frame
    is moved to a new week, the coordinates change. The purpose of this
    function is to update the ECI frame by moving forward `num_weeks` weeks
    (or backward is `num_weeks` is negative.

    This is accomplished by rotating the frame about the 3 axis by an angle of
    \(\omega_{\oplus}T\) where \(\omega_{\oplus}\) is the angular velocity
    of the Earth and \(T\) is the length of a week times the number of weeks
    to advance.

    Parameters
    ----------
    num_weeks : int
        The number of weeks to advance the ECI frame
    coordinates : np.ndarray
        The coordinates in the initial ECI frame

    Returns
    -------
    np.ndarray
        The coordinates in the new ECI frame

    See Also
    --------
    standard_rotation_matrix: Used to get the rotation matrix for the
        transformation

    &#34;&#34;&#34;
    if num_weeks == 0:
        return coordinates
    else:
        # How far the Earth rotates in a week
        # coordinates = np.array(coordinates, dtype=float)
        weekly_eci_rotation = _w_e * 604800 * num_weeks

        # rotation = Rotation(
        #     dcm=standard_rotation_matrix(3, weekly_eci_rotation))

        return standard_rotation(3, weekly_eci_rotation, coordinates)


def rotate_ecef(
    old_time: GPSTime, new_time: GPSTime, coordinates: np.ndarray
) -&gt; np.ndarray:
    &#34;&#34;&#34;Rotate the coordinates in one ECEF frame to a new ECEF frame.

    Because the Earth is rotating, the ECEF frame is constantly moving and the
    coordinates in the ECEF frame at one time are different than the
    coordinates at some other time. This function uses the time between
    `old_time` and `new_time` to determine how much the ECEF frame rotates and
    updates the coordinates accordingly.

    Parameters
    ----------
    old_time : GPSTime
        The time for the ECEF frame where the `coordinates` are defined
    new_time : GPSTime
        The time of the new ECEF frame
    coordinates : np.ndarray
        The coordinates in the `old_time` ECEF frame

    Returns
    -------
    np.ndarray
        The coordinates in the `new_time` ECEF frame

    See Also
    --------
    standard_rotation_matrix: Used to get the rotation matrix for the
        transformation

    &#34;&#34;&#34;
    time_delta = new_time - old_time
    assert isinstance(time_delta, float)

    angle_delta = _w_e * time_delta
    coordinates = np.array(coordinates, dtype=float)

    # rotation = Rotation(dcm=standard_rotation_matrix(3, angle_delta))

    return standard_rotation(3, angle_delta, coordinates)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="gps_frames.transforms.VALID_FRAMES"><code class="name">var <span class="ident">VALID_FRAMES</span></code></dt>
<dd>
<div class="desc"><p>The frames implemented for this toolbox</p>
<p>This list contains the names of the frames available in this module. These
frames are</p>
<ul>
<li>ECI: The ECI frame aligned with the ECEF frame at the start of the week.
When used, the coordinates refer to the X, Y, and Z positions in the
frame in meters</li>
<li>ECEF: The ECEF frame. When used, the coordinates refer to the X, Y, and
Z positions in the frame in meters</li>
<li>LLA: The WGS84 Latitude, Longitude, and Altitude. When used, the
coordinates refer to the Latitude, Longitude, and Altitude in radians or
meters as appropriate</li>
</ul>
<h2 id="notes">Notes</h2>
<p>For consistency, all names must be in all caps.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gps_frames.transforms.add_weeks_eci"><code class="name flex">
<span>def <span class="ident">add_weeks_eci</span></span>(<span>num_weeks:Â int, coordinates:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Move ECI frame to new week.</p>
<p>Because the ECI frame is reference to the start of the week, if the frame
is moved to a new week, the coordinates change. The purpose of this
function is to update the ECI frame by moving forward <code>num_weeks</code> weeks
(or backward is <code>num_weeks</code> is negative.</p>
<p>This is accomplished by rotating the frame about the 3 axis by an angle of
<span><span class="MathJax_Preview">\omega_{\oplus}T</span><script type="math/tex">\omega_{\oplus}T</script></span> where <span><span class="MathJax_Preview">\omega_{\oplus}</span><script type="math/tex">\omega_{\oplus}</script></span> is the angular velocity
of the Earth and <span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span> is the length of a week times the number of weeks
to advance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num_weeks</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of weeks to advance the ECI frame</dd>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The coordinates in the initial ECI frame</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The coordinates in the new ECI frame</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>standard_rotation_matrix</code></dt>
<dd>Used to get the rotation matrix for the transformation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(&#34;float64[:](int64, float64[:])&#34;, nopython=True)
def add_weeks_eci(num_weeks: int, coordinates: np.ndarray) -&gt; np.ndarray:
    r&#34;&#34;&#34;Move ECI frame to new week.

    Because the ECI frame is reference to the start of the week, if the frame
    is moved to a new week, the coordinates change. The purpose of this
    function is to update the ECI frame by moving forward `num_weeks` weeks
    (or backward is `num_weeks` is negative.

    This is accomplished by rotating the frame about the 3 axis by an angle of
    \(\omega_{\oplus}T\) where \(\omega_{\oplus}\) is the angular velocity
    of the Earth and \(T\) is the length of a week times the number of weeks
    to advance.

    Parameters
    ----------
    num_weeks : int
        The number of weeks to advance the ECI frame
    coordinates : np.ndarray
        The coordinates in the initial ECI frame

    Returns
    -------
    np.ndarray
        The coordinates in the new ECI frame

    See Also
    --------
    standard_rotation_matrix: Used to get the rotation matrix for the
        transformation

    &#34;&#34;&#34;
    if num_weeks == 0:
        return coordinates
    else:
        # How far the Earth rotates in a week
        # coordinates = np.array(coordinates, dtype=float)
        weekly_eci_rotation = _w_e * 604800 * num_weeks

        # rotation = Rotation(
        #     dcm=standard_rotation_matrix(3, weekly_eci_rotation))

        return standard_rotation(3, weekly_eci_rotation, coordinates)</code></pre>
</details>
</dd>
<dt id="gps_frames.transforms.ecef2eci"><code class="name flex">
<span>def <span class="ident">ecef2eci</span></span>(<span>ecef_coordinates:Â numpy.ndarray, time_of_week:Â float) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate from the ECEF to the ECI frame.</p>
<p>This function rotates the ECEF coordinates into the ECI frame. Note that
the ECI and ECEF frames are aligned at the start of the week.</p>
<p>Let <span><span class="MathJax_Preview">\boldsymbol{r}^{\mathcal{F}}</span><script type="math/tex">\boldsymbol{r}^{\mathcal{F}}</script></span> be the position in the ECEF frame
and <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> be the time of week. The angle of rotation between the ECI and
ECEF frames is <span><span class="MathJax_Preview">\Theta = \omega_{\oplus}t</span><script type="math/tex">\Theta = \omega_{\oplus}t</script></span>, with <span><span class="MathJax_Preview">\omega_{\oplus}</span><script type="math/tex">\omega_{\oplus}</script></span>
being the angular velocity of the Earth. Thus, the position in the ECI
coordinates is
<span><span class="MathJax_Preview">
\boldsymbol{r}^{\mathcal{N}} =
\left[\begin{array}{ccc}
\cos -\Theta &amp; \sin -\Theta &amp; 0 \\
-\sin -\Theta &amp; \cos -\Theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{array}\right]\boldsymbol{r}^{\mathcal{F}}
=
\left[\begin{array}{ccc}
\cos \Theta &amp; -\sin \Theta &amp; 0 \\
\sin \Theta &amp; \cos \Theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{array}\right]\boldsymbol{r}^{\mathcal{F}}
</span><script type="math/tex; mode=display">
\boldsymbol{r}^{\mathcal{N}} =
\left[\begin{array}{ccc}
\cos -\Theta & \sin -\Theta & 0 \\
-\sin -\Theta & \cos -\Theta & 0 \\
0 & 0 & 1
\end{array}\right]\boldsymbol{r}^{\mathcal{F}}
=
\left[\begin{array}{ccc}
\cos \Theta & -\sin \Theta & 0 \\
\sin \Theta & \cos \Theta & 0 \\
0 & 0 & 1
\end{array}\right]\boldsymbol{r}^{\mathcal{F}}
</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ecef_coordinates</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The coordinates in the ECEF frame</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>GPSTime</code></dt>
<dd>The time associated with the ECEF frame</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The coordinates in the ECI frame</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>standard_rotation_matrix</code></dt>
<dd>Used to get the rotation matrix for the transformation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(&#34;float64[:](float64[:], float64)&#34;, nopython=True)
def ecef2eci(ecef_coordinates: np.ndarray, time_of_week: float) -&gt; np.ndarray:
    r&#34;&#34;&#34;Rotate from the ECEF to the ECI frame.

    This function rotates the ECEF coordinates into the ECI frame. Note that
    the ECI and ECEF frames are aligned at the start of the week.

    Let \(\boldsymbol{r}^{\mathcal{F}}\) be the position in the ECEF frame
    and \(t\) be the time of week. The angle of rotation between the ECI and
    ECEF frames is \(\Theta = \omega_{\oplus}t\), with \(\omega_{\oplus}\)
    being the angular velocity of the Earth. Thus, the position in the ECI
    coordinates is
    $$
        \boldsymbol{r}^{\mathcal{N}} =
            \left[\begin{array}{ccc}
                \cos -\Theta &amp; \sin -\Theta &amp; 0 \\
                -\sin -\Theta &amp; \cos -\Theta &amp; 0 \\
                0 &amp; 0 &amp; 1
            \end{array}\right]\boldsymbol{r}^{\mathcal{F}}
        =
            \left[\begin{array}{ccc}
                \cos \Theta &amp; -\sin \Theta &amp; 0 \\
                \sin \Theta &amp; \cos \Theta &amp; 0 \\
                0 &amp; 0 &amp; 1
            \end{array}\right]\boldsymbol{r}^{\mathcal{F}}
    $$

    Parameters
    ----------
    ecef_coordinates : np.ndarray
        The coordinates in the ECEF frame
    time : GPSTime
        The time associated with the ECEF frame

    Returns
    -------
    np.ndarray
        The coordinates in the ECI frame

    See Also
    --------
    standard_rotation_matrix: Used to get the rotation matrix for the
        transformation

    &#34;&#34;&#34;

    # Angle from the ECI to the ECEF frame
    angle_of_rotation = _w_e * time_of_week
    # rotation = Rotation(axis=np.array((0., 0., 1.)), angle=-angle_of_rotation)

    return standard_rotation(3, -angle_of_rotation, ecef_coordinates)</code></pre>
</details>
</dd>
<dt id="gps_frames.transforms.ecef2lla"><code class="name flex">
<span>def <span class="ident">ecef2lla</span></span>(<span>ecef_coordinates:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transform an ECEF position to LLA position.</p>
<p>The purpose of this function is to convert a position in the ECEF frame to
the LLA frame relative to the WGS84 ellipsoid. Let the coordinates in the
ECEF frame be
<span><span class="MathJax_Preview">\boldsymbol{r}^{\mathcal{F}} = [r_{x}, r_{y}, r_{z}]^{T}</span><script type="math/tex">\boldsymbol{r}^{\mathcal{F}} = [r_{x}, r_{y}, r_{z}]^{T}</script></span>. The
longitude is calculated as
<span><span class="MathJax_Preview">
\phi = \arctan\left(\frac{p_{y}}{p_{x}}\right)
</span><script type="math/tex; mode=display">
\phi = \arctan\left(\frac{p_{y}}{p_{x}}\right)
</script></span>
Note that a 4-quadrant arctangent function should be used to avoid
ambiguity.</p>
<p>The latitude cannot be solved analytically and must be solved numerically.
The initial guesses for the geodetic latitude <span><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span> and reduced
latitude <span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span> are
<span><span class="MathJax_Preview">
\begin{split}
\beta = &amp; \arctan\left(\frac{p_{z}}{(1-f)s}\right) \\
\lambda = &amp; \arctan\left(
\frac{
p_{z} + \frac{e^{2}(1-f)}{1-e^{2}}a\sin^{3}\beta
}{
s - e^{2}a\cos^{3}\beta
}
\right)
\end{split}
</span><script type="math/tex; mode=display">
\begin{split}
\beta = & \arctan\left(\frac{p_{z}}{(1-f)s}\right) \\
\lambda = & \arctan\left(
\frac{
p_{z} + \frac{e^{2}(1-f)}{1-e^{2}}a\sin^{3}\beta
}{
s - e^{2}a\cos^{3}\beta
}
\right)
\end{split}
</script></span>
where <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> is the semi-major axis of the WGS84 ellipsoid, <span><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> is the
flattening of the ellipsoid, <span><span class="MathJax_Preview">e^{2}=1-(1-f)^{2}</span><script type="math/tex">e^{2}=1-(1-f)^{2}</script></span>, and
<span><span class="MathJax_Preview">s = \sqrt{p_{x}^{2} + p_{y}^{2}}</span><script type="math/tex">s = \sqrt{p_{x}^{2} + p_{y}^{2}}</script></span>.</p>
<p>Using the initial guesses, an update to the reduced latitude can be
calculated as
<span><span class="MathJax_Preview">
\beta = \arctan\left(
\frac{(1 - f)\sin\lambda}{\cos\lambda}
\right)
</span><script type="math/tex; mode=display">
\beta = \arctan\left(
\frac{(1 - f)\sin\lambda}{\cos\lambda}
\right)
</script></span>
which can in turn be used to update <span><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>. This cycle continues
until <span><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span> converges ([1]_ claims this usually takes 2-3
iterations).</p>
<p>From here, it is possible to compute the altitude directly:
<span><span class="MathJax_Preview">
h = s \cos\lambda + (p_{z} + e^{2}n\sin\lambda)\sin\lambda - n
</span><script type="math/tex; mode=display">
h = s \cos\lambda + (p_{z} + e^{2}n\sin\lambda)\sin\lambda - n
</script></span>
where <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> is the radius of curvature in the vertical prime
<span><span class="MathJax_Preview">
n = \frac{a}{\sqrt{1 - (e\sin\lambda)^{2}}}
</span><script type="math/tex; mode=display">
n = \frac{a}{\sqrt{1 - (e\sin\lambda)^{2}}}
</script></span></p>
<p>This function is based on the development provided by [1]_</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>If the latitude does not converge, this function prints a warning
instead of using the logger. This is necessary because of use of
Numba. In the future, this should be changed to logging a warning
message.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ecef_coordinates</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The coordinates in the ECEF frame</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The latitude, longitude, altitude coordinates.</dd>
</dl>
<h2 id="references">References</h2>
<p>.. [1] MathWorks Aerospace Blockset
<a href="https://www.mathworks.com/help/aeroblks/ecefpositiontolla.html">https://www.mathworks.com/help/aeroblks/ecefpositiontolla.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(&#34;float64[:](float64[:])&#34;, nopython=True)
def ecef2lla(ecef_coordinates: np.ndarray) -&gt; np.ndarray:
    r&#34;&#34;&#34;Transform an ECEF position to LLA position.

    The purpose of this function is to convert a position in the ECEF frame to
    the LLA frame relative to the WGS84 ellipsoid. Let the coordinates in the
    ECEF frame be
    \(\boldsymbol{r}^{\mathcal{F}} = [r_{x}, r_{y}, r_{z}]^{T}\). The
    longitude is calculated as
    $$
        \phi = \arctan\left(\frac{p_{y}}{p_{x}}\right)
    $$
    Note that a 4-quadrant arctangent function should be used to avoid
    ambiguity.

    The latitude cannot be solved analytically and must be solved numerically.
    The initial guesses for the geodetic latitude \(\lambda\) and reduced
    latitude \(\beta\) are
    $$
        \begin{split}
            \beta = &amp; \arctan\left(\frac{p_{z}}{(1-f)s}\right) \\
            \lambda = &amp; \arctan\left(
                    \frac{
                        p_{z} + \frac{e^{2}(1-f)}{1-e^{2}}a\sin^{3}\beta
                    }{
                        s - e^{2}a\cos^{3}\beta
                    }
                \right)
        \end{split}
    $$
    where \(a\) is the semi-major axis of the WGS84 ellipsoid, \(f\) is the
    flattening of the ellipsoid, \(e^{2}=1-(1-f)^{2}\), and
    \(s = \sqrt{p_{x}^{2} + p_{y}^{2}}\).

    Using the initial guesses, an update to the reduced latitude can be
    calculated as
    $$
        \beta = \arctan\left(
                \frac{(1 - f)\sin\lambda}{\cos\lambda}
            \right)
    $$
    which can in turn be used to update \(\lambda\). This cycle continues
    until \(\lambda\) converges ([1]_ claims this usually takes 2-3
    iterations).

    From here, it is possible to compute the altitude directly:
    $$
        h = s \cos\lambda + (p_{z} + e^{2}n\sin\lambda)\sin\lambda - n
    $$
    where \(n\) is the radius of curvature in the vertical prime
    $$
        n = \frac{a}{\sqrt{1 - (e\sin\lambda)^{2}}}
    $$

    This function is based on the development provided by [1]_

    .. todo:: 
        If the latitude does not converge, this function prints a warning 
        instead of using the logger. This is necessary because of use of
        Numba. In the future, this should be changed to logging a warning
        message.

    Parameters
    ----------
    ecef_coordinates : np.ndarray
        The coordinates in the ECEF frame

    Returns
    -------
    np.ndarray
        The latitude, longitude, altitude coordinates.

    References
    ----------
    .. [1] MathWorks Aerospace Blockset
        https://www.mathworks.com/help/aeroblks/ecefpositiontolla.html

    &#34;&#34;&#34;
    x = ecef_coordinates[0]
    y = ecef_coordinates[1]
    z = ecef_coordinates[2]

    longitude = np.arctan2(y, x)

    max_iterations = 5
    desired_accuracy = 1e-15

    s = np.sqrt(x ** 2 + y ** 2)

    beta = np.arctan2(z, (1 - _wgs84f) * s)
    latitude = _ecef2lla_latitude_func(s, z, beta)

    for ii in range(max_iterations):
        old_latitude = latitude

        beta = _ecef2lla_beta_func(latitude)
        latitude = _ecef2lla_latitude_func(s, z, beta)

        if np.abs(latitude - old_latitude) &lt;= desired_accuracy:
            break

    else:
        print(
            &#34;ecef2lla &gt;&gt; WARNING: latitude did not converge: &#34;,
            latitude - old_latitude,
        )

    # logger.debug(f&#34;ecef2lla took {ii} iterations to converge.&#34;)

    n = _wgs84a / np.sqrt(1 - _wgs84ecc ** 2 * np.sin(latitude) ** 2)

    altitude = (
        s * np.cos(latitude)
        + (z + _wgs84ecc ** 2 * n * np.sin(latitude)) * np.sin(latitude)
        - n
    )

    return np.array((latitude, longitude, altitude))</code></pre>
</details>
</dd>
<dt id="gps_frames.transforms.eci2ecef"><code class="name flex">
<span>def <span class="ident">eci2ecef</span></span>(<span>eci_coordinates:Â numpy.ndarray, time_of_week:Â float) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate from the ECI to the ECEF frame.</p>
<p>This function rotates the ECI coordinates into the ECEF frame. Note that
the ECI and ECEF frames are aligned at the start of the week.</p>
<p>Let <span><span class="MathJax_Preview">\boldsymbol{r}^{\mathcal{N}}</span><script type="math/tex">\boldsymbol{r}^{\mathcal{N}}</script></span> be the position in the ECI frame
and <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> be the time of week. The angle of rotation between the ECI and
ECEF frames is <span><span class="MathJax_Preview">\Theta = \omega_{\oplus}t</span><script type="math/tex">\Theta = \omega_{\oplus}t</script></span>, with <span><span class="MathJax_Preview">\omega_{\oplus}</span><script type="math/tex">\omega_{\oplus}</script></span>
being the angular velocity of the Earth. Thus, the position in the ECEF
coordinates is
<span><span class="MathJax_Preview">
\boldsymbol{r}^{\mathcal{F}} =
\left[\begin{array}{ccc}
\cos \Theta &amp; \sin \Theta &amp; 0 \\
-\sin \Theta &amp; \cos \Theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{array}\right]\boldsymbol{r}^{\mathcal{N}}
</span><script type="math/tex; mode=display">
\boldsymbol{r}^{\mathcal{F}} =
\left[\begin{array}{ccc}
\cos \Theta & \sin \Theta & 0 \\
-\sin \Theta & \cos \Theta & 0 \\
0 & 0 & 1
\end{array}\right]\boldsymbol{r}^{\mathcal{N}}
</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ecef_coordinates</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The coordinates in the ECEF frame</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>GPSTime</code></dt>
<dd>The time associated with the ECEF frame</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The coordinates in the ECI frame</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>standard_rotation_matrix</code></dt>
<dd>Used to get the rotation matrix for the transformation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(&#34;float64[:](float64[:], float64)&#34;, nopython=True)
def eci2ecef(eci_coordinates: np.ndarray, time_of_week: float) -&gt; np.ndarray:
    r&#34;&#34;&#34;Rotate from the ECI to the ECEF frame.

    This function rotates the ECI coordinates into the ECEF frame. Note that
    the ECI and ECEF frames are aligned at the start of the week.

    Let \(\boldsymbol{r}^{\mathcal{N}}\) be the position in the ECI frame
    and \(t\) be the time of week. The angle of rotation between the ECI and
    ECEF frames is \(\Theta = \omega_{\oplus}t\), with \(\omega_{\oplus}\)
    being the angular velocity of the Earth. Thus, the position in the ECEF
    coordinates is
    $$
        \boldsymbol{r}^{\mathcal{F}} =
            \left[\begin{array}{ccc}
                \cos \Theta &amp; \sin \Theta &amp; 0 \\
                -\sin \Theta &amp; \cos \Theta &amp; 0 \\
                0 &amp; 0 &amp; 1
            \end{array}\right]\boldsymbol{r}^{\mathcal{N}}
    $$

    Parameters
    ----------
    ecef_coordinates : np.ndarray
        The coordinates in the ECEF frame
    time : GPSTime
        The time associated with the ECEF frame

    Returns
    -------
    np.ndarray
        The coordinates in the ECI frame

    See Also
    --------
    standard_rotation_matrix: Used to get the rotation matrix for the
        transformation

    &#34;&#34;&#34;
    # Angle from the ECI to the ECEF frame
    angle_of_rotation = _w_e * time_of_week
    # rotation = Rotation(axis=np.array((0., 0., 1.)), angle=angle_of_rotation)

    return standard_rotation(3, angle_of_rotation, eci_coordinates)</code></pre>
</details>
</dd>
<dt id="gps_frames.transforms.eci2lla"><code class="name flex">
<span>def <span class="ident">eci2lla</span></span>(<span>eci_coordinates:Â numpy.ndarray, time:Â gps_time.core.GPSTime) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the ECI coordinates into an LLA position.</p>
<p>The purpose of this function is to transform ECI coordinates into LLA
coordinates. It does to by calling <code><a title="gps_frames.transforms.eci2ecef" href="#gps_frames.transforms.eci2ecef">eci2ecef()</a></code> and <code><a title="gps_frames.transforms.ecef2lla" href="#gps_frames.transforms.ecef2lla">ecef2lla()</a></code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eci_coordinates</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The ECI coordinates</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>GPSTime</code></dt>
<dd>The time for which to get the LLA</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The Latitude, Longitude, Altitude coordinates (WGS84)</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="gps_frames.transforms.eci2ecef" href="#gps_frames.transforms.eci2ecef">eci2ecef()</a></code></dt>
<dd>Convert coordinates (and time) to ECEF frame</dd>
<dt><code><a title="gps_frames.transforms.ecef2lla" href="#gps_frames.transforms.ecef2lla">ecef2lla()</a></code></dt>
<dd>Convert ECEF coordinates to LLA position</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(&#34;float64[:](float64[:], float64)&#34;, nopython=True)
def eci2lla(eci_coordinates: np.ndarray, time: GPSTime) -&gt; np.ndarray:
    &#34;&#34;&#34;Transform the ECI coordinates into an LLA position.

    The purpose of this function is to transform ECI coordinates into LLA
    coordinates. It does to by calling `eci2ecef()` and `ecef2lla()`

    Parameters
    ----------
    eci_coordinates : np.ndarray
        The ECI coordinates
    time : GPSTime
        The time for which to get the LLA

    Returns
    -------
    np.ndarray
        The Latitude, Longitude, Altitude coordinates (WGS84)

    See Also
    --------
    eci2ecef: Convert coordinates (and time) to ECEF frame
    ecef2lla: Convert ECEF coordinates to LLA position

    &#34;&#34;&#34;
    return ecef2lla(eci2ecef(eci_coordinates, time))</code></pre>
</details>
</dd>
<dt id="gps_frames.transforms.lla2ecef"><code class="name flex">
<span>def <span class="ident">lla2ecef</span></span>(<span>lla_coordinates:Â <built-inÂ functionÂ array>) â€‘>Â <built-inÂ functionÂ array></span>
</code></dt>
<dd>
<div class="desc"><p>Convert LLA to ECEF position.</p>
<p>Computes the ECEF position based on the WGS84 ellipsoid latitude,
longitude, and altitude. The inputs is are numpy arrays. Returns a
numpy array with columns representing the ECEF positions of the
elements of the inputs. From [1]_</p>
<p>Let <span><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>, <span><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span>, <span><span class="MathJax_Preview">h</span><script type="math/tex">h</script></span>, <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>, and <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> be the latitude,
longitude, altitude, WGS84 semi-major axis, and WGS84 eccentricity,
repsectively. The effective radius of the Earth is
<span><span class="MathJax_Preview">
n = \frac{a}{\sqrt{1 - (e\sin\lambda)^{2}}}
</span><script type="math/tex; mode=display">
n = \frac{a}{\sqrt{1 - (e\sin\lambda)^{2}}}
</script></span>
From this, the ECEF <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>, and <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span> positions can be computed as
<span><span class="MathJax_Preview">
\begin{split}
x = &amp; (n + h)\cos\lambda\cos\phi \\
y = &amp; (n + h)\cos\lambda\sin\phi \\
z = &amp; \left(n\left(1 - e^{2}\right) + h\right) \sin\lambda
\end{split}
</span><script type="math/tex; mode=display">
\begin{split}
x = & (n + h)\cos\lambda\cos\phi \\
y = & (n + h)\cos\lambda\sin\phi \\
z = & \left(n\left(1 - e^{2}\right) + h\right) \sin\lambda
\end{split}
</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lla_coordinates</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The WGS 84 latitude, longitude, and altitude (in that order)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The ECEF position of the given WGS84 LLA</dd>
</dl>
<h2 id="references">References</h2>
<p>.. [1] G. Xu and Y. Xu, "GPS: Theory, Algorithms and Applications" 3rd ed.
<a href="https://doi.org/10.1007/978-3-662-50367-6">https://doi.org/10.1007/978-3-662-50367-6</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(&#34;float64[:](float64[:])&#34;, nopython=True)
def lla2ecef(lla_coordinates: np.array) -&gt; np.array:
    r&#34;&#34;&#34;Convert LLA to ECEF position.

    Computes the ECEF position based on the WGS84 ellipsoid latitude,
    longitude, and altitude. The inputs is are numpy arrays. Returns a
    numpy array with columns representing the ECEF positions of the
    elements of the inputs. From [1]_

    Let \(\lambda\), \(\phi\), \(h\), \(a\), and \(e\) be the latitude,
    longitude, altitude, WGS84 semi-major axis, and WGS84 eccentricity,
    repsectively. The effective radius of the Earth is
    $$
        n = \frac{a}{\sqrt{1 - (e\sin\lambda)^{2}}}
    $$
    From this, the ECEF \(x\), \(y\), and \(z\) positions can be computed as
    $$
        \begin{split}
            x = &amp; (n + h)\cos\lambda\cos\phi \\
            y = &amp; (n + h)\cos\lambda\sin\phi \\
            z = &amp; \left(n\left(1 - e^{2}\right) + h\right) \sin\lambda
        \end{split}
    $$

    Parameters
    ----------
    lla_coordinates : np.ndarray
        The WGS 84 latitude, longitude, and altitude (in that order)

    Returns
    -------
    np.ndarray
        The ECEF position of the given WGS84 LLA

    References
    ----------
    .. [1] G. Xu and Y. Xu, &#34;GPS: Theory, Algorithms and Applications&#34; 3rd ed.
        https://doi.org/10.1007/978-3-662-50367-6

    &#34;&#34;&#34;
    latitude = lla_coordinates[0]
    longitude = lla_coordinates[1]
    altitude = lla_coordinates[2]

    n = _wgs84a / np.sqrt(1 - (_wgs84ecc * np.sin(latitude)) ** 2)

    x = (n + altitude) * np.cos(latitude) * np.cos(longitude)
    y = (n + altitude) * np.cos(latitude) * np.sin(longitude)
    z = (n * (1 - _wgs84ecc ** 2) + altitude) * np.sin(latitude)

    return np.array((x, y, z))</code></pre>
</details>
</dd>
<dt id="gps_frames.transforms.lla2eci"><code class="name flex">
<span>def <span class="ident">lla2eci</span></span>(<span>lla_coordinates:Â numpy.ndarray, time:Â float) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Tranform LLA coordinates into ECI.</p>
<p>This function is used to transform an LLA position into ECI coordinates.
To do this, the coordinates are first converted to ECEF coordinates using
<code><a title="gps_frames.transforms.lla2ecef" href="#gps_frames.transforms.lla2ecef">lla2ecef()</a></code>. Then, these new ECEF coordinates are transformed into ECI
coordinates using <code><a title="gps_frames.transforms.ecef2eci" href="#gps_frames.transforms.ecef2eci">ecef2eci()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lla_coordinates</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The Latitude, Longitude, Altitude position coordinates</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>GPSTime</code></dt>
<dd>The time at which the <code>lla_coordinates</code> are defined</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The position in the ECI frame</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="gps_frames.transforms.lla2ecef" href="#gps_frames.transforms.lla2ecef">lla2ecef()</a></code></dt>
<dd>Convert LLA coordinates to ECEF coordinates</dd>
<dt><code><a title="gps_frames.transforms.ecef2eci" href="#gps_frames.transforms.ecef2eci">ecef2eci()</a></code></dt>
<dd>Convert ECEF coordinates into ECI coordinates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(&#34;float64[:](float64[:], float64)&#34;, nopython=True)
def lla2eci(lla_coordinates: np.ndarray, time: float) -&gt; np.ndarray:
    &#34;&#34;&#34;Tranform LLA coordinates into ECI.

    This function is used to transform an LLA position into ECI coordinates.
    To do this, the coordinates are first converted to ECEF coordinates using
    `lla2ecef()`. Then, these new ECEF coordinates are transformed into ECI
    coordinates using `ecef2eci()`.

    Parameters
    ----------
    lla_coordinates : np.ndarray
        The Latitude, Longitude, Altitude position coordinates
    time : GPSTime
        The time at which the `lla_coordinates` are defined

    Returns
    -------
    np.ndarray
        The position in the ECI frame

    See Also
    --------
    lla2ecef: Convert LLA coordinates to ECEF coordinates
    ecef2eci: Convert ECEF coordinates into ECI coordinates

    &#34;&#34;&#34;
    return ecef2eci(lla2ecef(lla_coordinates), time)</code></pre>
</details>
</dd>
<dt id="gps_frames.transforms.position_transform"><code class="name flex">
<span>def <span class="ident">position_transform</span></span>(<span>from_frame:Â str, to_frame:Â str, coordinates:Â <built-inÂ functionÂ array>, time:Â gps_time.core.GPSTime) â€‘>Â <built-inÂ functionÂ array></span>
</code></dt>
<dd>
<div class="desc"><p>Convert a position from one frame to another.</p>
<p>The purpose of this function is to create a general tool to convert a
position from one frame to another. The current frame is given as the
<code>from_frame</code> and the desired new output frame is given as the <code>to_frame</code>.
The position is defined in the <code>from_frame</code> as the <code>coordinates</code>. The
<code>time</code> is used to define the time of the frame, as some conversions
between frames vary with time, e.g. ECEF to ECI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>from_frame</code></strong> :&ensp;<code>str</code></dt>
<dd>The frame in which the input coordinates are defined</dd>
<dt><strong><code>to_frame</code></strong> :&ensp;<code>str</code></dt>
<dd>The frame that the coordinates should be provided in</dd>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The coordinates in the <code>from_frame</code></dd>
<dt><strong><code>time</code></strong> :&ensp;<code>GPSTime</code></dt>
<dd>The time at which the <code>from_frame</code> and <code>to_frame</code> are aligned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The coordinates in the <code>to_frame</code></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>If the <code>from_frame</code> or <code>to_frame</code> are not valid frames</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="gps_frames.transforms.VALID_FRAMES" href="#gps_frames.transforms.VALID_FRAMES">VALID_FRAMES</a></code></dt>
<dd>A list of the valid frames for the <code>from_frame</code> and <code>to_frame</code> args</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function is used to transform a position in one frame to another. The
time is the same for both the <code>from_frame</code> and <code>to_frame</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def position_transform(
    from_frame: str, to_frame: str, coordinates: np.array, time: GPSTime
) -&gt; np.array:
    &#34;&#34;&#34;Convert a position from one frame to another.

    The purpose of this function is to create a general tool to convert a
    position from one frame to another. The current frame is given as the
    `from_frame` and the desired new output frame is given as the `to_frame`.
    The position is defined in the `from_frame` as the `coordinates`. The
    `time` is used to define the time of the frame, as some conversions
    between frames vary with time, e.g. ECEF to ECI.

    Parameters
    ----------
    from_frame : str
        The frame in which the input coordinates are defined
    to_frame : str
        The frame that the coordinates should be provided in
    coordinates : np.ndarray
        The coordinates in the `from_frame`
    time : GPSTime
        The time at which the `from_frame` and `to_frame` are aligned.

    Returns
    -------
    np.ndarray
        The coordinates in the `to_frame`

    Raises
    ------
    NotImplementedError
        If the `from_frame` or `to_frame` are not valid frames

    See Also
    --------
    VALID_FRAMES: A list of the valid frames for the `from_frame` and
        `to_frame` args

    Notes
    -----
    This function is used to transform a position in one frame to another. The
    time is the same for both the `from_frame` and `to_frame`

    &#34;&#34;&#34;

    if not isinstance(coordinates, np.ndarray):
        coordinates = np.array(coordinates, dtype=float)
    if from_frame not in VALID_FRAMES:
        raise NotImplementedError(f&#34;(from_frame) Unknown Frame: {from_frame}&#34;)
    if to_frame not in VALID_FRAMES:
        raise NotImplementedError(f&#34;(to_frame) Unknown Frame: {to_frame}&#34;)

    if from_frame == &#34;LLA&#34;:
        if to_frame == &#34;LLA&#34;:
            return coordinates
        elif to_frame == &#34;ECEF&#34;:
            return lla2ecef(coordinates)
        elif to_frame == &#34;ECI&#34;:
            return lla2eci(coordinates, time.time_of_week)
    elif from_frame == &#34;ECEF&#34;:
        if to_frame == &#34;LLA&#34;:
            return ecef2lla(coordinates)
        elif to_frame == &#34;ECEF&#34;:
            return coordinates
        elif to_frame == &#34;ECI&#34;:
            return ecef2eci(coordinates, time.time_of_week)
    elif from_frame == &#34;ECI&#34;:
        if to_frame == &#34;LLA&#34;:
            return eci2lla(coordinates, time.time_of_week)
        elif to_frame == &#34;ECEF&#34;:
            return eci2ecef(coordinates, time.time_of_week)
        elif to_frame == &#34;ECI&#34;:
            return coordinates

    logger.critical(&#34;Transformation Failed. Returning input&#34;)
    return coordinates</code></pre>
</details>
</dd>
<dt id="gps_frames.transforms.rotate_ecef"><code class="name flex">
<span>def <span class="ident">rotate_ecef</span></span>(<span>old_time:Â gps_time.core.GPSTime, new_time:Â gps_time.core.GPSTime, coordinates:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate the coordinates in one ECEF frame to a new ECEF frame.</p>
<p>Because the Earth is rotating, the ECEF frame is constantly moving and the
coordinates in the ECEF frame at one time are different than the
coordinates at some other time. This function uses the time between
<code>old_time</code> and <code>new_time</code> to determine how much the ECEF frame rotates and
updates the coordinates accordingly.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>old_time</code></strong> :&ensp;<code>GPSTime</code></dt>
<dd>The time for the ECEF frame where the <code>coordinates</code> are defined</dd>
<dt><strong><code>new_time</code></strong> :&ensp;<code>GPSTime</code></dt>
<dd>The time of the new ECEF frame</dd>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The coordinates in the <code>old_time</code> ECEF frame</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The coordinates in the <code>new_time</code> ECEF frame</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>standard_rotation_matrix</code></dt>
<dd>Used to get the rotation matrix for the transformation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_ecef(
    old_time: GPSTime, new_time: GPSTime, coordinates: np.ndarray
) -&gt; np.ndarray:
    &#34;&#34;&#34;Rotate the coordinates in one ECEF frame to a new ECEF frame.

    Because the Earth is rotating, the ECEF frame is constantly moving and the
    coordinates in the ECEF frame at one time are different than the
    coordinates at some other time. This function uses the time between
    `old_time` and `new_time` to determine how much the ECEF frame rotates and
    updates the coordinates accordingly.

    Parameters
    ----------
    old_time : GPSTime
        The time for the ECEF frame where the `coordinates` are defined
    new_time : GPSTime
        The time of the new ECEF frame
    coordinates : np.ndarray
        The coordinates in the `old_time` ECEF frame

    Returns
    -------
    np.ndarray
        The coordinates in the `new_time` ECEF frame

    See Also
    --------
    standard_rotation_matrix: Used to get the rotation matrix for the
        transformation

    &#34;&#34;&#34;
    time_delta = new_time - old_time
    assert isinstance(time_delta, float)

    angle_delta = _w_e * time_delta
    coordinates = np.array(coordinates, dtype=float)

    # rotation = Rotation(dcm=standard_rotation_matrix(3, angle_delta))

    return standard_rotation(3, angle_delta, coordinates)</code></pre>
</details>
</dd>
<dt id="gps_frames.transforms.velocity_transform"><code class="name flex">
<span>def <span class="ident">velocity_transform</span></span>(<span>from_frame:Â str, to_frame:Â str, position_coordinates:Â numpy.ndarray, velocity_components:Â numpy.ndarray, time:Â gps_time.core.GPSTime) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transform velocity from one frame to another.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>from_frame</code></strong> :&ensp;<code>str</code></dt>
<dd>The starting frame</dd>
<dt><strong><code>to_frame</code></strong> :&ensp;<code>str</code></dt>
<dd>The desired frame</dd>
<dt><strong><code>position_coordinates</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The position coordinates in the starting frame</dd>
<dt><strong><code>velocity_components</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The velocity components in the starting from</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>GPSTime</code></dt>
<dd>The time that the transformation is taking place</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The velocity components in the destination frame</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Does not work with the 'LLA' frame, so raises an error if the to_frame
or from_frame are specified as 'LLA'. Will also raise if the to_frame
or from_frame are not valid frames.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def velocity_transform(
    from_frame: str,
    to_frame: str,
    position_coordinates: np.ndarray,
    velocity_components: np.ndarray,
    time: GPSTime,
) -&gt; np.ndarray:
    &#34;&#34;&#34;Transform velocity from one frame to another.

    Parameters
    ----------
    from_frame : str
        The starting frame
    to_frame : str
        The desired frame
    position_coordinates : np.ndarray
        The position coordinates in the starting frame
    velocity_components : np.ndarray
        The velocity components in the starting from
    time : GPSTime
        The time that the transformation is taking place

    Returns
    -------
    np.ndarray
        The velocity components in the destination frame

    Raises
    ------
    ValueError
        Does not work with the &#39;LLA&#39; frame, so raises an error if the to_frame
        or from_frame are specified as &#39;LLA&#39;. Will also raise if the to_frame
        or from_frame are not valid frames.
    &#34;&#34;&#34;
    position_coordinates = np.array(position_coordinates)
    velocity_components = np.array(velocity_components)
    if from_frame == &#34;LLA&#34; or to_frame == &#34;LLA&#34;:
        raise ValueError(&#34;from_frame and to_frame cannot be LLA&#34;)

    if from_frame not in VALID_FRAMES:
        raise ValueError(f&#34;from_frame ({from_frame}) not valid&#34;)
    if to_frame not in VALID_FRAMES:
        raise ValueError(f&#34;to_frame ({to_frame}) not valid&#34;)

    if from_frame == &#34;ECEF&#34;:
        if to_frame == &#34;ECEF&#34;:
            angle_of_rotation = 0.0
            rotation_rate = 0.0
        elif to_frame == &#34;ECI&#34;:
            angle_of_rotation = -_w_e * time.time_of_week
            rotation_rate = -_w_e
    elif from_frame == &#34;ECI&#34;:
        if to_frame == &#34;ECEF&#34;:
            angle_of_rotation = _w_e * time.time_of_week
            rotation_rate = _w_e
        elif to_frame == &#34;ECI&#34;:
            angle_of_rotation = 0.0
            rotation_rate = 0.0

    rotation = Rotation(dcm=standard_rotation_matrix(3, angle_of_rotation))
    rate_matrix = standard_rotation_matrix_rates(3, angle_of_rotation, rotation_rate)

    return rotation.rotate(velocity_components) + rate_matrix @ position_coordinates</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#todo">Todo</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gps_frames" href="index.html">gps_frames</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="gps_frames.transforms.VALID_FRAMES" href="#gps_frames.transforms.VALID_FRAMES">VALID_FRAMES</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="gps_frames.transforms.add_weeks_eci" href="#gps_frames.transforms.add_weeks_eci">add_weeks_eci</a></code></li>
<li><code><a title="gps_frames.transforms.ecef2eci" href="#gps_frames.transforms.ecef2eci">ecef2eci</a></code></li>
<li><code><a title="gps_frames.transforms.ecef2lla" href="#gps_frames.transforms.ecef2lla">ecef2lla</a></code></li>
<li><code><a title="gps_frames.transforms.eci2ecef" href="#gps_frames.transforms.eci2ecef">eci2ecef</a></code></li>
<li><code><a title="gps_frames.transforms.eci2lla" href="#gps_frames.transforms.eci2lla">eci2lla</a></code></li>
<li><code><a title="gps_frames.transforms.lla2ecef" href="#gps_frames.transforms.lla2ecef">lla2ecef</a></code></li>
<li><code><a title="gps_frames.transforms.lla2eci" href="#gps_frames.transforms.lla2eci">lla2eci</a></code></li>
<li><code><a title="gps_frames.transforms.position_transform" href="#gps_frames.transforms.position_transform">position_transform</a></code></li>
<li><code><a title="gps_frames.transforms.rotate_ecef" href="#gps_frames.transforms.rotate_ecef">rotate_ecef</a></code></li>
<li><code><a title="gps_frames.transforms.velocity_transform" href="#gps_frames.transforms.velocity_transform">velocity_transform</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>